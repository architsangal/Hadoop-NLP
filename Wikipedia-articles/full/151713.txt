[ Computer science ] A one instruction set computer (OISC), sometimes called an ultimate reduced instruction set computer (URISC), is an abstract machine that uses only one instruction – obviating the need for a machine language opcode. With a judicious choice for the single instruction and given infinite resources, an OISC is capable of being a universal computer in the same manner as traditional computers that have multiple instructions. [ 55 ] OISCs have been recommended as aids in teaching computer architecture [ 327 ] [ 2 ] and have been used as computational models in structural computing research. [ Machine architecture ] In a Turing-complete model, each memory location can store an arbitrary integer, and – depending on the model – there may be arbitrarily many locations. The instructions themselves reside in memory as a sequence of such integers. There exists a class of universal computers with one instruction based on bit manipulation such as bit copying or bit inversion. Since their memory model is the same as memory structure used in real computers, those bit manipulation machines are equivalent to real computers rather than to Turing machines. { Oleg Mazonka, &quot; Bit Copying: The Ultimate Computational Simplicity &quot;, Complex Systems Journal 2011, Vol 19, N3, pp. 263-285 } Currently known OISC can be roughly separated into three broad categories: Transport Triggered Architecture Machines; Bit Manipulating Machines; Arithmetic Based Turing-Complete Machines. Transport Triggered Architecture (TTA) is a design in which computation is a side effect of data transport. Usually some memory registers (triggering ports) within common address space, perform an assigned operation when the instruction references them. For example, in an OISC utilizing a single memory-to-memory copy instruction, this is done by triggering ports performing arithmetic and instruction pointer jumps when writing into them. Bit Manipulating Machines is the simplest class. A bit copying machine, called BitBitJump, copies one bit in memory and passes the execution unconditionally to the address specified by one of the operands of the instruction. This process turns out to be capable of universal computation (i.e. being able to execute any algorithm and to interpret any other universal machine) because copying bits can conditionally modify the code ahead to be executed. Another machine, called the Toga computer, inverts a bit and passes the execution conditionally depending on the result of inversion. Yet another bit operating machine, similar to BitBitJump, copies several bits at the same time. The problem of computational universality is solved in this case by keeping predefined jump tables in the memory. Arithmetic based Turing-complete Machines use an arithmetic operation and a conditional jump. Unlike the two previous classes which are universal computers, this class is universal and Turing-complete in its abstract representation. The instruction operates on integers which may also be addresses in memory. Currently there are several known OISCs of this class, based on different arithmetic operations: addition (Addleq), decrement (DJN), increment (P1eq), and subtraction (Subleq). The latter is the oldest, the most popular and, arguably, the most efficient. [ Instruction types ] Common choices for the single instruction are: Subtract and branch if less than or equal to zero Subtract and branch if negative Reverse subtract and skip if borrow Move (used as part of a transport triggered architecture) Only one of these instructions is used in a given implementation. Hence, there is no need for an opcode to identify which instruction to execute; the choice of instruction is inherent in the design of the machine, and an OISC is typically named after the instruction it uses (e.g., an SBN OISC, [ 41 ] the SUBLEQ language, [ 4 ] etc.). Each of the above instructions can be used to construct a Turing-complete OISC. This article presents only subtraction-based instructions among those that are not transport triggered. However it is possible to build Turing complete machine using an instruction based on other arithmetic operations, e.g., addition. For example, one variation known as DLN (Decrement and jump if not zero) has only two operands and uses decrement as the base operation. For more information see Subleq derivative languages. [ Subtract and branch if less than or equal to zero ] The subleq instruction ( &quot; SUbtract and Branch if Less than or EQual to zero &quot; ) subtracts the contents at address a from the contents at address b, stores the result at address b, and then, if the result is not positive, transfers control to address c (if the result is positive, execution proceeds to the next instruction in sequence). [ 4-7 ] Pseudocode : { subleq a, b, c; Mem[b] = Mem[b] - Mem[a] } {; if (Mem[b] &amp; le; 0) goto c } Conditional branching can be suppressed by setting the third operand equal to the address of the next instruction in sequence. If the third operand is not written, this suppression is implied. A variant is also possible with two operands and an internal accumulator, where the accumulator is subtracted from the memory location specified by the first operand. The result is stored in both the accumulator and the memory location, and the second operand specifies the branch address: { subleq2 a, b; Mem[a] = Mem[a] - ACCUM } {; ACCUM = Mem[a] } {; if (Mem[a] &amp; le; 0) goto b } Although this uses only two (instead of three) operands per instruction, correspondingly more instructions are then needed to effect various logical operations. [ Synthesized instructions ] It is possible to synthesize many types of higher-order instructions using only the subleq instruction. [ 9-10 ] Unconditional branch: { JMP c == subleq Z, Z, c; Z is a location previously set to contain 0 } Addition can be performed by repeated subtraction, with no conditional branching; e.g., the following instructions result in the content at location a being added to the content at location b: { ADD a, b == subleq a, Z } { subleq Z, b } { subleq Z, Z } The first instruction subtracts the content at location a from the content at location Z (which is 0) and stores the result (which is the negative of the content at a) in location Z. The second instruction subtracts this result from b, storing in b this difference (which is now the sum of the contents originally at a and b); the third instruction restores the value 0 to Z. A copy instruction can be implemented similarly; e.g., the following instructions result in the content at location b getting replaced by the content at location a, again assuming the content at location Z is maintained as 0: { MOV a, b == subleq b, b } { subleq a, Z } { subleq Z, b } { subleq Z, Z } Any desired arithmetic test can be built. For example, a branch-if-zero condition can be assembled from the following instructions: { BEQ b, c == subleq b, Z, L1 } { subleq Z, Z, OUT } { L1: subleq Z, Z } { subleq Z, b, c } { OUT:... } Subleq2 can also be used to synthesize higher-order instructions, although it generally requires more operations for a given task. For example no fewer than 10 subleq2 instructions are required to flip all the bits in a given byte: { NOT a == subleq2 tmp; tmp = 0 (tmp = temporary register) } { subleq2 tmp } { subleq2 minus_one; acc = -1 } { subleq2 a; a&apos; = a + 1 } { subleq2 Z; Z = - a - 1 } { subleq2 tmp; tmp = a + 1 } { subleq2 a; a&apos; = 0 } { subleq2 tmp; load tmp into acc } { subleq2 a; a&apos; = - a - 1 ( = ~a ) } { subleq2 Z; set Z back to 0 } [ Emulation ] The following program (written in pseudocode ) emulates the execution of a subleq -based OISC: { integer memory[], program_counter, a, b, c } { program_counter = 0 } { while (program_counter &gt; = 0): } { a = memory[program_counter] } { b = memory[program_counter+1] } { c = memory[program_counter+2] } { if (a &lt; 0 or b &lt; 0): } { program_counter = -1 } { else: } { memory[b] = memory[b] - memory[a] } { if (memory[b] &gt; 0): } { program_counter = program_counter + 3 } { else: } { program_counter = c } This program assumes that memory[] is indexed by nonnegative integers. Consequently, for a subleq instruction (a, b, c), the program interprets a &lt; 0, b &lt; 0, or an executed branch to c &lt; 0 as a halting condition. Similar interpreters written in a subleq -based language (i.e., self-interpreter s, which may use self-modifying code as allowed by the nature of the subleq instruction) can be found in the external links below. [ Compilation ] There is a compiler called Higher Subleq written by Oleg Mazonka that compiles a simplified C program into subleq code. { Oleg Mazonka A Simple Multi-Processor Computer Based on Subleq } [ Subtract and branch if negative ] The subneg instruction ( &quot; SUbtract and Branch if NEGative &quot; ), also called SBN, is defined similarly to subleq : [ 41,51-52 ] { subneg a, b, c; Mem[b] = Mem[b] - Mem[a] } {; if (Mem[b] &lt; 0) goto c } Conditional branching can be suppressed by setting the third operand equal to the address of the next instruction in sequence. If the third operand is not written, this suppression is implied. [ Synthesized instructions ] It is possible to synthesize many types of higher-order instructions using only the subneg instruction. For simplicity, only one synthesized instruction is shown here to illustrate the difference between subleq and subneg. Unconditional branch: [ 88-89 ] { JMP c == subneg POS, Z, c } {... } { c: subneg Z, Z } where Z and POS are locations previously set to contain 0 and a positive integer, respectively; Unconditional branching is assured only if Z initially contains 0 (or a value less than the integer stored in POS). A follow-up instruction is required to clear Z after the branching, assuming that the content of Z must be maintained as 0. [ Reverse subtract and skip if borrow ] In a Reverse Subtract and Skip if Borrow (RSSB) instruction, the accumulator is subtracted from the memory location and the next instruction is skipped if there was a borrow (memory location was smaller than the accumulator). The result is stored in both the accumulator and the memory location. The program counter is mapped to memory location 0. The accumulator is mapped to memory location 1. [ Example ] To set x to the value of y minus z: { # First, move z to the destination location x. } { RSSB temp # Three instructions required to clear acc, temp } { RSSB temp } { RSSB temp } { RSSB x # Two instructions clear acc, x, since acc is already clear } { RSSB x } { RSSB y # Load y into acc: no borrow } { RSSB temp # Store -y into acc, temp: always borrow and skip } { RSSB temp # Skipped } { RSSB x # Store y into x, acc } { # Second, perform the operation. } { RSSB temp # Three instructions required to clear acc, temp } { RSSB temp } { RSSB temp } { RSSB z # Load z } { RSSB x # x = y - z } [ Transport triggered architecture ] [ transport triggered architecture ] A transport triggered architecture uses only the move instruction, hence it was originally called a &quot; move machine &quot;. This instruction moves the contents of one memory location to another memory location: [ 42 ] { move a to b; Mem[b] := Mem[a] } sometimes written as: { a - &gt; b; Mem[b] := Mem[a] } Arithmetic is performed using a memory-mapped arithmetic logic unit and jumps are performed using a memory-mapped program counter. A commercial transport triggered architecture microcontroller has been produced called MAXQ, which hides the apparent inconvenience of an OISC by using a &quot; transfer map &quot; that represents all possible destinations for the move instructions. [ See also ] [ Computer science ] Turing tarpit [ References ] [ Mavaddat F. Parhami, B. URISC: The Ultimate Reduced Instruction Set Computer Int&apos;l J. Electrical Engineering Education 25 4 327–334 Manchester University Press October 1988 http://www.ece.ucsb.edu/~parhami/pubs_folder/parh88-ijeee-ultimate-risc.pdf 2010-10-04 ] { This paper considers &quot; a machine with a single 3-address instruction as the ultimate in RISC design (URISC) &quot;. Without giving a name to the instruction, it describes a SBN OISC and its associated assembly language, emphasising that this is a universal (i.e., } { Turing-complete ) machine whose simplicity makes it ideal for classroom use. } [ Gilreath William F. Laplante, Phillip A. Computer Architecture: A Minimalist Perspective Springer Science+Business Media 2003 http://www.caamp.info 978-1-4020-7416-5 ] { Intended for researchers, computer system engineers, computational theorists and students, this book provides an in-depth examination of various OISCs, including SBN and MOVE. It attributes SBN to W. L. van der Poel (1956). } [ Nürnberg Peter J. Wiil, Uffe K.; Hicks, David L. Metainformatics: International Symposium, MIS 2003 Graz, Austria Springer Science+Business Media 2003 September A Grand Unified Theory for Structural Computing http://books.google.com/books?id%3DuxjigT31ns4C%26amp%3Blpg%3DPP5%26amp%3Bpg%3DPA1#v%3Donepage 1–16 http://www.informatik.uni-trier.de/~ley/db/conf/metainformatics/metainformatics2003.html 978-3-540-22010-7 ] { This research paper focusses entirely on a SUBLEQ OISC and its associated assembly language, using the name SUBLEQ for &quot; both the instruction and any language based upon it &quot;. } [ Jones Douglas W. The Ultimate RISC ACM SIGARCH Computer Architecture News 16 3 48–55 ACM New York June 1988 http://www.cs.uiowa.edu/~jones/arch/risc/ 10.1145/48675.48683 2010-10-04 ] { &quot; Reduced instruction set computer architectures have attracted considerable interest since 1980. The ultimate RISC architecture presented here is an extreme yet simple illustration of such an architecture. It has only one instruction, move memory to memory, yet it is useful. &quot; } [ Catsoulis John Designing embedded hardware O&apos;Reilly Media 2005 2 327–333 978-0-596-00755-3 ] [ External links ] { * Subleq on the esoteric programming languages wiki – Interpreters, compilers, examples and derivative languages } Laboratory subleq computer – FPGA implementation using VHDL The Retrocomputing Museum – SBN emulator and sample programs Laboratory SBN computer – Implemented with 7400 series integrated circuits RSSB on the esoteric programming languages wiki – Interpreters and examples Dr. Dobb&apos;s 32-bit OISC implemention – Transport triggered architecture on an FPGA using Verilog Introduction to the MAXQ Architecture – Includes transfer map diagram OISC-Emulator – Graphical version Category:Models of computation Category:Esoteric programming languages it:One instruction set computer ru:URISC simple:One instruction set computer zh:單一指令集