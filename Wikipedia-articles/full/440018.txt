In computer programming with object-oriented programming language s, duck typing is a style of dynamic typing in which an object&apos;s current set of method s and properties determines the valid semantics, rather than its inheritance from a particular class or implementation of a specific interface. The name of the concept refers to the duck test, attributed to James Whitcomb Riley (see history below), which may be phrased as follows: [ Heim Michael Exploring Indiana Highways 68 http://books.google.com/books?id%3Dj7zds6xx7S0C%26amp%3Bpg%3DPA68%26amp%3Bdq%3D%22james%2BRiley%22%2BOR%2B%22James%2BWhitcomb%2BRiley%22%2Bbird%2B%2Bduck%26amp%3Bnum%3D100 978-0-9744358-3-1 2007 Exploring America&apos;s Highway ] When I see a bird that walks like a duck and swims like a duck and quacks like a duck, I call that bird a duck. In duck typing, one is concerned with just those aspects of an object that are used, rather than with the type of the object itself. For example, in a non-duck-typed language, one can create a function that takes an object of type Duck and calls that object&apos;s walk and quack methods. In a duck-typed language, the equivalent function would take an object of any type and call that object&apos;s walk and quack methods. If the object does not have the methods that are called then the function signals a run-time error. If the object does have the methods, then they are executed no matter the type of the object, evoking the quotation and hence the name of this form of typing. Duck typing is aided by habitually not testing for the type of arguments in method and function bodies, relying on documentation, clear code and testing to ensure correct use. [ Concept examples ] Consider the following pseudo-code for a duck-typed language: { function calculate(a, b, c) = &gt; return (a+b)*c } { example1 = calculate (1, 2, 3) } { example2 = calculate ([1, 2, 3], [4, 5, 6], 2) } { example3 = calculate (&apos;apples &apos;, &apos;and oranges, &apos;, 3) } { print to_string example1 } { print to_string example2 } { print to_string example3 } In the example, each time the calculate function is called, objects without related inheritance may be used (numbers, lists and strings). As long as the objects support the &quot; + &quot; and &quot; * &quot; methods, the operation will succeed. If translated to Ruby or Python, for example, the result of the code would be: { 9 } { [1, 2, 3, 4, 5, 6, 1, 2, 3, 4, 5, 6] } { apples and oranges, apples and oranges, apples and oranges, } Thus, duck typing allows polymorphism without inheritance. The only restriction that function calculate places on its variables is that they implement the &quot; + &quot; and the &quot; * &quot; methods. The duck test can be seen in the following example (in Python). As far as the function in_the_forest is concerned, the Person object is a duck: class Duck: { def quack(self): } { print( &quot; Quaaaaaack! &quot; ) } { def feathers(self): } { print( &quot; The duck has white and gray feathers. &quot; ) } class Person: { def quack(self): } { print( &quot; The person imitates a duck. &quot; ) } { def feathers(self): } { print( &quot; The person takes a feather from the ground and shows it. &quot; ) } { def name(self): } { print( &quot; John Smith &quot; ) } def in_the_forest(duck): { duck.quack() } { duck.feathers() } def game(): { donald = Duck() } { john = Person() } { in_the_forest(donald) } { in_the_forest(john) } game() [ In statically typed languages ] Certain usually statically typed languages such as Boo and the version 4 release of C# have extra type annotations { Boo: Duck Typing } { Anders Hejlsberg Introduces C# 4.0 at PDC 2008 } that instruct the compiler to arrange for type checking of classes to occur at run-time rather than compile time, and include run-time type checking code in the compiled output. Such additions allow the language to enjoy most of the benefits of duck typing with the only drawback being the need to identify and specify such dynamic classes at compile time. [ Comparison with other type systems ] [ Structural type systems ] Duck typing is similar to but distinct from structural typing. Structural typing is a static typing system that determines type compatibility and equivalence by a type&apos;s structure, whereas duck typing is dynamic and determines type compatibility by only that part of a type&apos;s structure that is accessed during run time. The OCaml, Scala, and Go languages use structural type systems. [ Protocols and Interfaces ] Protocols and interfaces can provide some of the benefits of duck typing but duck typing is distinct in that no explicit interface is defined. For example, if a third party Java library implements a class you are not allowed to modify, you cannot use an instance of the class in place of an interface you have defined yourself, whereas duck typing would allow this. Again, all of an interface must be satisfied for compatibility. [ Templates or generic types ] Template, or generic functions or methods apply the duck test in a static typing context; this brings all the advantages and disadvantages of static versus dynamic type checking in general. Duck typing can also be more flexible in that only the methods actually called at run time need to be implemented, while templates require implementation of all methods that cannot be proven unreachable at compile time. Examples include the languages C++ and D with templates, which developed from Ada generics. [ Criticism ] One issue with duck typing is that it forces the programmer to have a much wider understanding of the code he or she is working with at any given time. In a strongly and statically typed language that uses type hierarchies and parameter type checking, it&apos;s much harder to supply an unexpected object type to a class. For instance, in Python, you could easily create a class called Wine, which expects a class implementing the &quot; press &quot; attribute as an ingredient. However, a class called Trousers might also implement the press() method. With Duck Typing, in order to prevent strange, hard-to-detect errors, the developer needs to be aware of each potential use of the method &quot; press &quot;, even when it&apos;s conceptually unrelated to what he or she is working on. In essence, the problem is that, &quot; if it walks like a duck and quacks like a duck &quot;, it could be a dragon doing a duck impersonation. You may not always want to let dragons into a pond, even if they can impersonate a duck. Proponents of duck typing, such as Guido van Rossum, argue that the issue is handled by testing, and the necessary knowledge of the codebase required to maintain it. [ http://www.mindviewinc.com/Blog/OldestIndex.php Strong Typing vs. Strong Testing Bruce Eckel mindview ] [ http://www.artima.com/intv/pycontract.html Contracts in Python. A Conversation with Guido van Rossum, Part IV Bill Venners Artima ] Criticisms around duck typing tend to be special cases of broader points of contention regarding dynamically typed versus statically typed programming language semantics. [ March 2011 ] [ History ] Alex Martelli made an early (2000) use of the term in a message to the comp.lang.python newsgroup. He also highlighted misunderstanding of the literal duck test, which may indicate that the term was already in use: In other words, don&apos;t check whether it IS-a duck: check whether it QUACKS-like-a duck, WALKS-like-a duck, etc, etc, depending on exactly what subset of duck-like behaviour you need to play your language-games with. [ Implementations ] [ In C# ] In C# 4.0 the compiler and runtime collaborate to implement dynamic member lookup. Notice how parameter duck is declared dynamic in method InTheForest of class Program. namespace DuckTyping{ { using System; } { public class Duck } { { } { public void Quack() } { { } { Console.WriteLine( &quot; Quaaaaaack! &quot; ); } { } } { public void Feathers() } { { } { Console.WriteLine( &quot; The duck has white and gray feathers. &quot; ); } { } } { } } { public class Person } { { } { public void Quack() } { { } { Console.WriteLine( &quot; The person imitates a duck. &quot; ); } { } } { public void Feathers() } { { } { Console.WriteLine( &quot; The person takes a feather from the ground and shows it. &quot; ); } { } } { } } { internal class Program } { { } { private static void InTheForest(dynamic duck) } { { } { duck.Quack(); } { duck.Feathers(); } { } } { private static void Game() } { { } { Duck donald = new Duck(); } { Person john = new Person(); } { InTheForest(donald); } { InTheForest(john); } { } } { private static void Main() } { { } { Game(); } { } } { } } } [ In Cobra ] In addition to static typing, Cobra allows one to declare objects of type &apos;dynamic&apos; and send any message to them. At run-time the message passing will either succeed or throw an exception. The &apos;dynamic&apos; type is the default for object variables and method arguments when a type has not been explicitly declared for them. This feature was inspired by Objective-C. [ http://cobra-language.com/docs/acknowledgements/ Cobra - Acknowledgements cobra-language.com 2010-04-07 ] [ In ColdFusion ] The web application scripting language ColdFusion allows function arguments to be specified as having type any. For this sort of argument, an arbitrary object can be passed in and method calls are bound dynamically at runtime. If an object does not implement a called method, a runtime exception is thrown which can be caught and handled gracefully. In ColdFusion 8, this can be picked up as a defined event onMissingMethod() rather than through an exception handler. An alternative argument type of WEB-INF.cftags.component restricts the passed argument to be a ColdFusion Component (CFC), which provides better error messages should a non-object be passed in. [ In Common Lisp ] Common Lisp provides an object-oriented extension ( Common Lisp Object System, or shorter CLOS). The combination of CLOS and Lisp&apos;s dynamic typing make duck typing a common programming style in Common Lisp. With Common Lisp one also does not need to query the types, since at runtime an error will be signaled when a function is not applicable. The error can be handled with the Condition System of Common Lisp. Methods are defined outside of classes and can also be defined for specific objects. We describe a protocol for &apos;duck-like&apos; objects. Objects with methods for these three generic functions may be considered &apos;ducks&apos;, for all intents and purposes -- regardless of their superclass. (defgeneric quack (something))(defgeneric feathers (something)) Implementation of the protocol for class DUCK. (defclass duck () ()) (defmethod quack ((a-duck duck)) { (print &quot; Quaaaaaack! &quot; )) } (defmethod feathers ((a-duck duck)) { (print &quot; The duck has white and gray feathers. &quot; )) } But we can also implement it for PERSON, without inheriting from DUCK. (defclass person () ()) (defmethod quack ((a-person person)) { (print &quot; The person imitates a duck. &quot; )) } (defmethod feathers ((a-person person)) { (print &quot; The person takes a feather from the ground and shows it. &quot; )) } IN-THE-FOREST does not need to be polymorphic. Its &apos;duck&apos; argument is anything that implements the duck protocol above. (defun in-the-forest (duck) { (quack duck) } { (feathers duck)) } GAME can also just be a regular function. (defun game () { (let ((donald (make-instance &apos;duck)) } { (john (make-instance &apos;person))) } { (in-the-forest donald) } { (in-the-forest john))) } (game) The usual development style of Common Lisp (by using a Lisp REPL like SLIME ) allows also the interactive repair: ? (defclass cat () ()) &lt; STANDARD-CLASS CAT &gt; ? (quack (make-instance &apos;cat)) &gt; Error: There is no applicable method for the generic function: &gt; # &lt; STANDARD-GENERIC-FUNCTION QUACK #x300041C2371F &gt; &gt; when called with arguments: &gt; (# &lt; CAT #x300041C7EEFD &gt; ) &gt; If continued: Try calling it again1 &gt; (defmethod quack ((a-cat cat)) { (print &quot; The cat imitates a duck. &quot; )) } &lt; STANDARD-METHOD QUACK (CAT) &gt; 1 &gt; (continue) &quot; The cat imitates a duck. &quot; This way software can be developed by extending partially working duck typed code. [ In JavaScript ] var Duck = function(){ { this.quack = function(){alert(&apos;Quaaaaaack!&apos;);}; } { this.feathers = function(){alert(&apos;The duck has white and gray feathers.&apos;);}; } { return this; } }; var Person = function(){ { this.quack = function(){alert(&apos;The person imitates a duck.&apos;);}; } { this.feathers = function(){alert(&apos;The person takes a feather from the ground and shows it.&apos;);}; } { this.name = function(){alert(&apos;John Smith&apos;);}; } { return this; } }; var in_the_forest = function(duck){ { duck.quack(); } { duck.feathers(); } }; var game = function(){ { var donald = new Duck; } { var john = new Person; } { in_the_forest(donald); } { in_the_forest(john); } }; game(); [ In Lua ] Lua supports duck typing as part of the Metatable weak-typing system. Any reference to a table&apos;s member function is checked dynamically at run-time. If an object does not implement the requested function, a run-time error is produced. If a data member is requested but does not exist, a nil value is returned. local duck_mt = { }local duck_methods = {}duck_mt.__index = duck_methods function duck_methods:quack ( ) print ( &quot; Quaaaaaack! &quot; )end function duck_methods:feathers ( ) return &quot; The duck has white and gray feathers. &quot; end function new_duck() return setmetatable ( { }, duck_mt )end local person_mt = { }local person_methods = {}person_mt.__index = person_methods function person_methods:quack ( ) print ( &quot; The person imitates a duck. &quot; )end function person_methods:feathers ( ) return &quot; The person takes a feather from the ground and shows it. &quot; end function person_methods:get_name ( ) return self.firstname.. &quot; &quot;.. self.lastnameend function new_person ( t ) return setmetatable ( t or {}, person_mt )end local function in_the_forest ( duck ) duck:quack() print(duck:feathers())end local donald = new_duck()local john = new_person { firstname= &quot; John &quot;, lastname= &quot; Smith &quot; }in_the_forest(donald)in_the_forest(john) [ In Objective-C ] Objective-C, a cross between C and Smalltalk, allows one to declare objects of type &apos;id&apos; and send any message to them (provided the method is declared somewhere), like in Smalltalk. The sender can test an object to see if it responds to a message, the object can decide at the time of the message whether it will respond to it or not, and if the sender sends a message a recipient cannot respond to, an exception is raised. Thus, duck typing is fully supported by Objective-C. [ In Perl ] Perl looks for method definitions in package set with bless function. use strict; package Duck; sub hatch { { bless \(my $self), shift; } }sub quack { { print &quot; Quaaaaaack!\n &quot;; } }sub feathers { { print &quot; The duck has white and gray feathers.\n &quot;; } } package Person; sub accept_birth { { bless \(my $self), shift; } }sub quack { { print &quot; The person imitates a duck.\n &quot;; } }sub feathers { { print &quot; The person takes a feather from the ground and shows it.\n &quot;; } } package main; sub in_the_forest{ { my $duck = shift; } { $duck- &gt; quack(); } { $duck- &gt; feathers(); } } my $duck = Duck- &gt; hatch();my $person = Person- &gt; accept_birth(); in_the_forest( $duck );in_the_forest( $person ); [ In PHP ] &lt; ?phpclass Duck{ { function quack(){ echo &quot; Quack\n &quot;;} } { function fly(){ echo &quot; Flap, Flap\n &quot;;} } }class Person{ { function __construct($name){$this- &gt; name=$name;} } { function quack(){echo &quot; {$this- &gt; name} walks in the forest and imitates ducks to draw them\n &quot;;} } { function fly(){ echo &quot; {$this- &gt; name} takes an airplane\n &quot;;} } } function QuackAndFly($obj){$obj- &gt; quack(); $obj- &gt; fly();} QuackAndFly(new Duck());QuackAndFly(new Person( &quot; Jules Verne &quot; )); /*Output``````QuackFlap, Flap Jules Verne walks in the forest and imitates ducks to draw them.Jules Verne takes an airplane. / [ In &lt; link &gt; &lt; wikilink href= &quot; PowerShell &quot; &gt; PowerShell &lt; /wikilink &gt; &lt; /link &gt; ] This is the concept example from the beginning of the page. Function calculate($a, $b, $c) { { return ($a+$b)*$c } } calculate 1 2 3 &quot; $(calculate (1, 2, 3) (4, 5, 6) 2) &quot; calculate &apos;apples &apos; &apos;and oranges, &apos; 3 [ In Python ] Duck typing is heavily used in Python. The Python&apos;s Glossary defines duck typing as follows: [ Pythonic programming style that determines an object&apos;s type by inspection of its method or attribute signature rather than by explicit relationship to some type object ( &quot; If it looks like a duck and quacks like a duck, it must be a duck. &quot; ) By emphasizing interfaces rather than specific types, well-designed code improves its flexibility by allowing polymorphic substitution. Duck-typing avoids tests using type() or isinstance(). Instead, it typically employs the EAFP (Easier to Ask Forgiveness than Permission) style of programming. ] The canonical example of duck typing in Python is file-like classes. Classes can implement some or all of the methods of file and can be used where file would normally be used. For example, &lt; code &gt; GzipFile &lt; /code &gt; implements a file-like object for accessing gzip -compressed data. &lt; code &gt; cStringIO &lt; /code &gt; allows treating a Python string as a file. Sockets and files share many of the same methods as well. However, sockets lack the tell() method and cannot be used everywhere that GzipFile can be used. This shows the flexibility of duck typing: a file-like object can implement only methods it is able to, and consequently it can only be used in situations where it makes sense. The EAFP principle describes the use of exception handling. For example instead of checking to see if some purportedly Duck-like object has a quack() method (using if hasattr(mallard, &quot; quack &quot; ):... ) it&apos;s usually preferable to wrap the attempted quacking with exception handling: try: { mallard.quack() } except (AttributeError, TypeError): { print( &quot; mallard can&apos;t quack() &quot; ) } Advantages of this approach are that it encourages the structured handling of other classes of errors (so, for example, a mute Duck subclass could raise a &quot; QuackException &quot; which can be added to the wrapper without delving more deeply into the logic of the code, and it handles situations where different classes of objects might have naming collisions for incompatible members (for example, Mallard the purported medical professional might have a boolean attribute which classifies him as a &quot; quack=True &quot;; an attempt to perform Mallard.quack() would raise a TypeError)). In the more practical examples of classes which implement file-like behavior the use of Python&apos;s exception handling facilities is generally preferred for handling a wide variety of I/O errors that can occur due to numerous environmental and operating system issues that are outside of the programmer&apos;s control. Here again the &quot; duck typing &quot; exceptions can be caught in their own clauses alongside the OS, I/O or other possible errors without complicated testing and error checking logic. Simply stated: provided you can perform the job, we don&apos;t care who your parents are. [ In Ruby ] class Duck { def quack } { puts &quot; Quaaaaaack! &quot; } { end } { def feathers } { puts &quot; The duck has white and gray feathers. &quot; } { end } end class Person { def quack } { puts &quot; The person imitates a duck. &quot; } { end } { def feathers } { puts &quot; The person takes a feather from the ground and shows it. &quot; } { end } end def in_the_forest duck { duck.quack } { duck.feathers } end def game { donald = Duck.new } { john = Person.new } { in_the_forest donald } { in_the_forest john } end game [ References ] [ External links ] Duck Typing: Ruby How to duck type? - the psychology of static typing in Ruby Python documentation glossary entry on duck-typing Dr. Dobbs June 01 2005: &quot; Templates and Duck Typing &quot; Javascript &apos;typeof&apos; limitations and duck typing Python from a Java perspective - Part 2 - How duck typing influences class design and design principles Apache Software Foundation &quot; commons &quot; proxy project provides DuckTyping implementation in Java Category:Object-oriented programming Category:Articles with example pseudocode Category:Articles with example Python code Category:Type theory de:Duck-Typing es:Duck typing fa:تایپ‌دهی اردکی fr:Duck typing gl:Tipado Pato ko:덕 타이핑 it:Duck typing nl:Duck-typing ja:ダック・タイピング pl:Duck typing pt:Duck typing ru:Утиная типизация zh:鸭子类型