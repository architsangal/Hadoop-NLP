[ the concept in mathematical logic Satisfiability ] [ 3SAT the Central European television network 3sat ] [ October 2011 ] In computer science, satisfiability (often written in all capitals or abbreviated SAT) is the problem of determining if the variables of a given Boolean formula can be assigned in such a way as to make the formula evaluate to TRUE. Equally important is to determine whether no such assignments exist, which would imply that the function expressed by the formula is identically FALSE for all possible variable assignments. In this latter case, we would say that the function is unsatisfiable; otherwise it is satisfiable. For example, the formula a AND b is satisfiable because one can find the values a  =  TRUE and b  =  TRUE, which make a AND b TRUE. To emphasize the binary nature of this problem, it is frequently referred to as Boolean or propositional satisfiability. SAT was the first known example of an NP-complete problem. That briefly means that there is no known algorithm that efficiently solves all instances of SAT, and it is generally believed (but not proven, see P versus NP problem ) that no such algorithm can exist. Further, a wide range of other naturally occurring decision and optimization problems can be transformed into instances of SAT. A class of algorithms called SAT solver s can efficiently solve a large enough subset of SAT instances to be useful in various practical areas such as circuit design and automatic theorem proving, by solving SAT instances made by transforming problems that arise in those areas. Extending the capabilities of SAT solving algorithms is an ongoing area of progress. However, no current such methods can efficiently solve all SAT instances. [ Basic definitions, terminology and applications ] In complexity theory, the satisfiability problem (SAT) is a decision problem, whose instance is a Boolean expression written using only AND, OR, NOT, variables, and parentheses. The question is: given the expression, is there some assignment of TRUE and FALSE values to the variables that will make the entire expression true? A formula of propositional logic is said to be satisfiable if logical value s can be assigned to its variables in a way that makes the formula true. The Boolean satisfiability problem is NP-complete. The propositional satisfiability problem (PSAT), which decides whether a given propositional formula is satisfiable, is of central importance in various areas of computer science, including theoretical computer science, algorithmics, artificial intelligence, hardware design, electronic design automation, and verification. A literal is either a variable or the negation of a variable (the negation of an expression can be reduced to negated variables by De Morgan&apos;s laws ). For example, \textstyle{x_1} is a positive literal and \mathrm{not}\textstyle(x_2) is a negative literal. A clause is a disjunction of literals. For example, x_1 \or \mathrm{not}(x_2) is a clause (read as &quot; x-sub-one or not x-sub-2 &quot; ). There are several special cases of the Boolean satisfiability problem in which the formula are required to be conjunctions of clauses (i.e. formulae in conjunctive normal form ). Determining the satisfiability of a formula in conjunctive normal form where each clause is limited to at most three literals is NP-complete; this problem is called &quot; 3SAT &quot;, &quot; 3CNFSAT &quot;, or &quot; 3-satisfiability &quot;. Determining the satisfiability of a formula in which each clause is limited to at most two literals is NL-complete; this problem is called &quot; 2SAT &quot;. Determining the satisfiability of a formula in which each clause is a Horn clause (i.e. it contains at most one positive literal) is P-complete; this problem is called Horn-satisfiability. The Cook–Levin theorem states that the Boolean satisfiability problem is NP-complete, and in fact, this was the first decision problem proved to be NP-complete. However, beyond this theoretical significance, efficient and scalable algorithms for SAT that were developed over the last decade have contributed to dramatic advances in our ability to automatically solve problem instances involving tens of thousands of variables and millions of constraints. Examples of such problems in electronic design automation (EDA) include formal equivalence checking, model checking, formal verification of pipelined microprocessors, automatic test pattern generation, routing of FPGA s, and so on. A SAT-solving engine is now considered to be an essential component in the EDA toolbox. [ Complexity and restricted versions ] [ NP-completeness ] SAT was the first known NP-complete problem, as proved by Stephen Cook in 1971 (see Cook&apos;s theorem for the proof). Until that time, the concept of an NP-complete problem did not even exist. The problem remains NP-complete even if all expressions are written in conjunctive normal form with 3 variables per clause (3-CNF), yielding the 3SAT problem. This means the expression has the form: (x 11 OR x 12 OR x 13 ) AND (x 21 OR x 22 OR x 23 ) AND (x 31 OR x 32 OR x 33 ) AND... where each x is a variable or a negation of a variable, and each variable can appear multiple times in the expression. A useful property of Cook&apos;s reduction is that it preserves the number of accepting answers. For example, if a graph has 17 valid 3-colorings, the SAT formula produced by the reduction will have 17 satisfying assignments. NP-completeness only refers to the run-time of the worst case instances. Many of the instances that occur in practical applications can be solved much more quickly. See runtime behavior below. SAT is easier if the formulas are restricted to those in disjunctive normal form, that is, they are disjunction (OR) of terms, where each term is a conjunction (AND) of literals (possibly negated variables). Such a formula is indeed satisfiable if and only if at least one of its terms is satisfiable, and a term is satisfiable if and only if it does not contain both x and NOT x for some variable x. This can be checked in polynomial time. [ 2-satisfiability ] [ 2-satisfiability ] SAT is also easier if the number of literals in a clause is limited to 2, in which case the problem is called 2SAT. This problem can also be solved in polynomial time, and in fact is complete for the class NL. Similarly, if we limit the number of literals per clause to 2 and change the AND operations to XOR operations, the result is exclusive-or 2-satisfiability, a problem complete for SL = L. One of the most important restrictions of SAT is HORNSAT, where the formula is a conjunction of Horn clause s. This problem is solved by the polynomial-time Horn-satisfiability algorithm, and is in fact P-complete. It can be seen as P&apos;s version of the Boolean satisfiability problem. Provided that the complexity classes P and NP are not equal, none of these restrictions are NP-complete, unlike SAT. The assumption that P and NP are not equal is currently not proven. [ 3-satisfiability ] 3-satisfiability is a special case of k-satisfiability ( &apos;&apos;k&apos;&apos;-SAT ) or simply satisfiability (SAT), when each clause contains exactly k = 3 literals. It was one of Karp&apos;s 21 NP-complete problems. Here is an example, where ¬ indicates negation : E = (x_1 \vee \neg x_2 \vee \neg x_3) \wedge (x_1 \vee x_2 \vee x_4) E has two clauses (denoted by parentheses), four variables (x 1, x 2, x 3, x 4 ), and k=3 (three literals per clause). To solve this instance of the decision problem we must determine whether there is a truth value (TRUE or FALSE) we can assign to each of the variables (x 1 through x 4 ) such that the entire expression is TRUE. In this instance, there is such an assignment (x 1 = TRUE, x 2 = TRUE, x 3 =TRUE, x 4 =TRUE), so the answer to this instance is YES. This is one of many possible assignments, with for instance, any set of assignments including x 1 = TRUE being sufficient. If there were no such assignment(s), the answer would be NO. 3-SAT is NP-complete and it is used as a starting point for proving that other problems are also NP-hard. This is done by polynomial-time reduction from 3-SAT to the other problem. An example of a problem where this method has been used is the Clique problem. 3-SAT can be further restricted to One-in-three 3SAT, where we ask if exactly one of the literals in each clause is true, rather than at least one. This restriction remains NP-complete. There is a simple randomized algorithm due to [ Schöning 1999 ] that runs in time (4/3)^n where n is the number of clauses and succeeds with high probability to correctly decide 3-Sat.The exponential time hypothesis is that no algorithm can solve 3-Sat in time \exp(o(n)). [ Horn-satisfiability ] [ Horn-satisfiability ] A clause is Horn if it contains at most one positive literal. Such clauses are of interest because they are able to express implication of one variable from a set of other variables. Indeed, one such clause \neg x_1 \vee \cdots \vee \neg x_n \vee y can be rewritten as x_1 \wedge \cdots \wedge x_n \rightarrow y, that is, if x_1,\ldots,x_n are all true, then y needs to be true as well. The problem of deciding whether a set of Horn clauses is satisfiable is in P. This problem can indeed be solved by a single step of the Unit propagation, which produces the single minimal model of the set of Horn clauses (w.r.t. the set of literal assigned to true). A generalization of the class of Horn formulae is that of renamable-Horn formulae, which is the set of formulae that can be placed in Horn form by replacing some variables with their respective negation. Checking the existence of such a replacement can be done in linear time; therefore, the satisfiability of such formulae is in P as it can be solved by first performing this replacement and then checking the satisfiability of the resulting Horn formula. [ XOR-satisfiability ] Another special case is the class of problems where each clause only contains exclusive or operators (also known as Zhegalkin polynomial ). This is NP-complete, because the SAT can be transformed into an instance of XOR-SAT. Corollary to this statement, this means that any problem from NP can be transformed into XOR-SAT, as established in the definition of NP-completeness. [ Schaefer&apos;s dichotomy theorem ] [ Schaefer&apos;s dichotomy theorem ] The restrictions above (CNF, 2CNF, 3CNF, Horn) bound the considered formulae to be conjunction of subformulae; each restriction states a specific form for all subformulae: for example, only binary clauses can be subformulae in 2CNF. Schaefer&apos;s dichotomy theorem states that, for any restriction to Boolean operators that can be used to form these subformulae, the corresponding satisfiability problem is in P or NP-complete. The membership in P of the satisfiability of 2CNF and Horn formulae are special cases of this theorem. [ Runtime behavior ] As mentioned briefly above, though the problem is NP-complete, many practical instances can be solved much more quickly. Many practical problems are actually &quot; easy &quot;, so the SAT solver can easily find a solution, or prove that none exists, relatively quickly, even though the instance has thousands of variables and tens of thousands of constraints. Other much smaller problems exhibit run-times that are exponential in the problem size, and rapidly become impractical. Unfortunately, there is no reliable way to tell the difficulty of the problem without trying it. Therefore, almost all SAT solvers include time-outs, so they will terminate even if they cannot find a solution. Finally, different SAT solvers will find different instances easy or hard, and some excel at proving unsatisfiability, and others at finding solutions. All of these behaviors can be seen in the SAT solving contests. [ http://www.satcompetition.org/ The international SAT Competitions web page 2007-11-15 ] [ Extensions of SAT ] An extension that has gained significant popularity since 2003 is Satisfiability modulo theories (SMT) that can enrich CNF formulas with linear constraints, arrays, all-different constraints, uninterpreted function s, etc. Such extensions typically remain NP-complete, but very efficient solvers are now available that can handle many such kinds of constraints. The satisfiability problem becomes more difficult (PSPACE-complete) if we allow both &quot; for all &quot; and &quot; there exists &quot; quantifier s to bind the Boolean variables. An example of such an expression would be: \forall x\left(\exists y\left(\exists z\left((x \lor y \lor z) \land (\lnot x \lor \lnot y \lor \lnot z)\right)\right)\right). SAT itself uses only \exists quantifiers. If we allow only \forall quantifiers, it becomes the Co-NP-complete tautology problem. If we allow both, the problem is called the quantified Boolean formula problem (QBF), which can be shown to be PSPACE-complete. It is widely believed that PSPACE-complete problems are strictly harder than any problem in NP, although this has not yet been proved. A number of variants deal with the number of variable assignments making the formula true. Ordinary SAT asks if there is at least one such assignment. MAJSAT, which asks if the majority of all assignments make the formula true, is complete for PP, a probabilistic class. The problem of how many variable assignments satisfy a formula, not a decision problem, is in #P. UNIQUE-SAT or USAT or Unambiguous SAT is the problem of determining whether a formula known to have either zero or one satisfying assignments has zero or has one. Although this problem seems easier, it has been shown that if there is a practical ( randomized polynomial-time ) algorithm to solve this problem, then all problems in NP can be solved just as easily. The maximum satisfiability problem, an FNP generalization of SAT, asks for the maximum number of clauses which can be satisfied by any assignment. It has efficient approximation algorithm s, but is NP-hard to solve exactly. Worse still, it is APX -complete, meaning there is no polynomial-time approximation scheme (PTAS) for this problem unless P=NP. [ Self-reducibility ] An algorithm which correctly answers if an instance of SAT is solvable can be used to find a satisfying assignment. First, the question is asked on formula \phi. If the answer is &quot; no &quot;, the formula is unsatisfable. Otherwise, the question is asked on \phi_{x_1 = 0}, i.e. the first variable is assumed to be 0. If the answer is &quot; no &quot;, it is assumed that x_1 = 1, otherwise x_1 = 0. Values of other variables are found subsequently. This property is used in several theorems in complexity theory: \displaystyle \mathsf{NP} \subseteq \mathsf{P/poly} \Rightarrow \mathsf{PH} = \Sigma_2 ( Karp-Lipton theorem ) \displaystyle \mathsf{NP} \subseteq \mathsf{BPP} \Rightarrow \mathsf{NP} = \mathsf{RP} \displaystyle \mathsf{P} = \mathsf{NP} \Rightarrow \mathsf{FP} = \mathsf{FNP} [ Algorithms for solving SAT ] There are two classes of high-performance algorithms for solving instances of SAT in practice: the conflict-driven clause learning algorithm, which can be viewed as a modern variant of the DPLL algorithm (well known implementation include Chaff, GRASP ) and stochastic local search algorithms, such as WalkSAT. A DPLL SAT solver employs a systematic backtracking search procedure to explore the (exponentially sized) space of variable assignments looking for satisfying assignments. The basic search procedure was proposed in two seminal papers in the early 60s (see references below) and is now commonly referred to as the Davis–Putnam–Logemann–Loveland algorithm (“DPLL” or “DLL”). Theoretically, exponential lower bounds have been proved for the DPLL family of algorithms. Modern SAT solvers (developed in the last ten years) come in two flavors: &quot; conflict-driven &quot; and &quot; look-ahead &quot;. Conflict-driven solvers augment the basic DPLL search algorithm with efficient conflict analysis, clause learning, non- chronological backtracking (aka backjumping ), as well as &quot; two-watched-literals &quot; unit propagation, adaptive branching, and random restarts. These &quot; extras &quot; to the basic systematic search have been empirically shown to be essential for handling the large SAT instances that arise in electronic design automation (EDA). Look-ahead solvers have especially strengthened reductions (going beyond unit-clause propagation) and the heuristics, and they are generally stronger than conflict-driven solvers on hard instances (while conflict-driven solvers can be much better on large instances which actually have an easy instance inside). Modern SAT solvers are also having significant impact on the fields of software verification, constraint solving in artificial intelligence, and operations research, among others. Powerful solvers are readily available as free and open source software. In particular, the conflict-driven MiniSAT, which was relatively successful at the 2005 SAT competition, only has about 600 lines of code. An example for look-ahead solvers is march_dl, which won a prize at the 2007 SAT competition. Certain types of large random satisfiable instances of SAT can be solved by survey propagation (SP). Particularly in hardware design and verification applications, satisfiability and other logical properties of a given propositional formula are sometimes decided based on a representation of the formula as a binary decision diagram (BDD). Propositional satisfiability has various generalisations, including satisfiability for quantified Boolean formula problem, for first - and second-order logic, constraint satisfaction problem s, 0-1 integer programming, and maximum satisfiability problem. Many other decision problems, such as graph coloring problems, planning problems, and scheduling problems, can be easily encoded into SAT. [ See also ] Unsatisfiable core Satisfiability Modulo Theories Counting SAT [ Notes ] [ References ] [ December 2010 ] References are ordered by date of publication: [ 25em ] [ 10.1145/321033.321034 ] [ 10.1145/368273.368557 ] [ 10.1145/800157.805047 ] [ Michael R. Garey and David S. Johnson 1979 Computers and Intractability: A Guide to the Theory of NP-Completeness W.H. Freeman 0-7167-1045-5 ] [ 10.1109/12.769433 ] [ 10.1109/DATE.1999.761110 ] [ 10.1109/SFFCS.1999.814612 ] [ 10.1145/378239.379017 ] [ 10.1023/A:1011276507260 ] [ 10.1109/TCAD.2002.1004311 ] [ 10.1007/b95238 ] [ 10.1109/TC.2006.175 ] [ 10.1109/BIMNICS.2007.4610083 ] A9.1: LO1 – LO7, pp.  259 – 260. R. E. Bryant, S. M. German, and M. N. Velev, Microprocessor Verification Using Efficient Decision Procedures for a Logic of Equality with Uninterpreted Functions, in Analytic Tableaux and Related Methods, pp.  1–13, 1999. [ 25em ] [ Further reading ] [ Frank Van Harmelen, Vladimir Lifschitz, Bruce Porter Handbook of knowledge representation 2008 Elsevier 978-0-444-52211-5 89–134 Carla P. Gomes, Henry Kautz, Ashish Sabharwal, Bart Selman Satisfiability Solvers 10.1016/S1574-6526(07)03002-7 Foundations of Artificial Intelligence 3 ] [ See also ] Circuit satisfiability [ External links ] More information on SAT: SAT and MAX-SAT for the Lay-researcher SAT Applications: WinSAT v2.04 : A Windows-based SAT application made particularly for researchers. SAT Solvers: Chaff HyperSAT Spear The MiniSAT Solver UBCSAT Sat4j RSat Fast SAT Solver - simple but fast implementation of SAT solver based on genetic algorithm s PicoSAT CryptoMiniSat International Conference on Theory and Applications of Satisfiability Testing: SAT 2011 SAT 2010 SAT 2009 SAT 2008 SAT 2007 Publications: Journal on Satisfiability, Boolean Modeling and Computation Survey Propagation Benchmarks: Forced Satisfiable SAT Benchmarks SATLIB Software Verification Benchmarks Fadi Aloul SAT Benchmarks SAT solving in general: http://www.satlive.org http://www.satisfiability.org Evaluation of SAT solvers: Yearly evaluation of SAT solvers SAT solvers evaluation results for 2008 &apos;&apos;This article includes material from a column in the ACM SIGDA e-newsletter by Prof. Karem Sakallah Original text is available here &apos;&apos; Category:Boolean algebra Category:Electronic design automation Category:Formal methods Category:Logic in computer science Category:NP-complete problems Category:Satisfiability problems de:Erfüllbarkeitsproblem der Aussagenlogik es:Problema de satisfacibilidad booleana eo:Bulea plenumebloproblemo fa:مسئله صدق‌پذیری دودویی fr:Problème SAT ko:충족 가능성 문제 it:Soddisfacibilità booleana he:בעיית הספיקות nl:Vervulbaarheidsprobleem ja:充足可能性問題 pl:Problem spełnialności pt:Problema de satisfatibilidade booleana ru:Задача выполнимости булевых формул simple:Boolean satisfiability problem sr:САТ проблем th:ปัญหาความสอดคล้องแบบบูล uk:Задача здійсненності бульових формул zh:布尔可满足性问题