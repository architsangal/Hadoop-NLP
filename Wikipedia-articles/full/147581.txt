[ BASIC on the 400/800/XL/XE the version of BASIC bundled with the Atari ST computer series Atari ST BASIC the BASIC cartridge for the Atari 2600 video game system BASIC Programming ] [ Atari BASIC A rudimentary Atari BASIC program ready to run A rudimentary Atari BASIC program ready to run Shepardson Microsystems 1979 Revision C 1983 Atari 400/800/XL/XE Media: cartridge BASIC Copyright © 1979 Atari Inc. Proprietary ] Atari BASIC is a BASIC interpreter for the Atari 8-bit family of 6502 -based home computer s. The interpreter originally shipped on an 8   KB cartridge; on later XL/XE model computers it was built in, with an option to disable it, and started when the machines were booted with no other cartridges in place. The complete commented source code and design specifications of Atari BASIC were published as a book in 1983. [ Wilkinson Bill 1983 The Atari BASIC Source Book Compute! Books 0-942386-15-9 ] This marked the first time source code was made available for a commercial language. [ August 2009 ] [ Nomenclature and symbols ] In the nomenclature of the time when these machines were designed, &quot; K &quot; was taken to mean one kilobyte, so that is how it is expressed here. Similarly, further, on the family of processors use by Atari machines, in the assembly language &quot; $ &quot; introduced a hexadecimal number, or it was suffixed subscripted with its radix, so, for example, &quot; [ 128 ] &quot; is &quot; 128 10 &quot;, &quot; $80 &quot;, or &quot; 80 16 &quot;. If a number is expressed with no radix, decimal (10) is assumed, and a leading 0 does not imply octal. These are used instead of more modern conventions because they appear as such in many of the sources and will be seen often by those using simulators and so forth. [ Background ] The machines that would become the Atari 8-bit family had originally been developed as second-generation games console s intended to replace the Atari 2600. Ray Kassar, the new president of Atari, decided to challenge Apple Computer by building a home computer instead. This meant Atari needed the BASIC programming language, then the standard language for home computers. Atari did what many of the other home computer companies did: they purchased the source code to the MOS 6502 version of Microsoft 8K BASIC, intending to port it to run on their new machines. But the name was something of a misnomer, as the 8K referred to its original size on the Intel 8080 &apos;s instruction set. The lower code density of the 6502 expanded the code to about 9  kB. Atari felt that they needed to expand the language to add better support for the specific hardware features of their computers, similar to what Apple had done with their Applesoft BASIC. This increased the size from 9K to around 11K. Atari had designed their ROM layout in 8K b/locks, and paring down the code from 11K to 8K turned out to be a significant problem. Adding to the problem was the fact that the 6502 code supplied by Microsoft was undocumented. Six months later, they were almost ready with a shippable version of the system. But Atari had a deadline with the Consumer Electronics Show (CES) approaching and decided to ask for help. [ Shepardson Microsystems ] The 8K ROM Atari BASIC cartridge for Atari 8-bit computers. In September 1978 Atari asked Shepardson Microsystems (SMI) to bid on completing BASIC. Shepardson had written a number of programs for the Apple II family, which used the same 6502 processor, and were in the middle of finishing a new BASIC for the Cromemco S-100 bus machines (Cromemco 32K Structured BASIC). SMI examined the existing work and decided it was too difficult to continue paring it down; instead they recommended developing a completely new version that would be easier to fit into 8K. Atari accepted the proposal, and when the specifications were finalized in October 1978, Paul Laughton and Kathleen O&apos;Brien began work on the new language. The result was a rather different version of BASIC, known as ATARI BASIC. In particular, the new BASIC dealt with character string s more like Data General &apos;s BASIC than Microsoft&apos;s, which used strings similar to those from DEC BASIC. { The main differences were whether strings were allowed to grow and shrink in size once memory had been allocated for them, and whether the size of the string was constant from the outset (e.g. being padded with some special character meaning &quot; } { end of string &quot; or whether the size was stored independently. Both approaches have advantages and disadvantages, depending on how one is expecting them to be used. } The contract specified a delivery date on or before April 6, 1979 and this also included a File Manager System (later known as DOS 1.0). Atari&apos;s plans were to take an early 8K version of Microsoft BASIC to the 1979 CES and then switch to the new Atari BASIC for production. Because of a bonus clause in the contract, development proceeded quickly and an 8K cartridge was available just before the release of the machines. Because Atari BASIC was delivered before Microsoft BASIC, Atari took it with them to the CES. [ Releases ] Shepardson&apos;s programmers found problems during the first review and managed to fix some of them, but Atari had already committed ATARI BASIC to manufacturing, and the technology of the time did not permit changes. So it was manufactured with known bugs, and became known (as a retronym ) Revision A. Revision A   – First Atari BASIC cartridge. 8K ROM. This version contained a bug in a subroutine that copied memory. Under certain conditions, deleting lines of code led to a crash condition known as the &quot; 2-line lockup &quot;. &quot; Atari BASIC Bugs &quot;, Compute!, July 1986, pg. 10 Revision B   – Fixed all of the major software bug s in Revision A. While fixing the 2-line bug they re-introduced the same problem in a more common routine, thereby dramatically increasing the number of crashes. Found built-in on the 600XL and early 800XLs. Never supplied on cartridges. Revision C   – Eliminated memory leak in Revision B. Found on later 800XLs, the 800XLF, XEGS and all XE computers. Limited cartridge production run. A BASIC programmer can find out the version by examining a well-known location in memory. Entering the command PRINT PEEK(43234) at the READY prompt will give a result of 162 for Revision A, 96 for Revision B, and 234 for Revision C. [ Description ] [ Program editing ] What happens when a line containing a syntax error is entered Atari BASIC uses a line editor, like most BASICs of the era. Unlike many BASICs, however, Atari BASIC immediately checks the line for syntax error s. If a problem is found it shows the line again, highlighting the text near the error in inverse video. This can make catching syntax errors on the Atari much easier than on other editors; most BASICs will not display the errors until the program is executed. (The Sinclair ZX family of machines also adopts the approach of checking each line as it was entered, although it differs by not even allowing the line to be entered until it is syntactically correct, which can be a hindrance to the programmer when writing a line of code but wanting to look up something elswehere in the program.) When not running a BASIC program, the Atari is in direct mode or immediate mode. Program lines can be entered by starting with a line number, which will insert a new line or amend an existing one. Lines without a line number are executed straight away, hence the name immediate mode. When the programmer types RUN the program executes from the first statement. It can also be given a line number, so that RUN 2000 will run the program from line 2000, or the first line after that if line 2000 does not exist. Unlike most other BASICs, Atari BASIC allows all commands to be executed in both modes. For instance most BASICs only allow LIST to be used in immediate mode, while Atari BASIC also allows it to be used inside a program. This is sometimes used as part of a way to produce self modifying code. Program lines ( &quot; logical lines &quot; ) can be up to three screen lines ( &quot; physical lines &quot; ) of 40 characters, so 120 characters total. The cursor can be moved freely in these lines, unlike in other BASICs where to get &quot; up &quot; a line one has to continuously scroll leftwards until the cursor is wrapped at the left margin (and similarly to go down when wrapping at the right margin) – though that works too, except the cursor when wrapping left to right or right to left does not move up or down a line. The OS handles tracking whether a physical line flowed to the next on the same logical line; the three-line limit is fairly arbitrary but keeps lines below 128 characters and so reduces the chances of buffer overflow. The cursor can always be moved freely around the screen, and it will wrap on all sides. Hitting &quot; ENTER &quot; will send the tokenizer the (logical) line on which the cursor sits. So, in the example pictured above (with &quot; PRUNT &quot; ), all the author needs to do to fix the error is move the cursor over the &quot; U &quot;, type [ I ] (the editor only has an overwrite mode) and hit [ ENTER ]. This is quite a frequent editing technique for, say, renumbering lines. Atari BASIC has no built-in renumbering command, but one can quickly learn to overwrite the numbers on a set of lines then just hit &quot; ENTER &quot; repeatedly to put them back into the program. Indeed, a slightly cryptic but essentially simple idiom allows this to be done by the program itself as it is running, producing self-modifying code. This is not an artifact or cheat around the system but inherent in the combined behavior of the editor and tokenizer. [ Character set ] [ ATASCII ] The Atari variation on ASCII, called ATASCII, has 128 (80 16 ) characters mostly corresponding to ASCII but with a few exceptions. All characters have printable forms unlike ASCII where codes 0-31 (0-1F 16 ) are &quot; control codes &quot; that perform special functions such as requesting a paper feed or ringing an attention bell. Characters 128-255 (80 16 -FF 16 ) are displayed as the inverse video of characters 0-127 (00 16 -7F 16 ). Variable names must be composed of upper-case alphabetic (65-90, 41 16 -5A 16 ) and numeric (48-57, 30 16 -39 16 ) characters, starting with an alphabetical character, and for strings terminating with a dollar sign (36, 24 16 ). The character set has a full ensemble of lower case characters and some graphics characters, but it is common to see programs mostly in upper case. This may be simply because of conventions, previous machines such as the Apple II series not having lower case; or that some devices such as daisy wheel printer s may not have lower case; or that the lower-case font is not very attractive, [ July 2011 ] in particular struggling to squeeze ascenders and descender s into the 8 &amp; times;8 fixed grid used to define each glyph, or the 8 &amp; times;7 fonts used on many dot matrix printer s such as Atari&apos;s own. On Revision C ROMs there is an alternative font including characters with diacritic s, intended for European users, but this is rarely used. Adding user-defined fonts is relatively easy and each takes 1 kilobyte (128 characters &amp; times; 8 bits high &amp; times; 8 bits wide). The ANTIC chip uses one byte to indicate the start page of a font (the memory consisting of 256 pages of 256 bytes). But only one font can be used at a time without machine code display list interrupts to change the font midway down the screen. An infrequently used 8 &amp; times;10 font mode exists, where the range of characters for lower case letters are shifted down two lines thus allowing the actual glyphs to be 8 &amp; times;8 yet be presented with ascenders or descenders. This mode is only occasionally used, partly because dot matrix printers can not easily support it. { Some programs such as PrettyPrint exist which do so by sending the output as graphics to the printer, so that seven lines of 8-bit-high text are printed as eight passes of the 7-bit-high print head. } The ease of implementing other fonts means many are freely available, with font editors and so forth too. [ The tokenizer ] Like most BASIC interpreters, Atari BASIC uses a token structure to handle lexical processing for better performance and reduced memory size. The tokenizer converts lines using a small buffer in memory, and the program is stored as a parse tree. { although Wilkinson tends to the parse tree as a set of tables which is really an implementation detail } The token output buffer (addressed by a pointer at LOMEM – 80, 81 16 ) is 1 page (256 bytes) long, and any tokenized statement that is larger than the buffer will generate a BASIC error (14   – line too long). Indeed, the syntax checking described in the &quot; Program editing &quot; section is a side effect of converting each line into a tokenized form before it is stored. Sinclair BASIC uses a similar approach, though it varies between models. The output from the tokenizer is then moved into more permanent storage in various locations in memory. A set of pointers (addresses) indicates these locations: variables are stored in the variable name table (pointed to at VNTP – 82, 83 16 ) and the values are stored in the variable value table (pointed to at VVTP – 86, 87 16 ). Strings have their own area (pointed to at STARP – 8C, 8D 16 ) as does the runtime stack (pointed to at RUNSTK – 8E, 8F 16 ) used to store the line numbers of looping statements ( FOR...NEXT ) and subroutines ( GOSUB...RETURN ). Finally, the end of BASIC memory usage is indicated by an address stored at MEMTOP – 90, 91 16 ) pointer. By indirecting the variable names in this way, a reference to a variable needs only two bytes to address its entry into the appropriate table; the whole name does not need to be stored each time. This also makes variable renaming relatively trivial if the program is in storage, as it is simply a case of changing the single instance of its name in the table and the only difficulty is if the name changes length (and even then, only if it gets longer): indeed, obfuscated code can be produced for a finished program by renaming variables in the name tables – possibly all to the same name. This doesn&apos;t confuse the interpreter since internally it is using the index values not the names. Of course, new code will be difficult to add because the tokenizer has to search the name table to find a variable&apos;s index, and can get confused if names are not unique (though it is OK to have names in both the &quot; string &quot; and &quot; variable &quot; namespaces, e.g. HELLO = 10 and HELLO$ = &quot; WORLD &quot;, because they have separate tables, that is to say, separate namespace s.) Atari BASIC uses a unique way to recognize abbreviated reserved words. In Microsoft BASIC there are a few predefined short forms, (like ? for PRINT and &apos; for REM ). Atari BASIC allows any keyword to be abbreviated using a period, at any point in writing it. So L. will be expanded to LIST, as will LI. and (redundantly) LIS.. To expand an abbreviation the tokenizer will search through its list of reserved words and find the first that matches the portion supplied. To improve the chance of a programmer&apos;s correctly guessing an abbreviation, to save typing, and to improve the speed of the lookup, the list of reserved words is sorted to place the more-commonly used commands first. REM is at the very top, and can be typed in just as.. This also speeds lexical analysis generally, since although the time to search is in theory proportional to the length of the list, in practice it will find common keywords very quickly, to the extent that good programmers know when a line is syntactically incorrect even before the parser says so, because the time taken to search the list to find it wanting gives an indication that something is wrong. So whereas Microsoft BASIC uses separate tokens for its few short forms, ATARI BASIC has only one token for each reserved word – when the program is later LIST ed it will always write out the full words (since only one token represents all possible forms, it can do no other). There are two exceptions to this: PRINT has a synonym, ?, and LET has a synonym which is the empty string (so 10 LET A = 10 and 10 A = 10 mean the same thing). These are separate tokens, and so will remain as such in the program listing. Some other contemporary BASICs have variants of keywords that include spaces (for example GO TO ). Atari BASIC does not. The main exception here is keywords for communicating with peripheral s (see the &quot; Input/Output &quot; section, below) such as OPEN  # and PRINT  #; it rarely occurs to many programmers that the &quot;  # &quot; is actually part of the tokenized keyword and not a separate symbol; and that for example &quot; PRINT &quot; and &quot; PRINT  #0 &quot; are the very same thing, { Although 0 is actually explicitly disallowed here by BASIC assuming it to be a coding error, isn&apos;t it? } just presented differently. It may be that the BASIC programmers kept the form { # } to conform with other BASICs (The syntax derives from Fortran ), though it is entirely unnecessary, and probably a hindrance, for tokenizing, and is not used in other languages for the Atari 8-bit family. Expanding tokens in the listing can cause problems when editing. The Atari line input buffer is three lines (120 characters); up to three &quot; physical lines &quot; make one &quot; logical line &quot;. After that a new &quot; logical line &quot; is automatically created. This doesn&apos;t matter much for output but it does for input, because the operating system will not return characters to the tokenizer after the third line, treating them as the start of a new &quot; logical line &quot;. (The operating system keeps track of the mapping between physical and logical lines as they are inserted and deleted; in particular it marks each physical line with a flag for being a continuation line or a new logical line.) But using abbreviations when typing in a line can result, once they have been expanded on output, to a line that is longer than three lines and, a more minor concern, some whitespace characters can be omitted on input, so for example PRINT &quot; HELLO &quot; will be listed as PRINT   &quot; HELLO &quot;, one character longer. If one then wants to edit the line, now split across two logical lines, one must replace the expanded commands back with their abbreviations to be submit them back to the tokenizer. The moral of this is, generally, don&apos;t try to squeeze more out of a line than is reasonable, or, in the alternate, obfuscate variables by makinggggggthemverrrryverrrrylongindeed. Literal line numbers in statements such as GOTO are calculated at run time using the same floating-point mathematical routines as other BASIC functions. This calculation allows subroutine s to be referred to by variables: for instance GOTO EXITOUT is as good as GOTO 2000, if one sets EXITOUT to 2000. This is much more useful than it might sound; literals are stored in the 6-byte floating-point variable format, but variables are stored as a two-byte pointer to their place in the variable value table, at VVTP, so by using a variable the GOTO target is just two bytes instead of six. Of course the actual number takes another six, but this is only stored once, so if the same line number is used more than twice, one saves some memory, though the line number takes a little longer to look up. (The design choice to store what can only legally be integers as floating-point numbers is discussed below.) It is quite common in BASIC to use GOTO or GOSUB to a line number, so real savings can be made to replace these numbers with variables. It also means that if the programmer is careful always to use the variable and not the literal, subroutines can be easily renumbered (moved around in the program), because only the variable value needs to be changed. This makes it common to see, at the start of an Atari BASIC program, a sequence of LET statements assigning line numbers to variables. { Because the literal line numbers are stored as floating point numbers, deliberate } { obfuscation can happen by changing them to values other than } { natural number s. This is rarely useful, because the line number is rounded as part of the lookup. } [ String handling ] Atari BASIC differs dramatically from Microsoft-style BASICs in the way it handles strings. In BASICs following the Microsoft model, strings are special types that allow for variable length and various operations. Atari BASIC has no strings of this sort, instead using arrays of characters, rather like Fortran. This allowed the BASIC language programmers to remove all the special-purpose code needed for handling dynamic resizing of strings, reusing instead the code already being used to handle arrays of numbers. A string is allocated a maximum size using the DIM statement, although its actual length can vary at runtime from 0 to this maximum size. Of course, strings are not used by end programmers in the same way as arrays of numbers – at least not normally – so Atari BASIC also includes a selection of commands for &quot; slicing &quot; up arrays. A$ refers to the entire string, whereas A$(4,6) &quot; slices &quot; out the three characters 4, 5 and 6. In theory, this is a more elegant solution than Microsoft BASIC&apos;s LEFT$, MID$, and RIGHT$ solution, as this syntax replaces three separate commands with a single one. Although this simplification reduces the size of Atari BASIC and offers some theoretical performance benefits, it is also a hindrance to porting BASIC programs from other computers to the Atari. When the Atari was first produced it was the norm for programs to be provided as listings in magazines for programmers to type in. They would have to scan them for instances of LEFT$, RIGHT$ and so on, do some mental arithmetic and replace them with slicing commands. Because strings were allocated a fixed size it generally means that programmers will pessimize or guesstimate the likely maximum size, allocating, perhaps 256 bytes for a string that only ever stores someone&apos;s first name. Strings in Atari BASIC cannot themselves be members of arrays, so arrays of strings have to be implemented by the programmer. Strings can move around in memory, so it is not generally possible for example to store their memory addresses in an array. For short strings of approximately the same length, instead an array is generally built using padding so that the strings are all the same length and the nth string in the array is n &amp; times;l characters into it, where l is the length of the string. According to Bill Wilkinson, the chief programmer at SMI, it was unfeasible to implement string arrays with strings that were larger than one page (256 characters). [ December 2009 ] Long strings initialization usually required for loops. Nevertheless, the language enabled fast string initialization with the following trick: { REM The following initialize A$ with 1000 characters of x } { DIM A$(1000) } { A$= &quot; x &quot; :A$(1000)=A$:A$(2)=A$ } [ Input/Output ] [ CIO overview ] The Atari OS includes a subsystem for peripheral device input/output (I/O) known as CIO (Central Input/Output). All I/O went through a central point of entry (E45C 16 ) passing the address of an I/O Control Block (IOCB), a 16-byte structure that defines which device was meant, and what kind of operation (read, write, seek etc.). There are 8 such IOCBs, allocated at fixed locations in page 3 of memory from 380 16 to 3FF 16. Most programs therefore can be written independently of what device they might use, as they all conform to a common interface – this was very rare on home computers when Atari BASIC was first made. virtual devices such as the screen, S: and the editor, E: did have special operations, for example to draw graphics or to ask for line input (in fact E: was pretty much a combination of S: and the keyboard, K: ), but these were done in a uniform way and new device drivers could be written fairly easily that would automatically be available to ATARI BASIC and indeed any other program using the Atari OS, for example to provide support for new hardware devices such as mouse pointers, or software devices such as an 80-column display (using typically a 4 &amp; times;8 pixel font). Existing drivers could be supplanted or augmented by new ones since the driver table was searched newest-to-oldest, so a replacement E:, for example could displace the one in ROM to provide an 80-column display, or to piggy-back on it to generate a checksum whenever a line was returned – this technique is used for some of the program listing checkers that provide a checksum for each line. [ CIO access in BASIC ] Atari BASIC supports CIO access with reserved words OPEN  #, CLOSE  #, PRINT  #, INPUT  #, GET  #, PUT  #, NOTE  #, POINT  # and XIO  #. There are routines in the OS for graphics fill and draw, but they are not available as specific BASIC keywords (e.g. DRAW or FILL, as in other BASICs), but can be got at through the general CIO entry point, which has the BASIC command XIO. It is odd that a machine that is superlatively endowed with graphics capabilities did not expose them to BASIC, when they are already there in the hardware and the OS. One might assume the BASIC programmers ran out of time or space to add them to the BASIC tokenizer: they are available in variants such as Turbo-BASIC XL, and in other languages. Up to eight IOCBs can be in use at a time, numbered 0 through 7 (0 was, by default, the editor E: ). The BASIC statement OPEN  # was used to prepare a device for I/O access: { REM Opens the cassette device on channel 1 for reading in BASIC } { OPEN #1,4,0, &quot; C:MYPROG.DAT &quot; } Here, OPEN  # means &quot; ensure channel 1 is free &quot; (an error otherwise results), call the C: driver to prepare the device (this will set the cassette tape spools onto tension and advance the heads keeping the cassette tape player &quot; paused &quot;; the 4 means &quot; for read &quot; (other codes were 8 for write, 12 = 8 + 4 for &quot; read-and-write &quot;, and so forth), and the third number provides extra auxiliary information, here not used and set by convention to 0. The C:MYPROG.DAT is the name of the device and the filename, as it happens, files on cassette were not named by this device [ March 2011 ]. The string gives the device name and optionally a filename. Physical devices can have numbers (mainly disks, printers and serial devices), so &quot; P1: &quot; might be the plotter and &quot; P2: &quot; the daisy-wheel printer, or &quot; D1: &quot; may be one disk drive and &quot; D2: &quot; another, &quot; R1: &quot; may be a modem and &quot; R2: &quot; an oscilloscope (R for RS-232, provided by an add-on interface and not built into the OS), and so on; if not present, 1 is assumed. [ Reserved IOCBs in Atari BASIC ] ATARI BASIC disallows access to IOCB 0 (the editor, E: ) and reserves IOCB 7 for printing and cassette operations using the built-in commands LPRINT, SAVE, LOAD, CSAVE, CLOAD, though there is nothing to stop printers or the cassette being used on other channels too. IOCB 6 is used for accessing the graphics screen device ( S: ) for drawing lines, filling shapes and so on. SAVE and LOAD output the compact tokenized form of the BASIC program, LIST and ENTER output and input the text source, just as if they were being sent to or from the editor. For the other CIO functions, Atari BASIC uses the XIO statement. This just primes an IOCB and calls the CIO entry point; any of the other commands ( PRINT, INPUT and so on) can be achieved with the more general form XIO. But the form of XIO is not very friendly for BASIC users, and it is mostly used for unusual functions that are specific to a particular device. For example, an M: device exists called &quot; Multi-Mouse &quot; { Published in } { Page 6 magazine, July 1986. } that allows an Atari ST mouse, 8-bit trakball, touch tablet, or joystick, to be treated as a device whereby the position of the mouse cursor is set or got with NOTE and POINT commands. It should be remembered here that POINT does not mean, as it does in many BASICs, draw a point on the screen, but point a IOCB channel at a specific place in a file. In Atari DOS the two parameters to NOTE and POINT are the disk sector and offset, which is not very portable. In SpartaDOS they make up the offset from the start of the file. In the Multi-Mouse driver M:, they are the X and Y position of the mouse cursor. [ Error Handling ] I/O routines returned error codes of 128-255 (80 16 -FF 16 ) via the processor&apos;s Y register and setting the carry flag of the processor. Setting the carry flag is a neat trick since the caller can immediately branch-on-carry (BCC or BCS instructions) to an error routine, a brief, quick and relocatable 6502 instruction (2 bytes, 2 cycles), without having to test Y for the (we hope) normal case where there is no error. As with other aspects of the CIO, error codes were common across devices but could be extended for particular devices. Error handlers could thus be written quite generically, to fail gracefully, maybe put out a message, ask the user whether to retry, propagate the error, and so on. There were no user-friendly messages for standard error codes in the OS itself. They would be interpreted by the application. Atari BASIC (and other languages) thus had the freedom to return error codes less than 128, and these meant different things in different languages. There was nothing to stop a perverse implementer using error codes of 128 or above, but no incentive to do so. [ Graphics ] [ Hardware support ] [ ANTIC ] The output of a small program using GRAPHICS 2 mode. The text says in es Here are 3 lines in Graphics Mode 2. (At the foot of the screen)And here is a window with four lines in Graphics Mode 0. READY. The Atari 8-bit family of hardware includes quite a sophisticated graphics system, stemming from its basis in video games consoles. Unlike many other home computers, the graphics &quot; mode &quot; – the size of pixels and the number of colors that could be displayed – is not fixed for the whole display but described line-by-line in a small microcontrol language to create a display list. Each entry in this list describes one or more lines on the TV display, top-to-bottom. A dedicated graphics microprocessor, &quot; ANTIC &quot;, reads these out during the horizontal blanking interval to determine how to display the next TV line. Lines can be narrow (256 pixels wide at highest resolution), normal (320 pixels) or wide (384 pixels). Characters are 8 &amp; times;8 and one display list entry would thus describe 8 TV lines; the ANTIC keeps a counter (a shift register ) of which line in the font to read the pixel data from for each of those lines, thus only requiring one entry for the whole 8 lines in the display. Similarly for larger, coarser graphics modes, the ANTIC chip kept track of the information so that it would display the data on more than one TV line. The ANTIC thus has to reference the RAM and asserts control over the address bus and data bus to do so. This &quot; steals &quot; cycles from the main 6502 CPU. The Sinclair ZX81 had SLOW and FAST commands to switch the display off and on, because writing the display took about three quarters of the whole processor time. Because the Atari&apos;s display rendering is on a separate chip, even though it has to fetch memory, its impact on the main processor is generally negligible. That being said, American machines are clocked to American NTSC video systems, at about 1.79  Mhz, to fit the 60  Hz vertical blank and correspondingly shorter horizontal blank; but European PAL models are clocked at 1.77  Mhz { http://www.faqs.org/faqs/atari-8-bit/faq/section-16.html NTSC vs PAL/SECAM Ataris. } to fit a 50  Hz vertical blank. Because European machines service fewer vertical blank interrupts per second, it makes mainline programs run faster, and code using vertical-blank interrupts run slower than American ones. Original Atari 800 and 400 systems included another processor, CTIA that assisted Antic in producing the graphics output. Shortly after introduction this chip was upgraded to the GTIA also included in all subsequent Atari 8-bit models. GTIA provides three new color processing modes which are accessible via Atari BASIC GRAPHICS modes 9, 10, and 11. The alternative color interpretations are the basis of additional graphics modes, but for the purposes of discussing Atari BASIC these do not affect the basic description as they were programmed much the same way as existing modes. [ Sprites (Player/Missile Graphics) ] A hardware sprite system is handled by CTIA/GTIA. The official ATARI name for the sprite system is &quot; Player/Missile Graphics &quot;, since it was designed to reduce the need to manipulate display memory for fast-moving objects, such as the &quot; player &quot; and his weapons, &quot; missiles &quot;, in a shoot &apos;em up game. See the CTIA/GTIA page for the technical description of the Player/Missile implementation. Atari BASIC does not provide direct support for Player/Missile graphics beyond the capability of PEEK/POKE. Moving a sprite horizontally is as simple as changing a register in the CTIA/GTIA (in Atari BASIC, a single POKE statement moves a player or missile horizontally). Moving the sprite vertically is achieved by block moving (or rotating) the definition of its glyph in memory. This is quite fast in 6502 machine language, even though the 6502 lacks a block-move instruction like the 8080, because the sprite is exactly 128 or 256 bytes long and so the indexing can be easily accommodated in a byte-wide register on the 6502. However, block memory moves are painfully slow in Atari BASIC. BASIC programs using sprites will ordinarily use one of two methods to perform high speed memory moves: first is including short USR() routines to perform the memory moves. The second exploits Atari BASIC&apos;s flexible string management by defining a large string for the Player/Missile memory map, and then using string copy functions which move memory at machine language speeds. Careful use of sprites with the other graphics features of the Atari hardware can make graphics programming, particularly games, significantly simpler. [ Interrupts ] Short sections of machine language code can be executed during the horizontal blanking interval, and this is typically done to change the values in the color registers, horizontal sprite positions and so forth thus giving the appearance of more colors or more flexible sprites than the hardware provides ab initio. This machine code has to be very short as there are not many clock cycles available during each horizontal blank. These routines are known as DLIs (display list interrupts) but are simply off limits to Atari BASIC as it is far too slow to perform even the simplest of tasks. Strictly these should be called &quot; DLI routines &quot; but are usually just called &quot; DLIs &quot;. During the vertical blanking interval, a much longer interval, another interrupt is generated and the Operating System hooks into this to perform some housekeeping tasks. Again, this is not available to Atari BASIC directly, although with some manipulation and severe restrictions (because BASIC was not designed to be re-entrant ) it is possible for a VBI (vertical blank interrupt) routine to call a BASIC routine. The VBI is a favourite place to stick some code that needs to execute frequently. [ Operating system support ] The operating System provided several standard &quot; Graphics modes &quot; by which it set up a display list automatically, and allocated memory, at the top end of free memory. These provided a range of graphics modes including text modes, graphics modes and mixed text-and-graphics modes. It was only these predefined modes that were available to Atari BASIC. The lack of an OS routine for a general-purpose memory move routine perhaps exhibited in artifacts of the graphics design. For example, once a graphics channel had been opened, it was not possible (or at least easy) to move it down in memory so that other memory could be reserved above it, which meant that generally a program would allocate &quot; more than enough &quot; memory above the high memory pointer (HIMEM) then set the graphics mode (with the GRAPHICS statement) to have the operating system allocate memory for the display below the new high water mark. Most of ANTIC&apos;s registers were write-only, their values could not be read (or rather they could be, but were meaningless or returned different values from those written as they were multiplexed ). The Operating System kept copies of the values written in &quot; shadow registers &quot; in pages 0 and 2 of memory (page 1 was the hardware stack on 6502 processors), thus allowing programs to read the values. The values written here were rewritten to the ANTIC registers during the vertical blank interrupt. The operating system provided access to the graphics in two ways: by allowing direct reads and writes (in Atari BASIC, through the PEEK and POKE commands to the memory being used to hold the graphics, by making available the address of the start of that memory in a well-known location, and to the shadow registers), and also by providing a CIO device, &quot; S: &quot;, through which CIO commands could be issued. The S: device supported the general-purpose XIO command used to implement PLOT, DRAWTO and FILL (unfortunately the last was not exposed to Atari BASIC, and was also rather tricky to get right at the best of times, as it used a rather primitive scanline fill that filled lines left-to-right, bottom-to-top but stopped as soon as a boundary was met, rather than providing a full flood fill ). In a way there was some confusion and overlap here in the design. For example, the CIO NOTE and POINT commands could be considered analogous to reading and writing the position of the cursor, but instead they had a separate interface through well-defined memory locations. Thus the exposure of the graphics API to BASIC and other languages was perhaps not as orthogonal and device-independent as it could have been. [ Atari BASIC support ] Atari BASIC supported graphics using the statements COLOR, SETCOLOR, CLEAR, PLOT, DRAWTO, LOCATE and GRAPHICS. Because of the support provided by the operating system, Atari BASIC implemented most of its graphics statements as simple calls to those routines or just set the memory registers for the cursor position and so on. In many cases it simply left programmers to use PEEK and POKE statements. It could be argued that some statements such as SETCOLOR were not only redundant but confusing, since they simply set one color value in a shadow register and could be as easily, and more quickly, done with a POKE command; the ROM space used by these routines could perhaps have been better used to implement other things. The lack of a FILL command is a notable omission considering that the routine, however primitive, was available in the operating system. It could be achieved with the general-purpose XIO command, but was rather fiddly: { REM The co-ordinates of the corners of the fill quadrilateral have to be set up } { REM before calling XIO, using POKE into the IOCB. This is quite a trick because } { REM it&apos;s not easy to find out where the IOCB is. Anyway, then we do: } { XIO 18,#6,12,0, &quot; S: &quot; } { REM XIO # = Extended IO. } { REM 18 = Fill (17=Drawto). } { REM #6 = On Channel 6, mapped to the graphics screen device. } { REM 12 = Read/write. } { REM 0 = Redundant (unused). } { REM &quot; S: &quot; = Logical device, used only for OPEN and some disk } { REM commands with a target such as for a RENAME } { REM Redundant here but used by convention } There was no BASIC support for sprites, although they were not particularly difficult to program in BASIC using PEEK and POKE, but this could not be done particularly fast in, say, games. Similarly, setting up a custom display list could be done, but was rather difficult, and was far more easily and effectively done in machine language. Sprite data could be defined using a DATA statement, and then POKE d into memory. However, scrolling a sprite vertically, for example, was not quick in BASIC as there was no &quot; block memory move &quot; statement and required a slow FOR loop of PEEK s and POKE s. [ Hardware support ] In comparison to the BASICs of some competing machines at the time, Atari BASIC had good built-in support of sound, ( SOUND statement), graphics ( GRAPHICS, SETCOLOR, COLOR, PLOT and DRAWTO ) and peripheral units like joysticks ( STICK, STRIG ) and paddles ( PADDLE, PTRIG ). Other home computer users were often left with cryptic POKE s for such programming. That being said, the parameters for many of these commands were cryptic, and essentially little better than machine code. SOUND took four numeric parameters for pitch, tone, volume and channel (the Atari 8-bits had 4-channel sound); the GRAPHICS statement took three to handle the numerous graphics modes, SETCOLOR and COLOR each took a number of parameters with different meanings depending on the graphics mode and often which did not match between the two, and so forth. It may be an example of Conway&apos;s law : clever designers made excellent hardware, by and large following a common model (memory-mapped register addressing for ANTIC, GTIA and Pokey, for example), but the lack of the teams&apos; interaction made them work in curiously different ways. One may wonder why it would be thought so important to include two key words for examining the state of paddles – something that could be done easily with a single PEEK and indeed in every respect more efficiently than a PADDLE statement – yet not have a FILL command that was already coded in the OS and would have been uniquely advanced for the BASICs of the time. Similarly, advanced aspects of the hardware such as sprite s were completely out of bounds for BASIC programmers, and the lack of access to timers made sound programming difficult, particularly because North American machines ran on different clock speed s from the rest of the world (basically because they were tied to the speed of the television system). [ Performance ] Running on the original equipment, Atari BASIC is slower than other BASICs on contemporaneous equipment for the same home market, sometimes by a surprising amount, especially when one takes into account the fact that the Atari&apos;s CPU was clocked almost twice as fast as that of most other 6502-based computers of that era. Most of these problems stemmed from two particularly poorly implemented bits of code. One is a side effect of how Atari BASIC recalculates line numbers as the program is run. This means that a GOTO has to run a small amount of additional code in order to find the line to jump to. { For added excitement, unlike in most other BASICs, if the line number is not found, execution continues at the lowest-numbered line higher than that specified rather than producing an UNDEFINED STATEMENT ERROR } This would normally be a minor issue, but the same code is also used to implement NEXT in a FOR... NEXT loop, so it dramatically lowers performance of these very common loops (indeed, the only loop structure in Atari BASIC). It is obvious that a line number less than 65536 10 (10000 16 ) can be stored in a 16-bit unsigned integer, but presumably the designers chose to store it as floating point for other reasons. Atari BASIC does not do well with integer variables; all numbers are stored as floating point. Atari BASIC relied on the Atari OS&apos;s built-in floating point routines ( BCD notation), which are relatively slow compared to other representations, even on the same hardware. But most of the slowness of the implementation lies in a particularly poor implementation of the multiply subroutine used throughout the math libraries. This is really not a problem of the language itself but of the underlying OS, but it adds to the general poor performance. More spectactularly, really, the fact that simple integer operations are converted back and forth to floating point really highlights the flaw, especially considering that the Atari&apos;s best features rely on special hardware (for graphics, sound and so on) that deals purely in integers: bytes or two-byte words. There is not even in Atari BASIC an easy way to perform bitwise operation s. The MOS 6502 processor had a special mode for dealing with BCD (the SED and CLD instructions to treat each 4 bits of a byte as a BCD digit), and perhaps that was particularly attractive to the designers for implementing floating point as BCD. The now almost universal IEEE 754 standard of representation of floating point numbers was still at the design stage when the Atari 8 bit family and its contemporaries first came to market, so the design of an FP implementation was very much up to the OS or BASIC designer. Several commercial and shareware BASICs were available on the platform that addressed some or all of these issues, resulting in performance that was 3 to 5 times faster than the Atari version. Using these BASICs, the Atari was one of the fastest home computers of its era. Atari later sold a diskette -based version of Microsoft BASIC, Atari Microsoft BASIC, and later managed to fit it onto a cartridge as well, but no compiler or runtime was available for redistribution. [ Advanced techniques ] Despite its small footprint (8 kilobytes), Atari BASIC has some features that give it some powers of more-advanced, larger versions of BASIC. [ Subroutines ] Atari BASIC has no implementation of subroutine s, or rather, it does not have a concept of local variable s. In Fortran terminology, all variables are COMMON. But programmers can simulate user functions because of the way the GOSUB command can reference a variable. For example, a programmer could start a subroutine at line 10000 and have the program initialize a variable with that number, e.g. LET TEST = 10000. The calling code can then initialize some mutually understood variables and use the statement GOSUB TEST to invoke the subroutine. The subroutine starting at line TEST can then do its operation on the predetermined variables and put return results into variables available after RETURN. By extension, if the two agree on two variables, an array called, say, STACK and a numeric variable called STACKTOP, then a stack can be implemented in software whereby local variables are pushed and popped to the stack and so implement local variables. For example: 10 DIM STACK(100)20 STACKTOP = 035 REM LINE NUMBERS OF SOME FUNCTIONS FOLLOW40 FACTORIAL = 800060 PUSHSTACK = 210070 POPSTACK = 220075 REM LET&apos;S COMPUTE EIGHT FACTORIAL80 LET STACKVALUE = 8: GOSUB PUSHSTACK90 GOSUB FACTORIAL100 GOSUB POPSTACK110 PRINT &quot; EIGHT FACTORIAL IS &quot;; STACKVALUE120 END2099 REM PUSHSTACK SUBROUTINE2100 STACK(STACKTOP) = STACKVALUE: STACKTOP = STACKTOP + 1: RETURN2199 REM POPSTACK SUBROUTINE2200 STACKTOP = STACKTOP - 1: STACKVALUE = STACK(STACKTOP): RETURN7999 REM FACTORIAL SUBROUTINE8000 GOSUB POPSTACK8010 IF STACKVALUE &lt; = 2 THEN GOSUB PUSHSTACK: RETURN8020 FACTORIAL = STACKVALUE8030 STACKVALUE = STACKVALUE - 1: GOSUB PUSHSTACK8040 GOSUB POPSTACK: FACTORIAL = FACTORIAL * STACKVALUE8050 RETURN BASIC or FORTRAN aficionados may notice that line 8010 can be optimized because a GOSUB followed by a RETURN is the same as a GOTO, because the subroutine will do the RETURN for us: 8010 IF STACK VALUE &lt; = 2 THEN GOTO PUSHSTACK This is of course a cute example of why the GOTO statement is Considered Harmful. [ Includes ] Because Atari BASIC can read in lines of code from any device, not just the editor, it is possible to save blocks of code and then read them in and merge them into a single program just as if they had been typed into the editor. Of course this means the lines being read in must have line numbers that are not used in the main program. The code to be merged is written to a device as text using the LIST command, and can be put back into the program with the ENTER command. So the stream of text on the device is, from the BASIC interpreter&apos;s point of view, no different from that had it been typed into the editor. By carefully using blocks of line numbers that do not overlap, programmers can build libraries of subroutines (simulating functions as above) and merge them into new programs as needed. [ Embedded machine language ] Atari BASIC does not have a built-in assembly language processor. Machine code is generally stored as bytes in strings. Machine code functions are invoked from Atari BASIC with the USR statement, which works in much the same way as GOSUB, but with fewer guarantees. String variables can hold any of the 256 characters available in the ATASCII character set and thus each byte of memory reserved for a string variable can hold any number from 0 to 255, including the characters 34 10 (22 16, &quot; quote &quot; ) and 155 10 (9B 16, &quot; ENTER &quot; ), although these are tricky to type in. Short relocatable 6502 machine language routines can be converted to ATASCII characters and stored in the string variable. The machine language routine can be called as a function with the USR command specifying the address of the string variable as the location in memory to execute. For example, if the machine language code is stored in a string named ROUTINE$ it can be called with parameters as ANSWER=USR(ADR(ROUTINE$),VAR1,VAR2). Parameters are pushed onto the hardware stack (in Page 1) as 16-bit integers; variables are pushed as their addresses. The return value is in the A and X registers and interpreted by BASIC as a 16-bit integer; it cannot be pushed to the stack as there is no concept of a stack frame, and for the same reason there is no concept of a void return, but typically if the machine code subroutine does not return anything useful, the value – just whatever happens to be in those registers at the time – is just ignored. These routines have to use relocatable machine code: that is to say, they cannot use instructions like JMP or JSR that use absolute addresses, except to well-known addresses in the OS and so forth; they can only use branch instructions such as BCC (branch if carry clear) which jump backwards or forwards by roughly 128 10 (80 16 ) { Because the branch amount is one byte in two&apos;s complement arithmetic, but the instruction pointer onto which it is applied is already at the next instruction, so actually it can go -128 + 2 = 126 bytes back, or +127 + 2 = 129 bytes forward, from the current instruction, the 2 being the number of bytes the branch instruction takes. That only adds up to 245 places it could go, where did the other 11 go? Well, -2 +2 goes to the branch instruction again and so is an infinite loop; -1 goes to the -1 itself, which is not a valid instruction in the 6502 instruction set; +0 goes to the next instruction, and so is effectively a NOP but takes two cycles rather than 1. The other few small branches, similarly, might jump to an instruction or to part of an address, depending on whether the instructions before or after the branch are one, two or three bytes long. } because the strings could be moved in memory. For this reason page 6 (0600 16 –06FF 16 ), a page of memory not used by BASIC or the operating system, is very popular for storing small routines; but of course one runs the danger that another routine may also wish to be stored there. On the 6502, relocation is not trivial. These days we expect programs to sit pretty much anywhere in memory; the loader and processor collaborate to make that happen. But microprocessors of that era did not do that. The 6502 was especially hindered by having very few indirection instructions, and those it had were asymmetric: the X and Y registers indirect in different directions. This leads either to rather clumsy code that is forever moving stuff between registers, or clever but obtuse code that keeps them where they need to be even if it would seem more obvious to stick something else there. The 6502 instruction set is small enough that, over a short time, programmers can model the entire processor in their heads, even down to knowing how many cycles each instruction takes, and then start making clever tricks. As well as using machine code for advanced functions, fairly trivial USR routines are sometimes used simply to gain access to functions in the Atari OS that have not been provided through Atari BASIC: for example block serialization to and from devices (Atari BASIC only lets it be done byte by byte, with GET and PUT, which takes far longer for just shuffling back and forth through the OS layers than actually writing the one byte of data), or for reading and writing blocks of memory (the PEEK and POKE commands were also unnecessarily slow because of the numeric problems described above). Machine code can also be stored as numbers in DATA statements, but this is pathological in that a byte is then stored as a six-byte floating point number, plus several other overheads, simply to be placed somewhere else as a byte. This method is sometimes used for very short routines where size isn&apos;t important but ease of use is (no special loaders or clever typing routines are required), or for one-off programs that then write out the resulting block of bytes (probably stored in a string) is written out as a program that can be read in later byte-for-byte. [ Atari BASIC keywords ] ABS Returns the absolute value of a number ADR Returns the address in memory of a variable (mostly used for machine code routines stored in variables) AND Logical conjunction ASC Returns the ATASCII value of a character ATN Returns the arctangent of a number BYE Transfers control to the internal &quot; Self Test &quot; program ( &quot; Memo Pad &quot; on early models) CHR$ Returns a character given an ATASCII value CLOAD Loads from cassette tape a tokenized program that was saved with CSAVE CLOG Returns the common logarithm of a number CLOSE Terminates pending transfers (flush) and closes an I/O channel CLR Clears variables&apos; memory and program stack COLOR Chooses which logical color to draw in COM Implementation of MS Basic&apos;s COMMON was cancelled. Recognized but the code for DIM is executed instead CONT Resumes execution of a program after a STOP at the next line number (see STOP) COS Returns the cosine of a number CSAVE Saves to cassette tape a program in tokenized form with fast method (short inter-record gap on tape) (see CLOAD) DATA Stores data in lists of numeric or string values DEG Switches trigonometric functions to compute in degrees ( radian s is the default mode) (see RAD) DIM Defines the size of a string or array (see COM) DOS Transfers control to the Disk Operating System (DOS); if DOS was not loaded, same as BYE DRAWTO Draws a line to given coordinates END Finishes execution of the program, closes open I/O channels and stops any sound ENTER Loads and merges into memory a plain text program from an external device, usually from cassette tape or disk (see LIST) EXP Exponential function FOR Starts a for loop FRE Returns the amount of free memory in bytes GET Reads one byte from an I/O channel (see PUT) GOSUB Jumps to a subroutine at a given line in the program, placing the return address on the stack (see POP and RETURN) GOTO and GO TO Jumps to a given line in the program. GOTO can be omitted in &quot; IF... THEN GOTO... &quot; GRAPHICS Sets the graphics mode IF Executes code depending on whether a condition is true or not INPUT Retrieves a stream of text from an I/O channel; usually data from keyboard (default), cassette tape or disk INT Returns the floor of a number LEN Returns the length of a string LET Assigns a value to a variable. LET can be omitted LIST Lists (all or part of) the program to screen (default), printer, disk, cassette tape, or any other external device (see ENTER) LOAD Loads a tokenized program from an external device; usually a cassette tape or disk (see SAVE) LOCATE Stores the logical color or ATASCII character at given coordinates LOG Returns the natural logarithm of a number LPRINT Prints text to a printer device (same result can be achieved with OPEN, PRINT and CLOSE statements) NEW Erases the program and all the variables from memory; automatically executed before a LOAD or CLOAD NEXT Continues the next iteration of a FOR loop NOT Logical negation NOTE Returns the current position on an I/O channel ON A computed goto - performs a jump based on the value of an expression OPEN Initialises an I/O channel OR Logical disjunction PADDLE Returns the position of a paddle controller PEEK Returns the value at an address in memory PLOT Draws a point at given coordinates POINT Sets the current position on an I/O channel POKE Sets a value at an address in memory POP Removes a subroutine return address from the stack (see GOSUB and RETURN) POSITION Sets the position of the graphics cursor PRINT and ? Writes text to an I/O channel; usually to screen (default), printer, cassette tape or disk (see LPRINT and INPUT) PTRIG Indicates whether a paddle trigger is pressed or not PUT Writes one byte to an I/O channel (see GET) RAD Switches trigonometric functions to compute in radian s (see DEG) READ Reads data from a DATA statement REM Marks a comment in a program RESTORE Sets the position of where to read data from a DATA statement RETURN Ends a subroutine, effectively branching to the line immediately following the &quot; calling &quot; GOSUB (see GOSUB and POP) RND Returns a pseudorandom number RUN Starts execution of a program, optionally loading it from an external device (see LOAD) SAVE Writes a tokenized program to an external device; usually a cassette tape or disk (see LOAD) SETCOLOR Maps a logical color to a physical color SGN Returns the signum of a number SIN Returns the sine of a number SOUND Starts or stops playing a tone on a sound channel (see END) SQR Returns the square root of a number STATUS Returns the status of an I/O channel STEP Indicates the increment used in a FOR loop STICK Returns a joystick position STOP Stops the program, allowing later resumption (see CONT) STRIG Indicates whether a joystick trigger is pressed or not STR$ Converts a number to string form THEN Indicates the statements to execute if the condition is true in an IF statement TO Indicates the limiting condition in a FOR statement TRAP Sets to jump to a given program line if an error occurs (TRAP 40000 cancels this order) USR Calls a machine code routine, optionally with parameters VAL Returns the numeric value of a string XIO General-purpose I/O routine (from &quot; Fill screen &quot; to &quot; Rename file &quot; to &quot; Format disk &quot; instructions) [ Running without Atari BASIC ] On the XL/XE models, Atari BASIC could be disabled by holding down the OPTION key while booting the computer. The XEGS would disable BASIC if powered without the keyboard attached. If another cartridge were inserted it may also disable Atari BASIC, if they used the same address space. [ See also ] BASIC A+ – An extended BASIC for the Atari, from Optimized Systems Software (OSS) Turbo-Basic XL - Freeware BASIC compatible with Atari BASIC, also available with a compiler for greater speed and extra commands. [ References ] [ The ATARI BASIC Reference Manual Atari Inc 1980 http://www.strotmann.de/twiki/bin/view/Infothek/AtBasicReferenceMa http://web.archive.org/web/20050501034651/http%3A//www.strotmann.de/twiki/bin/view/Infothek/AtBasicReferenceMa May 1, 2005 ] [ Wilkinson Bill The Atari BASIC Source Book COMPUTE! Books 1983 0-942386-15-9 http://users.telenet.be/kim1-6502/6502/absb.html Optimized Systems Software,Inc. 2009-04-04 ] [ Wilkinson Bill Inside Atari DOS COMPUTE! Books 1982 0-942386-02-7 http://www.atariarchives.org/iad/introduction.php Optimized Systems Software,Inc. 2009-04-04 ] [ http://www.atariarchives.org/dere/chapt10.php De Re Atari 10: ATARI BASIC AtariArchives.org 2009-04-04 ] – A detailed description of the dialect and interpreter [ Notes ] [ External links ] { * Atari BASIC, The Good, the Bad, and the Ugly } [ Bob Albrecht LeRoy Finkel Jerald R. Brown 1979 ] [ ] Bob Albrecht LeRoy Finkel Jerald R. Brown 1985 ] XFormer, a free Atari Emulator which needs no ROMs or other items De Re Atari by Chris Crawford Category:Atari 8-bit family software Category:Programming languages created in 1978 Category:Discontinued BASICs Category:BASIC interpreters ca:Atari BASIC de:Atari BASIC es:Atari BASIC pl:Atari BASIC pt:Atari BASIC