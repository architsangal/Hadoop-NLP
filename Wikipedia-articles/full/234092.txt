[ September 2009 ] [ May 2009 ] In computer programming, the extensibility pattern is a design pattern that provides a framework for straightforward addition of functionality to a system at a later date. Extensibility is often desired when an application must be able to support new features, such as networking protocol s or file format s, that do not yet exist. This requires the application to supply a framework for the general problem without concern for the specifics of details. [ Frameworks ] A framework uses other modules. Normal modules have a fixed set of dependencies, and are only extended through subclassing, as per inheritance. A framework may consist of several parts that must be inherited to be used much like several cases of abstract class. It may also be passed references to other objects, as would a class that is sets up a model-view-controller. It may read names of classes from a configuration file or from the user, as in BeanPattern. Instead of code being used by other code, it will use other code on the fly. It is on top of the food chain instead of the bottom. [ Configuration files as extensions ] A ConfigFile may be enough to customize the module for reasonable needs. It may also specify modules by name to be created and employed in a framework. the config.pl file defines @listeners to contain a list of class names that should receive notices from an EventListener broadcaster, referenced by $broadcaster. require &apos;config.pl&apos;; foreach my $listener (@listeners) { { require $listener; } { my $list_inst = $listener- &gt; new; } { $broadcaster- &gt; add_listener($list_inst); } } See Event listener for the broadcast er /listener idiom. This avoids building the names of listener modules into the application. An independent author could write a plugin to this application: she would need only have the user modify //config.pl// to include mention of the plugin. Of course, modification of //config.pl// could be automated. The install program for the plugin would need to ask the user where the //config.pl// is, and use the ConfigFile idiom to update it. [ Extending through scripting ] A major complaint against GUI s is that they make it difficult to script repetitive tasks. Command line interface s are difficult for most humans to work with. Neither give rich access to the application programming interface (API) of a program. A well-designed program is a few lines of Perl in the main program that use a number of modules — see Creating CPAN Modules. This makes it easier to reuse the program logic in other programs. Complex programs that build upon existing parts benefit from this, without question. How about the other case — a small script meant to automate some task? This requires that the script have knowledge about the structure of the application — it must know how to assemble the modules, initialize them, and so on. It is forced to work with aspects of the API that it almost certainly is not concerned with. It must itself be the framework. This is a kind of abstraction inversion — where something abstract is graphed onto something concrete, or something simple is grafted onto the top of something complex. It would make more sense in this case for the application to implement a sort of visitor pattern, and allow itself to be passed whole, already assembled, to another spat of code that knows how to perform specific operations on it. This lends itself to the sequential nature of the script: the user-defined extension could be a series of simple calls: package UserExtention1; we are expected to have a &quot; run_macro &quot; method sub run_macro { { my $this = shift; } { my $app = shift; } { $app- &gt; place_cursor(0, 0); } { $app- &gt; set_color(&apos;white&apos;); } { $app- &gt; draw_circle(radius= &gt; 1); } { $app- &gt; set_color(&apos;red&apos;); } { $app- &gt; draw_circle(radius= &gt; 2); } { # and so on... make a little bull&apos;s eye } { return 1; } } The main application could prompt the user for a module to load, or load all of the modules in a plugins directory, then make them available as menu items in an &quot; extensions &quot; menu. When one of the extensions are select from the menu, a reference to the application — or a facade pattern providing an interface to it — is passed to the run_macro() method of an instance of that package. Many applications will have users that want to do simple automation without being bothered to learn even a little Perl (horrible but true!). Some applications (like Mathematica, for instance) will provide functionality that does not cleanly map to Perl. In this case, you would want to be able to parse expressions and manipulate them. In these cases, a Little Language may be just the thing. A Little Language is a small programming language, created specifically for the task at hand. It can be similar to other languages. Having something clean and simple specifically targeted at the problem can be better solution than throwing an overpowered language at it. Just by neglecting unneeded features, user confusion is reduced. { place_cursor(0, 0) } { set_color(white) } { draw_circle(radius=1) } { set_color(red) } { draw_circle(radius=2) } A few options exist: we can compile this directly to Perl bytecode, using B::Generate (suitable for integrating legacy languages without performance loss), or we can munge this into Perl and ||eval|| it. Let us turn it into Perl. read in the users program my $input = join &apos;&apos;, &lt; STDIN &gt;; 0 if we&apos;re expecting a function name, 1 if we&apos;re expecting an argument, 2 if we&apos;re expecting a comma to separate arguments my $state = 0; perl code we&apos;re creating my $perl = &apos; { package UserExtention1; } { sub run_macros { } { my $this = shift; } { my $app = shift; } &apos;; while(1) { { # function call name } { if($state == 0 &amp; &amp; $input =~ /\G\s*(\w+)\s*\(/cgs) { } { $perl.= &apos; $app- &gt; &apos;. $1. &apos;(&apos;; } { $state = 1; } { # a=b style parameter } { } elsif($state == 1 &amp; &amp; $input =~ /\G\s*(\w+)\s*=\s*(\w+)/cgs) { } { $perl.= &quot; $1= &gt; &apos;$2&apos; &quot;; } { $state = 2; } { # simple parameter } { } elsif($state == 1 &amp; &amp; $input =~ /\G\s*(\w+)/cgs) { } { $perl.= &quot; &apos;$1&apos; &quot;; } { $state = 2; } { # comma to separate parameters } { } elsif($state == 2 &amp; &amp; $input =~ /\G\s*,/cgs) { } { $perl.= &apos;, &apos;; } { $state = 1; } { # end of parameter list } { } elsif(($state == 1 || $state == 2) &amp; &amp; $input =~ /\G\s*\)/cgs) { } { $perl.= &quot; );\n &quot;; } { $state = 0; } { # syntax error or end of input } { } else { } { return 1 unless $input =~ /\G./cgs; } { print &quot; operation name expected\n &quot; if $state == 0; } { print &quot; parameter expected\n &quot; if $state == 1; } { print &quot; comma or end of parameter list expected\n &quot; if $state == 2; } { return 0; } { } } } $perl.= &apos; { return 1; } { } } &apos;; eval $perl; if($@) { { # display diagnostic information to user } } We&apos;re using the \G regex metacharacter that matches where the last global regex on that string left off. That let us take off several small bites from the string rather than having to do it all in one big bite. The flags on the end of the regex are: g - global - needed for the \G token to work c - not sure, but it makes g work s - substring - treat the entire string as one string. Newlines become regular characters and match whitespace. Out of context, the string &quot; xyzzy &quot; could be either a parameter or the name of a method to call. The solution is simply to keep track of context: that is where $state comes in. Every time we find something, we update $state to indicate what class of thing would be valid if it came next. After we find a function name and an opening parenthesis, either a hash style parameter or a single, lone parameter, or else a close parenthesis would be valid. We are not even looking for the start of another function [though perhaps we should be. If changed, this in our code, it would allow us to nest function calls inside of each other. We would have to track our level of nesting if we wanted to report errors if there were too many or too few right-parenthesis. Exercise left for the reader.]. After a parameter, we are looking for either the close parenthesis or another parameter. Every time we match something, we append a Perl-ized version of exactly the same thing onto $perl. All of this is wrapped in a package and method declaration. Finally, $perl is evaluated. The result of evaluating should be to make this new package available to our code, ready to be called. [ Beans as extensions ] [ July 2010 ] [ Hacks as extensions ] When a base application, or shared code base, is customized in different directions for different clients, heavy use should be made of template method s and abstract factories, localizing client-specific code into a module or tree of modules under a client-specific namespace, rather than &quot; where it belongs &quot;. [ References ] The article is originally from Perl Design Patterns Book. Category:Software design patterns Category:Articles with example Perl code