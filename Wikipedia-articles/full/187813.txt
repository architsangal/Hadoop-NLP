Transport Layer Security (TLS) and its predecessor, Secure Sockets Layer (SSL), are cryptographic protocol s that provide communication security over the Internet. [ http://tools.ietf.org/html/rfc5246 The Transport Layer Security (TLS) Protocol, Version 1.2 August 2008 T. Dierks, E. Rescorla ] TLS and SSL encrypt the segments of network connections at the Application Layer for the Transport Layer, using asymmetric cryptography for key exchange, symmetric encryption for privacy, and message authentication code s for message integrity. Several versions of the protocols are in widespread use in applications such as web browsing, electronic mail, Internet fax ing, instant messaging and voice-over-IP (VoIP). TLS is an IETF standards track protocol, last updated in RFC 5246, and is based on the earlier SSL specifications developed by Netscape Communications. [ http://tools.ietf.org/html/rfc6101 The Secure Sockets Layer (SSL) Protocol Version 3.0 August 2011 A. Freier, P. Karlton, P. Kocher ] [ Description ] The TLS protocol allows client-server applications to communicate across a network in a way designed to prevent eavesdropping and tampering. Since most protocols can be used either with or without TLS (or SSL) it is necessary to indicate to the server whether the client is making a TLS connection or not. There are two main ways of achieving this, one option is to use a different port number for TLS connections (for example port 443 for HTTPS ). The other is to use the regular port number and have the client request that the server switch the connection to TLS using a protocol specific mechanism (for example STARTTLS for mail and news protocols). Once the client and server have decided to use TLS they negotiate a stateful connection by using a handshaking procedure. { &quot; SSL/TLS in Detail &quot;. } { Microsoft TechNet. Updated July 31, 2003. } During this handshake, the client and server agree on various parameters used to establish the connection&apos;s security. The client sends the server the client&apos;s SSL version number, cipher settings, session-specific data, and other information that the server needs to communicate with the client using SSL. The server sends the client the server&apos;s SSL version number, cipher settings, session-specific data, and other information that the client needs to communicate with the server over SSL. The server also sends its own certificate, and if the client is requesting a server resource that requires client authentication, the server requests the client&apos;s certificate. The client uses the information sent by the server to authenticate the server (see Server Authentication for details). If the server cannot be authenticated, the user is warned of the problem and informed that an encrypted and authenticated connection cannot be established. If the server can be successfully authenticated, the client proceeds to step 4. Using all data generated in the handshake thus far, the client (with the cooperation of the server, depending on the cipher being used) creates the pre-master secret for the session, encrypts it with the server&apos;s public key (obtained from the server&apos;s certificate, sent in step 2), and then sends the encrypted pre-master secret to the server. If the server has requested client authentication (an optional step in the handshake), the client also signs another piece of data that is unique to this handshake and known by both the client and server. In this case, the client sends both the signed data and the client&apos;s own certificate to the server along with the encrypted pre-master secret. If the server has requested client authentication, the server attempts to authenticate the client (see Client Authentication for details). If the client cannot be authenticated, the session ends. If the client can be successfully authenticated, the server uses its private key to decrypt the pre-master secret, and then performs a series of steps (which the client also performs, starting from the same pre-master secret) to generate the master secret. Both the client and the server use the master secret to generate the session keys, which are symmetric keys used to encrypt and decrypt information exchanged during the SSL session and to verify its integrity (that is, to detect any changes in the data between the time it was sent and the time it is received over the SSL connection). The client sends a message to the server informing it that future messages from the client will be encrypted with the session key. It then sends a separate (encrypted) message indicating that the client portion of the handshake is finished. The server sends a message to the client informing it that future messages from the server will be encrypted with the session key. It then sends a separate (encrypted) message indicating that the server portion of the handshake is finished. The SSL handshake is now complete and the session begins. The client and the server use the session keys to encrypt and decrypt the data they send to each other and to validate its integrity. [ http://support.microsoft.com/kb/257591 Description of the Secure Sockets Layer (SSL) Handshake Support.microsoft.com 2008-07-07 2012-05-17 ] This is the normal operation condition of the secure channel. At any time, due to internal or external stimulus (either automation or user intervention), either side may renegotiate the connection, in which case, the process repeats itself. This concludes the handshake and begins the secured connection, which is encrypted and decrypted with the key material until the connection closes. If any one of the above steps fails, the TLS handshake fails and the connection is not created. [ History and development ] [ Secure Network Programming API ] Early research efforts toward transport layer security included the Secure Network Programming (SNP) application programming interface (API), which in 1993 explored the approach of having a secure transport layer API closely resembling Berkeley sockets, to facilitate retrofitting preexisting network applications with security measures. { Thomas Y. C. Woo, Raghuram Bindignavle, Shaowen Su and } { Simon S. Lam, SNP: An interface for secure network programming Proceedings USENIX Summer Technical Conference, June 1994 } [ SSL 1.0, 2.0 and 3.0 ] The SSL protocol was originally developed by Netscape. [ http://web.archive.org/web/19970614020952/http%3A//home.netscape.com/newsref/std/SSL.html 14 June 1997 THE SSL PROTOCOL http://home.netscape.com/newsref/std/SSL.html Netscape Corporation 2007 ] Version 1.0 was never publicly released; version 2.0 was released in February 1995 but &quot; contained a number of security flaws which ultimately led to the design of SSL version 3.0 &quot;. { Rescorla 2001 } SSL version 3.0, released in 1996, was a complete redesign of the protocol produced by Paul Kocher working with Netscape engineers Phil Karlton and Alan Freier. Newer versions of SSL/TLS are based on SSL 3.0. The 1996 draft of SSL 3.0 was published by IETF as a historic document in RFC 6101. [ TLS 1.0 ] TLS 1.0 was first defined in RFC 2246 in January 1999 as an upgrade to SSL Version 3.0. As stated in the RFC, &quot; the differences between this protocol and SSL 3.0 are not dramatic, but they are significant enough that TLS 1.0 and SSL 3.0 do not interoperate. &quot; TLS 1.0 does include a means by which a TLS implementation can downgrade the connection to SSL 3.0, thus weakening security. On September 23, 2011 researchers Thai Duong and Juliano Rizzo demonstrated a &quot; proof of concept &quot; called BEAST (Browser Exploit Against SSL/TLS) using a Java Applet to violate same origin policy constraints, for a long-known Cipher block chaining (CBC) vulnerability in TLS 1.0. [ http://www.theregister.co.uk/2011/09/19/beast_exploits_paypal_ssl/ Hackers break SSL encryption used by millions of sites 2011-09-19 Dan Goodin ] [ http://news.ycombinator.com/item?id%3D3015498 Y Combinator comments on the issue 2011-09-20 ] Practical exploits had not been previously demonstrated for this vulnerability, which was originally discovered by Phillip Rogaway [ http://www.openssl.org/~bodo/tls-cbc.txt Security of CBC Ciphersuites in SSL/TLS 2004-05-20 ] in 2002. Mozilla updated the development versions of their NSS libraries to mitigate BEAST-like attacks. NSS is used by Mozilla Firefox and Google Chrome to implement SSL. Some web server s that have a broken implementation of the SSL specification may stop working as a result. [ https://bugzilla.mozilla.org/show_bug.cgi?id%3D665814 (CVE-2011-3389) Rizzo/Duong chosen plaintext attack (BEAST) on SSL/TLS 1.0 (facilitated by websockets -76) 2011-09-30 Brian Smith ] Microsoft released Security Bulletin MS12-006 on January 10, 2012, which fixed the BEAST vulnerability by changing the way that the Windows Secure Channel ( SChannel ) component transmits encrypted network packets. [ http://technet.microsoft.com/en-us/security/bulletin/ms12-006 Vulnerability in SSL/TLS Could Allow Information Disclosure (2643584) 2012-01-10 ] As a work-around, the BEAST attack can also be prevented by removing all CBC ciphers from one&apos;s list of allowed ciphers—leaving only the RC4 cipher, which is still widely supported on most websites. [ http://serverfault.com/questions/315042/ Safest ciphers to use with the BEAST? (TLS 1.0 exploit) 2011-09-24 ] [ http://www.h-online.com/security/news/item/First-solutions-for-SSL-TLS-vulnerability-1349813.html First solutions for SSL/TLS vulnerability 2011-09-26 ] Users of Windows 7 and Windows Server 2008 R2 can enable use of TLS 1.1 and 1.2, but this work-around will fail if it is not supported by the other end of the connection and will result in a fall-back to TLS 1.0. [ TLS 1.1 ] TLS 1.1 was defined in RFC 4346 in April 2006. [ Dierks, T. and E. Rescorla The Transport Layer Security (TLS) Protocol Version 1.1, RFC 4346 April 2006 http://tools.ietf.org/html/rfc5246#ref-TLS1.1 ] It is an update from TLS version 1.0. Significant differences in this version include: The implicit Initialization Vector (IV) was replaced with an explicit IV. Change in handling of padding errors. { Support for } { IANA registration of parameters. } [ TLS 1.2 ] TLS 1.2 was defined in RFC 5246 in August 2008. It is based on the earlier TLS 1.1 specification. Major differences include: The MD5 - SHA-1 combination in the pseudorandom function (PRF) was replaced with SHA-2 56, with an option to use cipher-suite specified PRFs. The MD5-SHA-1 combination in the Finished message hash was replaced with SHA-256, with an option to use cipher-suite specific hash algorithms. However the size of the hash in the finished message is still truncated to 96-bits. The MD5-SHA-1 combination in the digitally signed element was replaced with a single hash negotiated during handshake, defaults to SHA-1. Enhancement in the client&apos;s and server&apos;s ability to specify which hash and signature algorithms they will accept. Expansion of support for authenticated encryption ciphers, used mainly for Galois/Counter Mode (GCM) and CCM mode of Advanced Encryption Standard encryption. TLS Extensions definition and Advanced Encryption Standard CipherSuite s were added. TLS 1.2 was further refined in RFC 6176 in March 2011 redacting its backward compatibility with SSL such that TLS sessions will never negotiate the use of Secure Sockets Layer (SSL) version 2.0. [ Applications ] In applications design, TLS is usually implemented on top of any of the Transport Layer protocols, encapsulating the application-specific protocols such as HTTP, FTP, SMTP, NNTP and XMPP. Historically it has been used primarily with reliable transport protocols such as the Transmission Control Protocol (TCP). However, it has also been implemented with datagram-oriented transport protocols, such as the User Datagram Protocol (UDP) and the Datagram Congestion Control Protocol (DCCP), usage which has been standardized independently using the term Datagram Transport Layer Security (DTLS). A prominent use of TLS is for securing World Wide Web traffic carried by HTTP to form HTTPS. Notable applications are electronic commerce and asset management. Increasingly, the Simple Mail Transfer Protocol (SMTP) is also protected by TLS. These applications use public key certificate s to verify the identity of endpoints. TLS can also be used to tunnel an entire network stack to create a VPN, as is the case with OpenVPN. Many vendors now marry TLS&apos;s encryption and authentication capabilities with authorization. There has also been substantial development since the late 1990s in creating client technology outside of the browser to enable support for client/server applications. When compared against traditional IPsec VPN technologies, TLS has some inherent advantages in firewall and NAT traversal that make it easier to administer for large remote-access populations. TLS is also a standard method to protect Session Initiation Protocol (SIP) application signaling. TLS can be used to provide authentication and encryption of the SIP signaling associated with VoIP and other SIP-based applications. [ Security ] TLS has a variety of security measures: Protection against a downgrade of the protocol to a previous (less secure) version or a weaker cipher suite. Numbering subsequent Application records with a sequence number and using this sequence number in the message authentication code s (MACs). Using a message digest enhanced with a key (so only a key-holder can check the MAC). The HMAC construction used by most TLS cipher suites is specified in RFC 2104 (SSL 3.0 used a different hash-based MAC). The message that ends the handshake ( &quot; Finished &quot; ) sends a hash of all the exchanged handshake messages seen by both parties. The pseudorandom function splits the input data in half and processes each one with a different hashing algorithm ( MD5 and SHA-1 ), then XOR s them together to create the MAC. This provides protection even if one of these algorithms is found to be vulnerable. TLS only. SSL 3.0 improved upon SSL 2.0 by adding SHA-1 based ciphers and support for certificate authentication. From a security standpoint, SSL 3.0 should be considered less desirable than TLS 1.0. The SSL 3.0 cipher suites have a weaker key derivation process; half of the master key that is established is fully dependent on the MD5 hash function, which is not resistant to collisions and is, therefore, not considered secure.Under TLS 1.0, the master key that is established depends on both MD5 and SHA-1 so its derivation process is not currently considered weak.It is for this reason that SSL 3.0 implementations cannot be validated under FIPS 140-2. [ National Institute of Standards and Technology Implementation Guidance for FIPS PUB 140-2 and the Cryptographic Module Validation Program December 2010 http://csrc.nist.gov/groups/STM/cmvp/documents/fips140-2/FIPS1402IG.pdf ] A vulnerability of the renegotiation procedure was discovered in August 2009 that can lead to plaintext injection attacks against SSL 3.0 and all current versions of TLS. For example, it allows an attacker who can hijack an https connection to splice their own requests into the beginning of the conversation the client has with the web server. The attacker can&apos;t actually decrypt the client-server communication, so it is different from a typical man-in-the-middle attack. A short-term fix is for web servers to stop allowing renegotiation, which typically will not require other changes unless client certificate authentication is used. To fix the vulnerability, a renegotiation indication extension was proposed for TLS. It will require the client and server to include and verify information about previous handshakes in any renegotiation handshakes. [ Eric Rescorla Understanding the TLS Renegotiation Attack Educated Guesswork 2009-11-27 2009-11-05 http://www.educatedguesswork.org/2009/11/understanding_the_tls_renegoti.html ] This extension has become a proposed standard and has been assigned the number RFC 5746. The RFC has been implemented in recent OpenSSL [ SSL_CTX_set_options SECURE_RENEGOTIATION OpenSSL Docs 2010-11-18 2010-02-25 http://www.openssl.org/docs/ssl/SSL_CTX_set_options.html#SECURE_RENEGOTIATION ] and other libraries. [ GnuTLS 2.10.0 released GnuTLS release notes 2011-07-24 2010-06-25 http://article.gmane.org/gmane.network.gnutls.general/2046 ] [ NSS 3.12.6 release notes NSS release notes 2011-07-24 2010-03-03 https://developer.mozilla.org/NSS_3.12.6_release_notes ] There are some attacks against the implementation rather than the protocol itself: [ Various IE SSL Vulnerability Educated Guesswork 2010-11-17 2002-08-10 http://www.mail-archive.com/bugtraq%40securityfocus.com/msg08807.html ] [ Defeating SSL https://www.blackhat.com/presentations/bh-dc-09/Marlinspike/BlackHat-DC-09-Marlinspike-Defeating-SSL.pdf ] [ Adrian Dimcev SSL/TLS version rollbacks and browsers Random SSL/TLS 101 9 March 2011 ] In the earlier implementations, some CAs did not explicitly set basicConstraints CA=FALSE for leaf nodes. As a result, these leaf nodes could sign rogue certificates. In addition, some early software (including IE6 and Konqueror) did not check this field altogether. This can be exploited for man-in-the-middle attack on all potential SSL connections. Some implementations (including older versions of Microsoft Cryptographic API, Network Security Services and GnuTLS ) stop reading any characters that follow the null character in the name field of the certificate, which can be exploited to fool the client into reading the certificate as if it were one that came from the authentic site, e.g. paypal.com\0.badguy.com would be mistaken as the site of paypal.com rather than badguy.com. Browsers implemented SSL/TLS protocol version fallback mechanisms for compatibility reasons. The protection offered by the SSL/TLS protocols against a downgrade to a previous version by an active MITM attack can be rendered useless by such mechanisms. SSL 2.0 is flawed in a variety of ways: [ November 2010 ] Identical cryptographic keys are used for message authentication and encryption. SSL 2.0 has a weak MAC construction that uses the MD5 hash function with a secret prefix, making it vulnerable to length extension attacks. SSL 2.0 does not have any protection for the handshake, meaning a man-in-the-middle downgrade attack can go undetected. SSL 2.0 uses the TCP connection close to indicate the end of data. This means that truncation attacks are possible: the attacker simply forges a TCP FIN, leaving the recipient unaware of an illegitimate end of data message (SSL 3.0 fixes this problem by having an explicit closure alert). SSL 2.0 assumes a single service and a fixed domain certificate, which clashes with the standard feature of virtual hosting in Web servers. This means that most websites are practically impaired from using SSL. SSL 2.0 is disabled by default, beginning with Internet Explorer 7, [ http://blogs.msdn.com/ie/archive/2005/10/22/483795.aspx IEBlog : Upcoming HTTPS Improvements in Internet Explorer 7 Beta 2 2007-11-25 Lawrence Eric 2005-10-22 MSDN Blogs ] Mozilla Firefox 2, [ https://bugzilla.mozilla.org/show_bug.cgi?id%3D236933 Bugzilla@Mozilla  — Bug 236933 - Disable SSL2 and other weak ciphers 2007-11-25 Mozilla Corporation ] Opera and Safari. After it sends a TLS ClientHello, if Mozilla Firefox finds that the server is unable to complete the handshake, it will attempt to fall back to using SSL 3.0 with an SSL 3.0 ClientHello in SSL 2.0 format to maximize the likelihood of successfully handshaking with older servers. [ https://bugzilla.mozilla.org/show_bug.cgi?id%3D454759 Firefox still sends SSLv2 handshake even though the protocol is disabled 2008-09-11 ] Support for SSL 2.0 (and weak 40-bit and 56-bit ciphers) has been removed completely from Opera as of version 9.5. [ http://my.opera.com/yngve/blog/2007/04/30/10-years-of-ssl-in-opera 10 years of SSL in Opera  — Implementer&apos;s notes 2007-11-25 Pettersen Yngve 2007-04-30 Opera Software ] Modifications to the original protocols, like False Start (adopted and enabled by Google Chrome [ Wolfgang Gruener False Start: Google Proposes Faster Web, Chrome Supports It Already http://www.conceivablytech.com/3299/products/false-start-google-proposes-faster-web-chrome-supports-it-already 9 March 2011 ] ) or Snap Start, have been reported to introduce limited TLS protocol version rollback attacks [ Brian Smith Limited rollback attacks in False Start and Snap Start http://www.ietf.org/mail-archive/web/tls/current/msg06933.html 9 March 2011 ] or to allow modifications to the cipher suite list sent by the client to the server (an attacker may be able to influence the cipher suite selection in an attempt to downgrade the cipher suite strength, to use either a weaker symmetric encryption algorithm or a weaker key exchange [ Adrian Dimcev False Start http://www.carbonwind.net/blog/post/Random-SSLTLS-101-False-Start.aspx Random SSL/TLS 101 9 March 2011 ] ). [ TLS handshake in detail ] The TLS protocol exchanges records, which encapsulate the data to be exchanged. Each record can be compressed, padded, appended with a message authentication code (MAC), or encrypted, all depending on the state of the connection. Each record has a content type field that specifies the record, a length field and a TLS version field. When the connection starts, the record encapsulates another protocol  — the handshake messaging protocol  — which has content type 22. [ Simple TLS handshake ] A simple connection example follows, illustrating a handshake where the server (but not the client) is authenticated by its certificate: A client sends a ClientHello message specifying the highest TLS protocol version it supports, a random number, a list of suggested CipherSuite s and suggested compression methods. If the client is attempting to perform a resumed handshake, it may send a session ID. The server responds with a ServerHello message, containing the chosen protocol version, a random number, CipherSuite and compression method from the choices offered by the client. To confirm or allow resumed handshakes the server may send a session ID. The chosen protocol version should be the highest that both the client and server support. For example, if the client supports TLS1.1 and the server supports TLS1.2, TLS1.1 should be selected; SSL 3.0 should not be selected. The server sends its Certificate message (depending on the selected cipher suite, this may be omitted by the server). These certificates are currently X.509, but there is also a draft specifying the use of OpenPGP based certificates. The server sends a ServerHelloDone message, indicating it is done with handshake negotiation. The client responds with a ClientKeyExchange message, which may contain a PreMasterSecret, public key, or nothing. (Again, this depends on the selected cipher.) This PreMasterSecret is encrypted using the public key of the server certificate. The client and server then use the random numbers and PreMasterSecret to compute a common secret, called the &quot; master secret &quot;. All other key data for this connection is derived from this master secret (and the client- and server-generated random values), which is passed through a carefully designed pseudorandom function. { The client now sends a ChangeCipherSpec record, essentially telling the server, &quot; Everything I tell you from now on will be authenticated (and encrypted if encryption parameters were present in the server certificate). &quot; The ChangeCipherSpec is itself a record-level protocol with content type of 20. } Finally, the client sends an authenticated and encrypted Finished message, containing a hash and MAC over the previous handshake messages. The server will attempt to decrypt the client&apos;s Finished message and verify the hash and MAC. If the decryption or verification fails, the handshake is considered to have failed and the connection should be torn down. { Finally, the server sends a ChangeCipherSpec, telling the client, &quot; Everything I tell you from now on will be authenticated (and encrypted, if encryption was negotiated). &quot; } The server sends its authenticated and encrypted Finished message. The client performs the same decryption and verification. { Application phase: at this point, the &quot; handshake &quot; is complete and the application protocol is enabled, with content type of 23. Application messages exchanged between client and server will also be authenticated and optionally encrypted exactly like in their Finished message. Otherwise, the content type will return 25 and the client will not authenticate. } [ Client-authenticated TLS handshake ] The following full example shows a client being authenticated (in addition to the server like above) via TLS using certificates exchanged between both peers. A client sends a ClientHello message specifying the highest TLS protocol version it supports, a random number, a list of suggested cipher suites and compression methods. The server responds with a ServerHello message, containing the chosen protocol version, a random number, cipher suite and compression method from the choices offered by the client. The server may also send a session id as part of the message to perform a resumed handshake. The server sends its Certificate message (depending on the selected cipher suite, this may be omitted by the server). The server requests a certificate from the client, so that the connection can be mutually authenticated, using a CertificateRequest message. The server sends a ServerHelloDone message, indicating it is done with handshake negotiation. The client responds with a Certificate message, which contains the client&apos;s certificate. The client sends a ClientKeyExchange message, which may contain a PreMasterSecret, public key, or nothing. (Again, this depends on the selected cipher.) This PreMasterSecret is encrypted using the public key of the server certificate. The client sends a CertificateVerify message, which is a signature over the previous handshake messages using the client&apos;s certificate&apos;s private key. This signature can be verified by using the client&apos;s certificate&apos;s public key. This lets the server know that the client has access to the private key of the certificate and thus owns the certificate. The client and server then use the random numbers and PreMasterSecret to compute a common secret, called the &quot; master secret &quot;. All other key data for this connection is derived from this master secret (and the client- and server-generated random values), which is passed through a carefully designed pseudorandom function. { The client now sends a ChangeCipherSpec record, essentially telling the server, &quot; Everything I tell you from now on will be authenticated (and encrypted if encryption was negotiated). &quot; The ChangeCipherSpec is itself a record-level protocol and has type 20 and not 22. } Finally, the client sends an encrypted Finished message, containing a hash and MAC over the previous handshake messages. The server will attempt to decrypt the client&apos;s Finished message and verify the hash and MAC. If the decryption or verification fails, the handshake is considered to have failed and the connection should be torn down. { Finally, the server sends a ChangeCipherSpec, telling the client, &quot; Everything I tell you from now on will be authenticated (and encrypted if encryption was negotiated). &quot; } The server sends its own encrypted Finished message. The client performs the same decryption and verification. { Application phase: at this point, the &quot; handshake &quot; is complete and the application protocol is enabled, with content type of 23. Application messages exchanged between client and server will also be encrypted exactly like in their Finished message. The application will never again return TLS encryption information without a type 32 apology. } [ Resumed TLS handshake ] Public key operations (e.g., RSA) are relatively expensive in terms of computational power. TLS provides a secure shortcut in the handshake mechanism to avoid these operations. In an ordinary full handshake, the server sends a session id as part of the ServerHello message. The client associates this session id with the server&apos;s IP address and TCP port, so that when the client connects again to that server, it can use the session id to shortcut the handshake. In the server, the session id maps to the cryptographic parameters previously negotiated, specifically the &quot; master secret &quot;. Both sides must have the same &quot; master secret &quot; or the resumed handshake will fail (this prevents an eavesdropper from using a session id). The random data in the ClientHello and ServerHello messages virtually guarantee that the generated connection keys will be different than in the previous connection. In the RFCs, this type of handshake is called an abbreviated handshake. It is also described in the literature as a restart handshake. A client sends a ClientHello message specifying the highest TLS protocol version it supports, a random number, a list of suggested cipher suites and compression methods. Included in the message is the session id from the previous TLS connection. The server responds with a ServerHello message, containing the chosen protocol version, a random number, cipher suite and compression method from the choices offered by the client. If the server recognizes the session id sent by the client, it responds with the same session id. The client uses this to recognize that a resumed handshake is being performed. If the server does not recognize the session id sent by the client, it sends a different value for its session id. This tells the client that a resumed handshake will not be performed. At this point, both the client and server have the &quot; master secret &quot; and random data to generate the key data to be used for this connection. { The server now sends a ChangeCipherSpec record, essentially telling the client, &quot; Everything I tell you from now on will be encrypted. &quot; The ChangeCipherSpec is itself a record-level protocol and has type 20 and not 22. } Finally, the server sends an encrypted Finished message, containing a hash and MAC over the previous handshake messages. The client will attempt to decrypt the server&apos;s Finished message and verify the hash and MAC. If the decryption or verification fails, the handshake is considered to have failed and the connection should be torn down. { Finally, the client sends a ChangeCipherSpec, telling the server, &quot; Everything I tell you from now on will be encrypted. &quot; } The client sends its own encrypted Finished message. The server performs the same decryption and verification. { Application phase: at this point, the &quot; handshake &quot; is complete and the application protocol is enabled, with content type of 23. Application messages exchanged between client and server will also be encrypted exactly like in their Finished message. } Apart from the performance benefit, resumed sessions can also be used for single sign-on as it is guaranteed that both the original session as well as any resumed session originate from the same client. This is of particular importance for the FTP over TLS/SSL protocol which would otherwise suffer from a man in the middle attack in which an attacker could intercept the contents of the secondary data connections. [ Chris http://scarybeastsecurity.blogspot.com/2009/02/vsftpd-210-released.html vsftpd-2.1.0 released - Using TLS session resume for FTPS data connection authentication Scarybeastsecurity.blogspot.com 2009-02-18 2012-05-17 ] [ TLS record protocol ] This is the general format of all TLS records. + Byte +0 Byte +1 Byte +2 Byte +3 Byte 0 Content type   Bytes 1..4 Version Length (Major) (Minor) (bits 15..8) (bits 7..0) Bytes 5..(m-1) Protocol message(s) Bytes m..(p&apos;&apos;-1) MAC (optional) Bytes p..(q&apos;&apos;-1) Padding (block ciphers only) Content type This field identifies the Record Layer Protocol Type contained in this Record. Content types Hex Dec Type 0x14 20 ChangeCipherSpec 0x15 21 Alert 0x16 22 Handshake 0x17 23 Application; Version This field identifies the major and minor version of TLS for the contained message. For a ClientHello message, this need not be the highest version supported by the client. Versions Major Version Minor Version Version Type 3 0 SSL 3.0 3 1 TLS 1.0 3 2 TLS 1.1 3 3 TLS 1.2; Length The length of Protocol message(s), not to exceed 2 14 bytes (16 KiB). Protocol message(s) One or more messages identified by the Protocol field. Note that this field may be encrypted depending on the state of the connection. MAC and Padding A message authentication code computed over the Protocol message, with additional key material included. Note that this field may be encrypted, or not included entirely, depending on the state of the connection. No MAC or Padding can be present at end of TLS records before all cipher algorithms and parameters have been negotiated and handshaked and then confirmed by sending a CipherStateChange record (see below) for signalling that these parameters will take effect in all further records sent by the same peer. [ Handshake protocol ] Most messages exchanged during the setup of the TLS session are based on this record, unless an error or warning occurs and needs to be signalled by an Alert protocol record (see below), or the encryption mode of the session is modified by another record (see ChangeCipherSpec protocol below). + Byte +0 Byte +1 Byte +2 Byte +3 Byte 0 22   Bytes 1..4 Version Length (Major) (Minor) (bits 15..8) (bits 7..0) Bytes 5..8 Message type Handshake message data length (bits 23..16) (bits 15..8) (bits 7..0) Bytes 9..(n-1) Handshake message data Bytes n..(n+3) Message type Handshake message data length (bits 23..16) (bits 15..8) (bits 7..0) Bytes (n+4).. Handshake message data Message type This field identifies the Handshake message type. Message Types Code Description 0 HelloRequest 1 ClientHello 2 ServerHello 11 Certificate 12 ServerKeyExchange 13 CertificateRequest 14 ServerHelloDone 15 CertificateVerify 16 ClientKeyExchange 20 Finished; Handshake message data length This is a 3-byte field indicating the length of the handshake data, not including the header. Note that multiple Handshake messages may be combined within one record. [ Alert protocol ] This record should normally not be sent during normal handshaking or application exchanges. However, this message can be sent at any time during the handshake and up to the closure of the session. If this is used to signal a fatal error, the session will be closed immediately after sending this record, so this record is used to give a reason for this closure. If the alert level is flagged as a warning, the remote can decide to close the session if it decides that the session is not reliable enough for its needs (before doing so, the remote may also send its own signal). + Byte +0 Byte +1 Byte +2 Byte +3 Byte 0 21   Bytes 1..4 Version Length (Major) (Minor) 0 2 Bytes 5..6 Level Description   Bytes 7..(p&apos;&apos;-1) MAC (optional) Bytes p..(q&apos;&apos;-1) Padding (block ciphers only) Level This field identifies the level of alert. If the level is fatal, the sender should close the session immediately. Otherwise, the recipient may decide to terminate the session itself, by sending its own fatal alert and closing the session itself immediately after sending it. The use of Alert records is optional, however if it is missing before the session closure, the session may be resumed automatically (with its handshakes). Normal closure of a session after termination of the transported application should preferably be alerted with at least the Close notify Alert type (with a simple warning level) to prevent such automatic resume of a new session. Signalling explicitly the normal closure of a secure session before effectively closing its transport layer is useful to prevent or detect attacks (like attempts to truncate the securely transported data, if it intrinsically does not have a predetermined length or duration that the recipient of the secured data may expect). Alert level types Code Level type Connection state 1 warning connection or security may be unstable. 2 fatal connection or security may be compromised, or an unrecoverable error has occurred.; Description This field identifies which type of alert is being sent. Alert description types Code Description Level types Note 0 Close notify warning / fatal 10 Unexpected message fatal 20 Bad record MAC fatal Possibly a bad SSL implementation, or payload has been tampered with e.g. FTP firewall rule on FTPS server. 21 Decryption failed fatal TLS only, reserved 22 Record overflow fatal TLS only 30 Decompression failure fatal 40 Handshake failure fatal 41 No certificate warning / fatal SSL 3.0 only, reserved 42 Bad certificate warning / fatal 43 Unsupported certificate warning / fatal E.g. certificate has only Server authentication usage enabled and is presented as a client certificate 44 Certificate revoked warning / fatal 45 Certificate expired warning / fatal || Check server certificate expire also check no certificate in the chain presented has expired 46 Certificate unknown warning / fatal 47 Illegal parameter fatal 48 Unknown CA ( Certificate authority ) fatal TLS only 49 Access denied fatal TLS only - E.g. no client certificate has been presented (TLS: Blank certificate message or SSLv3: No Certificate alert), but server is configured to require one. 50 Decode error fatal TLS only 51 Decrypt error warning / fatal TLS only 60 Export restriction fatal TLS only, reserved 70 Protocol version fatal TLS only 71 Insufficient security fatal TLS only 80 Internal error fatal TLS only 90 User cancelled fatal TLS only 100 No renegotiation warning TLS only 110 Unsupported extension warning TLS only 111 Certificate unobtainable warning TLS only 112 Unrecognized name warning TLS only; client&apos;s Server Name Indicator specified a hostname not supported by the server 113 Bad certificate status response fatal TLS only 114 Bad certificate hash value fatal TLS only 115 Unknown PSK identity (used in TLS-PSK and TLS-SRP ) fatal TLS only ===ChangeCipherSpec protocol=== + Byte +0 Byte +1 Byte +2 Byte +3 Byte 0 20   Bytes 1..4 Version Length (Major) (Minor) 0 1 Byte 5 CCS protocol type   CCS protocol type Currently only 1. [ Application protocol ] + Byte +0 Byte +1 Byte +2 Byte +3 Byte 0 23   Bytes 1..4 Version Length (Major) (Minor) (bits 15..8) (bits 7..0) Bytes 5..(m-1) Application data Bytes m..(p&apos;&apos;-1) MAC (optional) Bytes p..(q&apos;&apos;-1) Padding (block ciphers only) Length Length of Application data (excluding the protocol header and including the MAC and padding trailers) MAC 20 bytes for the SHA-1 -based HMAC, 16 bytes for the MD5 -based HMAC. Padding Variable length; last byte contains the padding length. [ Support for name-based virtual servers ] From the application protocol point of view, TLS belongs to a lower layer, although theTCP/IP model is too coarse to show it. This means that the TLS handshake is usually(except in the STARTTLS case) performed before the application protocol can start.The name-based virtual server feature being provided by theapplication layer, all co-hosted virtual servers share the same certificate becausethe server has to select and send a certificate immediately after the ClientHello message.This is a big problem in hosting environments because it means either sharing thesame certificate among all customers or using a different IP address for each of them. There are two known workarounds provided by X.509 : [ https://www.switch.ch/pki/meetings/2007-01/namebased_ssl_virtualhosts.pdf Named-based SSL virtual hosts: how to tackle the problem PDF 2012-05-17 ] If all virtual servers belong to the same domain, a wildcard certificate can be used. Besides the loose host name selection that might be a problem or not, there is no common agreement about how to match wildcard certificates. Different rules are applied depending on the application protocol or software used. Add every virtual host name in the subjectAltName extension. The major problem being that the certificate needs to be reissued whenever a new virtual server is added. In order to provide the server name, RFC 4366 Transport Layer Security (TLS) Extensions allow clients to include a Server Name Indication extension (SNI) in the extended ClientHello message.This extension hints the server immediately which name the client wishes to connect to, so the servercan select the appropriate certificate to send to the client. [ Implementations ] SSL and TLS have been widely implemented in several free and open source software projects. Programmers may use the PolarSSL, CyaSSL, OpenSSL, NSS, or GnuTLS libraries for SSL/TLS functionality. Microsoft Windows includes an implementation of SSL and TLS as part of its Secure Channel package. Delphi programmers may use a library called Indy. Comparison of TLS Implementations provides a brief comparison of features of different implementations. [ Browser implementations ] All the most recent web browsers support TLS: [ Apple http://www.apple.com/safari/features.html Features 2009-06-10 2009-06-10 ] [ Adrian Dimcev Common browsers/libraries/servers and the associated cipher suites implemented http://www.carbonwind.net/TLS_Cipher_Suites_Project/tls_ssl_cipher_suites_annex_a1_main.docx TLS Cipher Suites Project ] [ Mozilla https://developer.mozilla.org/en/Security_in_Firefox_2 Security in Firefox 2 2008-08-06/ 2009-03-31 ] [ January 2012 ] [ https://bugzilla.mozilla.org/show_bug.cgi?id%3D480514 Bug 480514 - Implement support for TLS 1.2 (RFC 5246) 2010-03-17 2010-04-04 ] [ Microsoft http://msdn.microsoft.com/en-us/library/dd208005%28PROT.13%29.aspx MS-TLSP Appendix A 2009-02-27 2009-03-19 ] [ Yngve Nysæter Pettersen http://my.opera.com/core/blog/2009/02/25/new-in-opera-presto-2-2-tls-1-2-support New in Opera Presto 2.2: TLS 1.2 Support 2009-02-25 2009-02-25 ] [ Google http://googlechromereleases.blogspot.nl/2012/05/dev-channel-update_29.html Dev Channel Update 2012-05-29 2011-06-01 ] [ Chromium Project http://code.google.com/p/chromium/issues/detail?id%3D90392 No TLS 1.2 (SHA-2) Support 2011-07-25 2011-06-01 ] Apple&apos;s Safari supports TLS, but it’s not officially specified which version. On operating systems (Safari uses the TLS implementation of the underlying OS) like Mac OS X 10.5.8, Mac OS X 10.6.6, Windows XP, Windows Vista or Windows 7, Safari 5 has been reported to support TLS 1.0. Mozilla Firefox, versions 2 and above, support TLS 1.0. Firefox does not support TLS 1.1 or 1.2. Microsoft Internet Explorer always uses the TLS implementation of the underlying Microsoft Windows Operating System, a service called SChannel Security Service Provider. Internet Explorer 8 in Windows 7 and Windows Server 2008 R2 supports TLS 1.2. Windows 7 and Windows Server 2008 R2 use the same code (Microsoft Windows Version 6.1 (build 7600)) similar to how Windows Vista SP1 uses the same code as Windows 2008 Server. As of Presto 2.2, featured in Opera 10, Opera supports TLS 1.2. Google&apos;s Chrome browser supports TLS 1.0, and TLS 1.1 from version 21 and higher. There is no support for TLS 1.2 yet. [ Standards ] The current approved version of TLS is version 1.2, which is specified in: RFC 5246: “The Transport Layer Security (TLS) Protocol Version 1.2”. The current standard replaces these former versions, which are now considered obsolete: RFC 2246: “The TLS Protocol Version 1.0”. RFC 4346: “The Transport Layer Security (TLS) Protocol Version 1.1”. as well as the never standardized SSL 3.0: RFC 6101: “The Secure Sockets Layer (SSL) Protocol Version 3.0”. Other RFC s subsequently extended TLS. Extensions to TLS 1.0 include: RFC 2595: “Using TLS with IMAP, POP3 and ACAP”. Specifies an extension to the IMAP, POP3 and ACAP services that allow the server and client to use transport-layer security to provide private, authenticated communication over the Internet. RFC 2712: “Addition of Kerberos Cipher Suites to Transport Layer Security (TLS)”. The 40-bit cipher suites defined in this memo appear only for the purpose of documenting the fact that those cipher suite codes have already been assigned. RFC 2817: “Upgrading to TLS Within HTTP/1.1”, explains how to use the Upgrade mechanism in HTTP/1.1 to initiate Transport Layer Security (TLS) over an existing TCP connection. This allows unsecured and secured HTTP traffic to share the same well known port (in this case, http: at 80 rather than https: at 443). RFC 2818: “HTTP Over TLS”, distinguishes secured traffic from insecure traffic by the use of a different &apos;server port&apos;. RFC 3207: “SMTP Service Extension for Secure SMTP over Transport Layer Security”. Specifies an extension to the SMTP service that allows an SMTP server and client to use transport-layer security to provide private, authenticated communication over the Internet. RFC 3268: “AES Ciphersuites for TLS”. Adds Advanced Encryption Standard (AES) cipher suites to the previously existing symmetric ciphers. RFC 3546: “Transport Layer Security (TLS) Extensions”, adds a mechanism for negotiating protocol extensions during session initialisation and defines some extensions. Made obsolete by RFC 4366. RFC 3749: “Transport Layer Security Protocol Compression Methods”, specifies the framework for compression methods and the DEFLATE compression method. RFC 3943: “Transport Layer Security (TLS) Protocol Compression Using Lempel-Ziv-Stac (LZS)”. RFC 4132: “Addition of Camellia Cipher Suites to Transport Layer Security (TLS)”. RFC 4162: “Addition of SEED Cipher Suites to Transport Layer Security (TLS)”. RFC 4217: “Securing FTP with TLS ”. RFC 4279: “Pre-Shared Key Ciphersuites for Transport Layer Security (TLS)”, adds three sets of new cipher suites for the TLS protocol to support authentication based on pre-shared keys. Extensions to TLS 1.1 include: RFC 4347: “ Datagram Transport Layer Security ” specifies a TLS variant that works over datagram protocols (such as UDP). RFC 4366: “Transport Layer Security (TLS) Extensions” describes both a set of specific extensions and a generic extension mechanism. RFC 4492: “ Elliptic Curve Cryptography (ECC) Cipher Suites for Transport Layer Security (TLS)”. RFC 4507: “Transport Layer Security (TLS) Session Resumption without Server-Side State”. RFC 4680: “TLS Handshake Message for Supplemental Data”. RFC 4681: “TLS User Mapping Extension”. RFC 4785: “Pre-Shared Key (PSK) Ciphersuites with NULL Encryption for Transport Layer Security (TLS)”. RFC 5054: “Using the Secure Remote Password (SRP) Protocol for TLS Authentication”. Defines the TLS-SRP ciphersuites. RFC 5081: “Using OpenPGP Keys for Transport Layer Security (TLS) Authentication”, obsoleted by RFC 6091. Extensions to TLS 1.2 include: RFC 5746: “Transport Layer Security (TLS) Renegotiation Indication Extension”. RFC 5878: “Transport Layer Security (TLS) Authorization Extensions”. RFC 6091: “Using OpenPGP Keys for Transport Layer Security (TLS) Authentication“. RFC 6176: “Prohibiting Secure Sockets Layer (SSL) Version 2.0”. RFC 6209: “Addition of the ARIA Cipher Suites to Transport Layer Security (TLS)”. [ See also ] [ Cryptography ] Multiplexed Transport Layer Security Extended Validation Certificate SSL acceleration Obfuscated TCP Server gated cryptography tcpcrypt Transport Layer Security - Origin Bound Certificates - A proposed protocol extension that improves web browser security via self-signed browser certificates [ Software ] OpenSSL : a free implementation (BSD license with some extensions) GnuTLS : a free implementation (LGPL licensed) cryptlib : a portable open source cryptography library (includes TLS/SSL implementation) JSSE : a Java implementation included in the Java Runtime Environment Network Security Services (NSS): FIPS 140 validated open source library PolarSSL : A tiny SSL/TLS implementation for embedded devices that is designed for ease of use. CyaSSL : Embedded SSL/TLS Library with a strong focus on speed and size. [ References and footnotes ] [ 30em ] [ Further reading ] [ David Wagner Schneier, Bruce Analysis of the SSL 3.0 Protocol The Second USENIX Workshop on Electronic Commerce Proceedings USENIX Press November 1996 29–40 http://www.schneier.com/paper-ssl.pdf ] [ Eric Rescorla SSL and TLS: Designing and Building Secure Systems Addison-Wesley Pub Co United States 2001 0-201-61598-3 ] [ Joshua Davies Implementing SSL/TLS Using Cryptography and PKI Wiley New York 2011 978-0-470-92041-1 ] [ Stephen A. Thomas SSL and TLS essentials securing the Web Wiley New York 2000 0-471-38354-6 ] [ A Challenging But Feasible Blockwise-Adaptive Chosen-Plaintext Attack On Ssl International Association for Cryptologic Research 2006 Gregory Bard 136 http://eprint.iacr.org/2006/136 2011-09-23 ] [ http://lasecwww.epfl.ch/memo/memo_ssl.shtml Password Interception in a SSL/TLS Channel 2007-04-20 Canvel Brice ] [ http://tools.ietf.org/html/rfc5746 RFC of change for TLS Renegotiation 2009-12-11 IETF Multiple Authors ] Creating VPNs with IPsec and SSL/TLS Linux Journal article by Rami Rosen [ External links ] [ SSL and TLS ] SSL 2 specification (published 1994) Early drafts of SSL 3.0 specification (published 1995) The Secure Sockets Layer (SSL) Protocol Version 3.0 (2011) The IETF (Internet Engineering Task Force) TLS Workgroup SSL tutorial ECMAScript Secure Transform (Web 2 Secure Transform Method) OWASP: Transport Layer Protection Cheat Sheet A talk on SSL/TLS that tries to explain things in terms that people might understand. SSL: Foundation for Web Security Category:Cryptographic protocols Category:Internet standards Category:Internet protocols Category:Electronic commerce Category:Secure communication Category:Application layer protocols bg:TLS ca:Transport Layer Security cs:Transport Layer Security da:Transport Layer Security de:Transport Layer Security et:Transpordikihi turbeprotokoll el:TLS es:Transport Layer Security eu:Transport Layer Security fa:امنیت لایه انتقال fr:Transport Layer Security ko:트랜스포트 레이어 보안 hr:TLS id:Transport Layer Security it:Transport Layer Security lv:Transport Layer Security lt:Transport Layer Security nl:Secure Sockets Layer ja:Transport Layer Security no:Transport Layer Security nn:Transport Layer Security pl:Transport Layer Security pt:Transport Layer Security ro:Securitatea nivelului de transport ru:TLS simple:Transport Layer Security sk:Transport Layer Security fi:TLS sv:Transport Layer Security th:Transport Layer Security uk:Transport Layer Security yo:Transport Layer Security zh:传输层安全