[ November 2007 ] In computing, just-in-time compilation (JIT), also known as dynamic translation, is a method to improve the runtime performance of computer program s. Historically, computer programs had two modes of runtime operation, either interpreted or static ( ahead-of-time ) compilation. Interpreted code is translated from a high-level language to a machine code continuously during every execution, whereas statically compiled code is translated into machine code before execution, and only requires this translation once. JIT compilers represent a hybrid approach, with translation occurring continuously, as with interpreters, but with caching of translated code to minimize performance degradation. It also offers other advantages over statically compiled code at development time, such as handling of late-bound data types and the ability to enforce security guarantees. JIT builds upon two earlier ideas in run-time environments: bytecode compilation and dynamic compilation. It converts code at runtime prior to executing it natively, for example bytecode into native machine code. Several modern runtime environments, such as Microsoft &apos;s.NET Framework and most implementations of Java, rely on JIT compilation for high-speed code execution. [ Overview ] In a bytecode-compiled system, source code is translated to an intermediate representation known as bytecode. Bytecode is not the machine code for any particular computer, and may be portable among computer architectures. The bytecode may then be interpreted by, or run on, a virtual machine. The JIT compiler reads the bytecodes in many sections (or in full, rarely) and compiles them dynamically into machine language so the program can run faster. Java performs runtime checks on various sections of the code and this is the reason the entire code is not compiled at once. [ Kogent Solution Inc. Java 6 Programming Black Book, New Ed 2007 Dreamtech Press 5 978-81-7722-736-9 http://books.google.com/books?id%3DSSyuJa04uv8C ] This can be done per-file, per-function or even on any arbitrary code fragment; the code can be compiled when it is about to be executed (hence the name &quot; just-in-time &quot; ), and then cached and reused later without needing to be recompiled. In contrast, a traditional interpreted virtual machine will simply interpret the bytecode, generally with much lower performance. Some interpreters even interpret source code, without the step of first compiling to bytecode, with even worse performance. Statically compiled code or native code is compiled prior to deployment. A dynamic compilation environment is one in which the compiler can be used during execution. For instance, most Common Lisp systems have a compile function which can compile new functions created during the run. This provides many of the advantages of JIT, but the programmer, rather than the runtime, is in control of what parts of the code are compiled. This can also compile dynamically generated code, which can, in many scenarios, provide substantial performance advantages over statically compiled code [ September 2011 ], as well as over most JIT systems. A common goal of using JIT techniques is to reach or surpass the performance of static compilation, while maintaining the advantages of bytecode interpretation: Much of the &quot; heavy lifting &quot; of parsing the original source code and performing basic optimization is often handled at compile time, prior to deployment: compilation from bytecode to machine code is much faster than compiling from source. The deployed bytecode is portable, unlike native code. Since the runtime has control over the compilation, like interpreted bytecode, it can run in a secure sandbox. Compilers from bytecode to machine code are easier to write, because the portable bytecode compiler has already done much of the work. JIT code generally offers far better performance than interpreters. In addition, it can in some cases offer better performance than static compilation, as many optimizations are only feasible at run-time: The compilation can be optimized to the targeted CPU and the operating system model where the application runs. For example JIT can choose SSE2 CPU instructions when it detects that the CPU supports them. To obtain this level of optimization specificity with a static compiler, one must either compile a binary for each intended platform/architecture, or else include multiple versions of portions of the code within a single binary. The system is able to collect statistics about how the program is actually running in the environment it is in, and it can rearrange and recompile for optimum performance. However, some static compilers can also take profile information as input. The system can do global code optimizations (e.g. inlining of library functions) without losing the advantages of dynamic linking and without the overheads inherent to static compilers and linkers. Specifically, when doing global inline substitutions, a static compilation process may need run-time checks and ensure that a virtual call would occur if the actual class of the object overrides the inlined method, and boundary condition checks on array accesses may need to be processed within loops. With just-in-time compilation in many cases this processing can be moved out of loops, often giving large increases of speed. Although this is possible with statically compiled garbage collected languages, a bytecode system can more easily rearrange executed code for better cache utilization. [ Startup delay and optimizations ] JIT typically causes a slight delay in initial execution of an application, due to the time taken to load and compile the bytecode. Sometimes this delay is called &quot; startup time delay &quot;. In general, the more optimization JIT performs, the better the code it will generate, but the initial delay will also increase. A JIT compiler therefore has to make a trade-off between the compilation time and the quality of the code it hopes to generate. However, it seems that much of the startup time is sometimes due to IO-bound operations rather than JIT compilation (for example, the rt.jar class data file for the Java Virtual Machine is 40 MB and the JVM must seek a lot of data in this contextually huge file). [ http://java.sun.com/developer/technicalArticles/javase/consumerjre#Quickstarter Consumer JRE: Leaner, Meaner Java Technology Sun Microsystems Haase Chet At the OS level, all of these megabytes have to be read from disk, which is a very slow operation. Actually, it&apos;s the seek time of the disk that&apos;s the killer; reading large files sequentially is relatively fast, but seeking the bits that we actually need is not. So even though we only need a small fraction of the data in these large files for any particular application, the fact that we&apos;re seeking all over within the files means that there is plenty of disk activity. May 2007 2007-07-27 ] One possible optimization, used by Sun&apos;s HotSpot Java Virtual Machine, is to combine interpretation and JIT compilation. The application code is initially interpreted, but the JVM monitors which sequences of bytecode are frequently executed and translates them to machine code for direct execution on the hardware. For bytecode which is executed only a few times, this saves the compilation time and reduces the initial latency; for frequently executed bytecode, JIT compilation is used to run at high speed, after an initial phase of slow interpretation. Additionally, since a program spends most time executing a minority of its code, the reduced compilation time is significant. Finally, during the initial code interpretation, execution statistics can be collected before compilation, which helps to perform better optimization. { The Java HotSpot Performance Engine Architecture } The correct tradeoff can vary due to circumstances. For example, Sun&apos;s Java Virtual Machine has two major modes—client and server. In client mode, minimal compilation and optimization is performed, to reduce startup time. In server mode, extensive compilation and optimization is performed, to maximize performance once the application is running by sacrificing startup time. Other Java just-in-time compilers have used a runtime measurement of the number of times a method has executed combined with the bytecode size of a method as a heuristic to decide when to compile. [ The simplest heuristics may be the best in Java JIT compilers Schilling Jonathan L. SIGPLAN Notices 38 2 February 2003 36–46 10.1145/772970.772975 ] Still another uses the number of times executed combined with the detection of loops. { Toshio Suganuma, Toshiaki Yasue, Motohiro Kawahito, Hideaki Komatsu, Toshio Nakatani, &quot; A dynamic optimization framework for a Java just-in-time compiler &quot;, Proceedings of the 16th ACM SIGPLAN conference on Object-oriented programming, systems, languages, and applications (OOPSLA &apos;01), pp. 180–195, October 14–18, 2001. } In general, it is much harder to accurately predict which methods to optimize in short-running applications than in long-running ones. { Matthew Arnold, Michael Hind, Barbara G. Ryder, &quot; An Empirical Study of Selective Optimization &quot;, Proceedings of the 13th International Workshop on Languages and Compilers for Parallel Computing-Revised Papers, pp. 49–67, August 10–12, 2000. } Native Image Generator (Ngen) by Microsoft is another approach at reducing the initial delay. { http://msdn2.microsoft.com/en-us/library/6t9t5wcf(VS.80).aspx } Ngen pre-compiles (or &quot; pre-jits &quot; ) bytecode in a Common Intermediate Language image into machine native code. As a result, no runtime compilation is needed..NET framework 2.0 shipped with Visual Studio 2005 runs Ngen on all of the Microsoft library DLLs right after the installation. Pre-jitting provides a way to improve the startup time. However, the quality of code it generates might not be as good as the one that is jitted, for the same reasons why code compiled statically, without profile-guided optimization, cannot be as good as JIT compiled code in the extreme case: the lack of profiling data to drive, for instance, inline caching. { Matthew R. Arnold, Stephen Fink, David P. Grove, Michael Hind, and Peter F. Sweeney, &quot; A Survey of Adaptive Optimization in Virtual Machines &quot;, Proceedings of the IEEE, 92(2), February 2005, pp. 449–466. } There also exist Java implementations that combine an AOT (ahead-of-time) compiler with either a JIT compiler ( Excelsior JET ) or interpreter ( GNU Compiler for Java.) [ History ] The earliest published JIT compiler is generally attributed to work on LISP by McCarthy in 1960. [ Aycock J. A brief history of just-in-time ACM Computing Surveys 2003 June 35 2 97–113 10.1145/857076.857077 http://citeseerx.ist.psu.edu/viewdoc/download?doi%3D10.1.1.97.3985%26amp%3Brep%3Drep1%26amp%3Btype%3Dpdf 2010-05-24 ] In his seminal paper Recursive functions of symbolic expressions and their computation by machine, Part I, he mentions functions that are translated during runtime, thereby sparing the need to save the compiler output to punch card s. [ McCarthy J. Recursive functions of symbolic expressions and their computation by machine, Part I Communications of the ACM 1960 April 3 4 184–195 10.1145/367177.367199 http://citeseerx.ist.psu.edu/viewdoc/download?doi%3D10.1.1.111.8833%26amp%3Brep%3Drep1%26amp%3Btype%3Dpdf 24 May 2010 ] An influential technique for deriving compiled code from interpretation was pioneered by Mitchell in 1970, which he implemented for the experimental language LC². Smalltalk pioneered new aspects of JIT compilations. For example, translation to machine code was done on demand, and the result was cached for later use. When memory became scarce, the system would delete some of this code and regenerate it when it was needed again. { http://webpages.charter.net/allanms/popl84.pdf } { 0-89791-125-3 } Sun&apos;s Self language improved these techniques extensively and was at one point the fastest Smalltalk system in the world; achieving up to half the speed of optimized C { http://research.sun.com/jtech/pubs/97-pep.ps } but with a fully object-oriented language. Self was abandoned by Sun, but the research went into the Java language, and currently it is used by most implementations of the Java Virtual Machine, as HotSpot builds on, and extensively uses, this research base. The HP project Dynamo was an experimental JIT compiler where the &apos;bytecode&apos; format and the machine code format were the same; the system turned HPA-8000 machine code into HPA-8000 machine code. Counterintuitively, this resulted in speed ups, in some cases of 30% since doing this permitted optimizations at the machine code level, for example, inlining code for better cache usage and optimizations of calls to dynamic libraries and many other run-time optimizations which conventional compilers are not able to attempt. { Ars Technica on HP&apos;s Dynamo } [ See also ] [ Java ] Binary translation HotSpot Common Language Runtime Crusoe, a microprocessor that essentially performs just-in-time compilation from x86 code to microcode within the microprocessor GNU lightning — A library that generates assembly language code at run-time LLVM Self-modifying code Tracing just-in-time compilation [ References ] Free Online Dictionary of Computing entry [ 2 ] [ External links ] [ libjit libJIT ] — A library by Rhys Weatherley, Klaus Treichel, Aleksey Demakov, and Kirill Kononenko for development of Just-In-Time compilers in Virtual Machine implementations, Dynamic programming languages and Scripting languages. Mozilla Nanojit — A small, cross-platform C++ library that emits machine code. It is used as the JIT for the Mozilla Tamarin and SpiderMonkey Javascript engines. SoftWire — A library by Nicolas Capens that generates assembly language code at run-time ( thesis ) CCG by Ian Piumarta Dyninst JatoVM, a Java JIT-only VM AsmJit — Complete x86/x64 jit assembler library for C++ language by Petr Kobalíček Xbyak — A x86/x64 JIT assembler for C++ language by Herumi Profiling Runtime Generated and Interpreted Code using the VTune Performance Analyzer Category:Compiler construction Category:Virtual machines ar:ترجمة في الوقت المناسب cs:JIT de:Just-in-time-Kompilierung es:Compilación en tiempo de ejecución fr:Compilation à la volée ko:JIT 컴파일 it:Compilatore just-in-time hu:Futásidejű fordítás nl:Just in time compilatie ja:実行時コンパイラ pl:JIT (informatyka) pt:JIT ru:JIT-компиляция fi:Ajonaikainen kääntäminen sv:JIT-kompilator uk:JIT zh:即時編譯