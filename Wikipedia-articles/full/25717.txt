In computing, a regular expression provides a concise and flexible means to &quot; match &quot; (specify and recognize) strings of text, such as particular characters, words, or patterns of characters. Common abbreviations for &quot; regular expression &quot; include regex and regexp. The concept of regular expressions was first popularized by utilities provided by Unix distributions, in particular the editor ed and the filter grep. [ September 2011 ] A regular expression is written in a formal language that can be interpreted by a regular expression processor, which is a program that either serves as a parser generator or examines text and identifies parts that match the provided specification. Historically, the concept of regular expressions is associated with Kleene&apos;s formalism of regular set s, introduced in the 1950s. The following are examples of specifications which can be expressed as a regular expression: the sequence of characters &quot; car &quot; appearing consecutively, such as in &quot; car &quot;, &quot; cartoon &quot;, or &quot; bicarbonate &quot; the word &quot; car &quot; when it appears as an isolated word (and delimited from other words, typically through whitespace characters ) the word &quot; car &quot; when preceded by the word &quot; motor &quot; (and separated by a named delimiter, or multiple.) Regular expressions are used by many text editor s, utilities, and programming language s to search and manipulate text based on pattern s. Some of these languages, including Perl, Ruby, AWK, and Tcl, integrate regular expressions into the syntax of the core language itself. Other programming languages like.NET languages, Java, and Python instead provide regular expressions through standard libraries. For yet other languages, such as Object Pascal (Delphi) and C and C++, non-core libraries are available (however, version C++11 provides regular expressions in its Standard Libraries). As an example of the syntax, the regular expression \bex can be used to search for all instances of the string &quot; ex &quot; occurring after &quot; word boundaries &quot;. Thus \bex will find the matching string &quot; ex &quot; in two possible locations, (1) at the beginning of words, and (2) between two characters in a string, where the first is not a word character and the second is a word character. For instance, in the string &quot; Texts for experts &quot;, \bex matches the &quot; ex &quot; in &quot; experts &quot; but not in &quot; Texts &quot; (because the &quot; ex &quot; occurs inside a word and not immediately after a word boundary). Many modern computing systems provide wildcard character s in matching filename s from a file system. This is a core capability of many command-line shells and is also known as globbing. Wildcards differ from regular expressions in generally expressing only limited forms of patterns. [ Basic concepts ] A regular expression, often called a pattern, is an expression that specifies a set of strings. To specify such sets of strings, rules are often more concise than lists of a set&apos;s members. For example, the set containing the three strings &quot; Handel &quot;, &quot; Händel &quot;, and &quot; Haendel &quot; can be specified by the pattern H(ä|ae?)ndel (or alternatively, it is said that the pattern matches each of the three strings). In most formalism s, if there exists at least one regex that matches a particular set then there exist an infinite number of such expressions. Most formalisms provide the following operations to construct regular expressions. Boolean &quot; or &quot; A vertical bar separates alternatives. For example, gray|grey can match &quot; gray &quot; or &quot; grey &quot;. Grouping Parentheses are used to define the scope and precedence of the operators (among other uses). For example, gray|grey and gr(a|e)y are equivalent patterns which both describe the set of &quot; gray &quot; and &quot; grey &quot;. Quantification { (derived from the } { Kleene star ), and the } { plus sign + (Kleene cross). } ? The question mark indicates there is zero or one of the preceding element. For example, colou?r matches both &quot; color &quot; and &quot; colour &quot;. * The asterisk indicates there is zero or more of the preceding element. For example, ab*c matches &quot; ac &quot;, &quot; abc &quot;, &quot; abbc &quot;, &quot; abbbc &quot;, and so on. + The plus sign indicates there is one or more of the preceding element. For example, ab+c matches &quot; abc &quot;, &quot; abbc &quot;, &quot; abbbc &quot;, and so on, but not &quot; ac &quot;. { These constructions can be combined to form arbitrarily complex expressions, much like one can construct arithmetical expressions from numbers and the operations +, −, ×, and ÷. For example, H(ae?|ä)ndel and H(a|ae|ä)ndel are both valid patterns which match the same strings as the earlier example, H(ä|ae?)ndel. } The precise syntax for regular expressions varies among tools and with context; more detail is given in the &apos;&apos;Syntax&apos;&apos; section. [ History ] [ Pattern matching#History ] The origins of regular expressions lie in automata theory and formal language theory, both of which are part of theoretical computer science. These fields study models of computation (automata) and ways to describe and classify formal languages. In the 1950s, mathematician Stephen Cole Kleene described these models using his mathematical notation called regular sets. [ Kleene 1956 ] The SNOBOL language was an early implementation of pattern matching, but not identical to regular expressions. Ken Thompson built Kleene&apos;s notation into the editor QED as a means to match patterns in text file s. He later added this capability to the Unix editor ed, which eventually led to the popular search tool grep &apos;s use of regular expressions ( &quot; grep &quot; is a word derived from the command for regular expression searching in the ed editor: g/re/p where re stands for regular expression [ http://catb.org/jargon/html/G/grep.html Jargon File 4.4.7: grep Raymond, Eric S. citing Dennis Ritchie 2003 ] ). Since that time, many variations of Thompson&apos;s original adaptation of regular expressions have been widely used in Unix and Unix-like utilities including expr, AWK, Emacs, vi, and lex. Perl and Tcl regular expressions were derived from a regex library written by Henry Spencer, though Perl later expanded on Spencer&apos;s library to add many new features. [ http://perldoc.perl.org/perlre.html perlre: Perl regular expressions Wall, Larry and the Perl 5 development team 2006 ] Philip Hazel developed PCRE (Perl Compatible Regular Expressions), which attempts to closely mimic Perl&apos;s regular expression functionality and is used by many modern tools including PHP and Apache HTTP Server. Part of the effort in the design of Perl 6 is to improve Perl&apos;s regular expression integration, and to increase their scope and capabilities to allow the definition of parsing expression grammar s. [ Wall 2002 ] The result is a mini-language called Perl 6 rules, which are used to define Perl 6 grammar as well as provide a tool to programmers in the language. These rules maintain existing features of Perl 5.x regular expressions, but also allow BNF -style definition of a recursive descent parser via sub-rules. The use of regular expressions in structured information standards for document and database modeling started in the 1960s and expanded in the 1980s when industry standards like ISO SGML (precursored by ANSI &quot; GCA 101-1983 &quot; ) consolidated. The kernel of the structure specification language standards consists of regular expressions. Its use is evident in the DTD element group syntax. [ Formal language theory ] Regular expressions describe regular language s in formal language theory. They have the same expressive power as regular grammar s. [ Formal definition ] Regular expressions consist of constants and operator symbols that denote sets of strings and operations over these sets, respectively. The following definition is standard, and found as such in most textbooks on formal language theory. [ Hopcroft Motwani Ullman 2000 ] [ Sipser 1998 ] Given a finite alphabet Σ, the following constants are definedas regular expressions: [ ∅ ] [ ∅ ] (empty set) denoting the set. ( empty string ) ε denoting the set containing only the &quot; empty &quot; string, which has no characters at all. ( literal character ) a in Σ denoting the set containing only the character a. Given regular expressions R and S, the following operations over them are definedto produce regular expressions: (concatenation) RS denoting the set { αβ | α in set described by expression R and β in set described by S }. For example { &quot; ab &quot;, &quot; c &quot; }{ &quot; d &quot;, &quot; ef &quot; } = { &quot; abd &quot;, &quot; abef &quot;, &quot; cd &quot;, &quot; cef &quot; }. (alternation) R | S denoting the set union of sets described by R and S. For example, if R describes { &quot; ab &quot;, &quot; c &quot; } and S describes { &quot; ab &quot;, &quot; d &quot;, &quot; ef &quot; }, expression R | S describes { &quot; ab &quot;, &quot; c &quot;, &quot; d &quot;, &quot; ef &quot; }. ( Kleene star ) R* denoting the smallest superset of set described by R that contains ε and is closed under string concatenation. This is the set of all strings that can be made by concatenating any finite number (including zero) of strings from set described by R. For example, { &quot; 0 &quot;, &quot; 1 &quot; }* is the set of all finite binary string s (including the empty string), and { &quot; ab &quot;, &quot; c &quot; }* = {ε, &quot; ab &quot;, &quot; c &quot;, &quot; abab &quot;, &quot; abc &quot;, &quot; cab &quot;, &quot; cc &quot;, &quot; ababab &quot;, &quot; abcab &quot;,... }. To avoid parentheses it is assumed that the Kleene star has the highest priority, then concatenation and then set union. If there is no ambiguity then parentheses may be omitted. For example, (ab)c can be written as abc, and a|(b(c*)) can be written as a|bc*.Many textbooks use the symbols [ ∪ ], [ + ], or [ ∨ ] for alternation instead of the vertical bar. Examples: a|b* denotes {ε, &quot; a &quot;, &quot; b &quot;, &quot; bb &quot;, &quot; bbb &quot;,...} (a|b)* denotes the set of all strings with no symbols other than &quot; a &quot; and &quot; b &quot;, including the empty string: {ε, &quot; a &quot;, &quot; b &quot;, &quot; aa &quot;, &quot; ab &quot;, &quot; ba &quot;, &quot; bb &quot;, &quot; aaa &quot;,...} ab*(c|ε) denotes the set of strings starting with &quot; a &quot;, then zero or more &quot; b &quot; s and finally optionally a &quot; c &quot; : { &quot; a &quot;, &quot; ac &quot;, &quot; ab &quot;, &quot; abc &quot;, &quot; abb &quot;, &quot; abbc &quot;,...} [ Expressive power and compactness ] The formal definition of regular expressions is purposely parsimonious and avoids defining the redundant quantifiers ? and +, which can be expressed as follows: a+ = aa*, and a? = (a|ε). Sometimes the complement operator is added, to give a generalized regular expression; here R c matches all strings over Σ* that do not match R. In principle, the complement operator is redundant, as it can always be circumscribed by using the other operators. However, the process for computing such a representation is complex, and the result may require expressions of a size that is double exponentially larger. [ Gelade Neven 2008 ] [ Gruber Holzer 2008 ] Regular expressions in this sense can express the regular language s, exactly the class of languages accepted by deterministic finite automata. There is, however, a significant difference in compactness. Some classes of regular languages can only be described by deterministic finite automata whose size grows exponentially in the size of the shortest equivalent regular expressions. The standard example here is the languagesL k consisting of all strings over the alphabet {a,b} whose k th -from-last letter equals  a. On one hand, a regular expression describing L 4 is given by (a|b)^*a(a|b)(a|b)(a|b). Generalizing this pattern to L k gives the expression (a|b)^*a\underbrace{(a|b)(a|b)\cdots(a|b)}_{k-1\text{ times}}. \, On the other hand, it is known that every deterministic finite automaton accepting the language L k must have at least 2 k states. Luckily, there is a simple mapping from regular expressions to the more general nondeterministic finite automata (NFAs) that does not lead to such a blowup in size; for this reason NFAs are often used as alternative representations of regular languages. NFAs are a simple variation of the type-3 grammars of the Chomsky hierarchy. Finally, it is worth noting that many real-world &quot; regular expression &quot; engines implement features that cannot be described by the regular expressions in the sense of formal language theory; see below for more on this. [ Deciding equivalence of regular expressions ] As seen in many of the examples above, there is more than one way to construct a regular expression to achieve the same results. It is possible to write an algorithm which for two given regular expressions decides whether the described languages are essentially equal, reduces each expression to a minimal deterministic finite state machine, and determines whether they are isomorphic (equivalent). The redundancy can be eliminated by using Kleene star and set union to find an interesting subset of regular expressions that is still fully expressive, but perhaps their use can be restricted. This is a surprisingly difficult problem. As simple as the regular expressions are, there is no method to systematically rewrite them to some normal form. The lack of axiom in the past led to the star height problem. In 1991, Dexter Kozen axiomatized regular expressions with Kleene algebra. [ Kozen 1991 ] [ Syntax ] { A number of } { special character s or meta characters are used to denote actions or delimit groups; but it is possible to force these special characters to be interpreted as normal characters by preceding them with a defined } { escape character, usually the } { backslash &quot; \ &quot;. For example, a dot is normally used as a &quot; wild card &quot; metacharacter to denote any character, but if preceded by a backslash it represents the dot character itself. The pattern c.t matches &quot; cat &quot;, &quot; cot &quot;, &quot; cut &quot;, and non-words such as &quot; czt &quot; and &quot; c.t &quot;; but c\.t matches only &quot; c.t &quot;. The backslash also escapes itself, i.e., two backslashes are interpreted as a literal backslash character. } [ POSIX ] [ POSIX Basic Regular Expressions ] Traditional Unix regular expression syntax followed common conventions but often differed from tool to tool. The IEEE POSIX Basic Regular Expressions (BRE) standard (ISO/IEC 9945-2:1993 Information technology -- Portable Operating System Interface (POSIX) -- Part 2: Shell and Utilities, successively revised as ISO/IEC 9945-2:2002 Information technology -- Portable Operating System Interface (POSIX) -- Part 2: System Interfaces, ISO/IEC 9945-2:2003, and currently ISO/IEC/IEEE 9945:2009 Information technology -- Portable Operating System Interface (POSIX®) Base Specifications, Issue 7) was designed mostly for backward compatibility with the traditional (Simple Regular Expression) syntax but provided a common standard which has since been adopted as the default syntax of many Unix regular expression tools, though there is often some variation or additional features. BRE was released alongside an alternative flavor called Extended Regular Expressions or ERE. Many Unix tools also provide support for ERE syntax with command line argument s. In the BRE syntax, most characters are treated as literal s  — they match only themselves (e.g., a matches &quot; a &quot; ). The exceptions, listed below, are called metacharacter s or metasequences. [ BRE: \(  \) ] [ ERE: (  ) ] [ BRE: \{m,n\} ] [ ERE: {m,n} ] Metacharacter Description. Matches any single character (many applications exclude newline s, and exactly which characters are considered newlines is flavor-, character-encoding-, and platform-specific, but it is safe to assume that the line feed character is included). Within POSIX bracket expressions, the dot character matches a literal dot. For example, a.c matches &quot; abc &quot;, etc., but [a.c] matches only &quot; a &quot;, &quot;. &quot;, or &quot; c &quot;. [  ] A bracket expression. Matches a single character that is contained within the brackets. For example, [abc] matches &quot; a &quot;, &quot; b &quot;, or &quot; c &quot;. [a-z] specifies a range which matches any lowercase letter from &quot; a &quot; to &quot; z &quot;. These forms can be mixed: [abcx-z] matches &quot; a &quot;, &quot; b &quot;, &quot; c &quot;, &quot; x &quot;, &quot; y &quot;, or &quot; z &quot;, as does [a-cx-z].The - character is treated as a literal character if it is the last or the first (after the ^ ) character within the brackets: [abc-], [-abc]. Note that backslash escapes are not allowed. The ] character can be included in a bracket expression if it is the first (after the ^ ) character: []abc]. [^  ] Matches a single character that is not contained within the brackets. For example, [^abc] matches any character other than &quot; a &quot;, &quot; b &quot;, or &quot; c &quot;. [^a-z] matches any single character that is not a lowercase letter from &quot; a &quot; to &quot; z &quot;. Likewise, literal characters and ranges can be mixed. ^ Matches the starting position within the string. In line-based tools, it matches the starting position of any line. $ Matches the ending position of the string or the position just before a string-ending newline. In line-based tools, it matches the ending position of any line. Defines a marked subexpression. The string matched within the parentheses can be recalled later (see the next entry, \n ). A marked subexpression is also called a block or capturing group. \n Matches what the nth marked subexpression matched, where n is a digit from 1 to 9. This construct is theoretically irregular and was not adopted in the POSIX ERE syntax. Some tools allow referencing more than nine capturing groups. Matches the preceding element zero or more times. For example, ab*c matches &quot; ac &quot;, &quot; abc &quot;, &quot; abbbc &quot;, etc. [xyz]* matches &quot; &quot;, &quot; x &quot;, &quot; y &quot;, &quot; z &quot;, &quot; zx &quot;, &quot; zyx &quot;, &quot; xyzzy &quot;, and so on. \(ab\)* matches &quot; &quot;, &quot; ab &quot;, &quot; abab &quot;, &quot; ababab &quot;, and so on. Matches the preceding element at least m and not more than n times. For example, a\{3,5\} matches only &quot; aaa &quot;, &quot; aaaa &quot;, and &quot; aaaaa &quot;. This is not found in a few older instances of regular expressions. Examples:.at matches any three-character string ending with &quot; at &quot;, including &quot; hat &quot;, &quot; cat &quot;, and &quot; bat &quot;. [hc]at matches &quot; hat &quot; and &quot; cat &quot;. [^b]at matches all strings matched by.at except &quot; bat &quot;. ^[hc]at matches &quot; hat &quot; and &quot; cat &quot;, but only at the beginning of the string or line. [hc]at$ matches &quot; hat &quot; and &quot; cat &quot;, but only at the end of the string or line. \[.\] matches any single character surrounded by &quot; [ &quot; and &quot; ] &quot; since the brackets are escaped, for example: &quot; [a] &quot; and &quot; [b] &quot;. [ POSIX Extended Regular Expressions ] The meaning of metacharacters escaped with a backslash is reversed for some characters in the POSIX Extended Regular Expression (ERE) syntax. With this syntax, a backslash causes the metacharacter to be treated as a literal character. So, for example, \(  \) is now (  ) and \{  \} is now &lt; code &gt; {  } &lt; code &gt;. Additionally, support is removed for \n backreferences and the following metacharacters are added: Metacharacter Description ? Matches the preceding element zero or one time. For example, ba? matches &quot; b &quot; or &quot; ba &quot;. + Matches the preceding element one or more times. For example, ba+ matches &quot; ba &quot;, &quot; baa &quot;, &quot; baaa &quot;, and so on. | The choice (aka alternation or set union) operator matches either the expression before or the expression after the operator. For example, abc|def matches &quot; abc &quot; or &quot; def &quot;. &lt; /td &gt; Examples: &lt; code &gt; [hc]+at &lt; code &gt; matches &quot; hat &quot;, &quot; cat &quot;, &quot; hhat &quot;, &quot; chat &quot;, &quot; hcat &quot;, &quot; ccchat &quot;, and so on, but not &quot; at &quot;. [hc]?at matches &quot; hat &quot;, &quot; cat &quot;, and &quot; at &quot;. &lt; code &gt; [hc]*at &lt; code &gt; matches &quot; hat &quot;, &quot; cat &quot;, &quot; hhat &quot;, &quot; chat &quot;, &quot; hcat &quot;, &quot; ccchat &quot;, &quot; at &quot;, and so on. cat|dog matches &quot; cat &quot; or &quot; dog &quot;. POSIX Extended Regular Expressions can often be used with modern Unix utilities by including the command line flag -E. [ POSIX character classes ] Since many ranges of characters depend on the chosen locale setting (i.e., in some settings letters are organized as abc...zABC...Z, while in some others as aAbBcC...zZ), the POSIX standard defines some classes or categories of characters as shown in the following table: POSIX Non-standard Perl Vim ASCII Description [:alnum:] [A-Za-z0-9] Alphanumeric characters [:word:] \w \w [A-Za-z0-9_] Alphanumeric characters plus &quot; _ &quot; \W \W [^A-Za-z0-9_] Non-word characters [:alpha:] \a [A-Za-z] Alphabetic characters [:blank:] [ \t ] Space and tab \b \ &lt; \ &gt; &lt; code &gt; (? &lt; =\W)(?=\w) &amp; #124;(? &lt; =\w)(?=\W) &lt; /code &gt; Word boundaries [:cntrl:] [\x00-\x1F\x7F] Control character s [:digit:] \d \d [0-9] Digits \D \D [^0-9] Non-digits [:graph:] [\x21-\x7E] Visible characters [:lower:] \l [a-z] Lowercase letters [:print:] \p [\x20-\x7E] Visible characters and the space character [:punct:] [\]\[! &quot; #$% &amp; &apos;()*+,./:; &lt; = &gt; ?@\^_`{|}~-] Punctuation characters [:space:] \s \s [ \t \r \n \v \f ] Whitespace character s \S \S [^ \t\r\n\v\f] Non-whitespace characters [:upper:] \u [A-Z] Uppercase letters [:xdigit:] \x [A-Fa-f0-9] Hexadecimal digits POSIX character classes can only be used within bracket expressions. For example, [[:upper:]ab] matches the uppercase letters and lowercase &quot; a &quot; and &quot; b &quot;. An additional non-POSIX class understood by some tools is [:word:], which is usually defined as [:alnum:] plus underscore. This reflects the fact that in many programming languages these are the characters that may be used in identifiers. The editor Vim further distinguishes word and word-head classes (using the notation \w and \h ) since in many programming languages the characters that can begin an identifier are not the same as those that can occur in other positions. Note that what the POSIX regular expression standards call character classes are commonly referred to as POSIX character classes in other regular expression flavors which support them. With most other regular expression flavors, the term character class is used to describe what POSIX calls bracket expressions. [ Perl-derived regular expressions ] Perl has a more consistent and richer syntax than the POSIX basic (BRE) and extended (ERE) regular expression standards. An example of its consistency is that \ always escapes a non-alphanumeric character. Other examples of functionality possible with Perl but not POSIX-compliant regular expressions is the concept of lazy quantification (see the next section), possessive quantifies to control backtracking, named capture groups, and recursive patterns. Due largely to its expressive power, many other utilities and programming languages have adopted syntax similar to Perl&apos;s  — for example, Java, JavaScript, PCRE, Python, Ruby, Microsoft &apos;s.NET Framework, and the W3C&apos;s XML Schema all use regular expression syntax similar to Perl&apos;s. Some languages and tools such as Boost and PHP support multiple regular expression flavors. Perl-derivative regular expression implementations are not identical, and all implement no more than a subset of Perl&apos;s features, usually those of Perl 5.0, released in 1994. With Perl 5.10, this process has come full circle with Perl incorporating syntactic extensions originally developed in Python and PCRE [ http://perldoc.perl.org/perlre.html#PCRE%2FPython-Support Perl Regular Expression Documentation perldoc.perl.org January 8, 2012 ] [ Simple Regular Expressions ] Simple Regular Expressions is a syntax that may be used by historical versions of application programs, and may be supported within some applications for the purpose of providing backward compatibility. It is deprecated. { The Single Unix Specification (Version 2) } [ Lazy quantification ] The standard quantifiers in regular expressions are greedy, meaning they match as much as they can. For example, to find the first instance of an item between the angled bracket symbols &lt; &gt; in this example: { Another whale sighting occurred on &lt; January 26 &gt;, &lt; 2004 &gt;. } someone new to regexes would likely come up with the pattern &lt;.* &gt; or similar. However, instead of the &quot; &lt; January 26 &gt; &quot; that might be expected, this pattern will actually return &quot; &lt; January 26 &gt;, &lt; 2004 &gt; &quot; because the quantifier is greedy  — it will consume as many characters as possible from the input, and &quot; &lt; January 26 &gt;, &lt; 2004 &gt; &quot; has more characters than &quot; &lt; January 26 &gt; &quot;. Though this problem can be avoided in a number of ways (e.g., by specifying the text that is not to be matched: &lt; [^ &gt; ]* &gt; ), modern regular expression tools allow a quantifier to be specified as lazy (also known as non-greedy, reluctant, minimal, or ungreedy) by putting a question mark after the quantifier (e.g., &lt;.*? &gt; ), or by using a modifier which reverses the greediness of quantifiers (though changing the meaning of the standard quantifiers can be confusing). By using a lazy quantifier, the expression tries the minimal match first. Though in the previous example lazy matching is used to select one of many matching results, in some cases it can also be used to improve performance when greedy matching would require more backtracking. [ Patterns for non-regular languages ] Many features found in modern regular expression libraries provide an expressive power that far exceeds the regular language s. For example, many implementations allow grouping subexpressions with parentheses and recalling the value they match in the same expression ( [ backreferences ] ). This means that a pattern can match strings of repeated words like &quot; papa &quot; or &quot; WikiWiki &quot;, called squares in formal language theory. The pattern for these strings is (.*)\1. The language of squares is not regular, nor is it context-free. Pattern matching with an unbounded number of back references, as supported by numerous modern tools, is NP-complete (see, [ Aho 1990 ] Theorem 6.2). However, many tools, libraries, and engines that provide such constructions still use the term regular expression for their patterns. This has led to a nomenclature where the term regular expression has different meanings in formal language theory and pattern matching. For this reason, some people have taken to using the term regex or simply pattern to describe the latter. Larry Wall, author of the Perl programming language, writes in an essay about the design of Perl 6: [ &apos;Regular expressions&apos; [...] are only marginally related to real regular expressions. Nevertheless, the term has grown with the capabilities of our pattern matching engines, so I&apos;m not goin g to try to fight linguistic necessity here. I will, however, generally call them &quot; regexes &quot; (or &quot; regexen &quot;, when I&apos;m in an Anglo-Saxon mood). ] [ Fuzzy Regular Expressions ] [ September 2011 ] Variants of regular expressions can be used for working with text in natural language, when it is necessary to take into account possible typos and spelling variants. For example, the text &quot; Julius Caesar &quot; might be a fuzzy match for: Gaius Julius Caesar Yulius Cesar G. Juliy Caezar In such cases the mechanism implements some fuzzy string matching algorithm and possibly some algorithm for finding the similarity between text fragment and pattern. This task is closely related to both full text search and named entity recognition. Some software libraries work with fuzzy regular expressions: TRE - well-developed portable free project in C, which uses syntax similar to POSIX FREJ - open source project in Java with non-standard syntax (which utilizes prefix, Lisp -like notation), targeted to allow easy use of substitutions of inner matched fragments in outer blocks, but lacks many features of standard regular expressions. agrep - command-line utility (proprietary, but free for non-commercial usage). [ Implementations and running times ] There are at least three different algorithm s that decide if and how a given regular expression matches a string. The oldest and fastest rely on a result in formal language theory that allows every nondeterministic finite automaton (NFA) to be transformed into a deterministic finite automaton (DFA). The DFA can be constructed explicitly and then run on the resulting input string one symbol at a time. Constructing the DFA for a regular expression of size m has the time and memory cost of &apos;&apos;O&apos;&apos; (2 m ), but it can be run on a string of size n in time O(n). An alternative approach is to simulate the NFA directly, essentially building each DFA state on demand and then discarding it at the next step. This keeps the DFA implicit and avoids the exponential construction cost, but running cost rises to O(m 2 n). The explicit approach is called the DFA algorithm and the implicit approach the NFA algorithm. Adding caching to the NFA algorithm is often called the &quot; lazy DFA &quot; algorithm, or just the DFA algorithm without making a distinction. These algorithms are fast, but using them for recalling grouped subexpressions, lazy quantification, and similar features is tricky. [ Cox 2007 ] [ Laurikari 2009 ] The third algorithm is to match the pattern against the input string by backtracking. This algorithm is commonly called NFA, but this terminology can be confusing. Its running time can be exponential, which simple implementations exhibit when matching against expressions like (a|aa)*b that contain both alternation and unbounded quantification and force the algorithm to consider an exponentially increasing number of sub-cases. This behavior can cause a security problem called Regular expression Denial of Service. Although backtracking implementations only give an exponential guarantee in the worst case, they provide much greater flexibility and expressive power. For example, any implementation which allows the use of backreferences, or implements the various extensions introduced by Perl, must include some kind of backtracking. Some implementations try to provide the best of both algorithms by first running a fast DFA algorithm, and revert to a potentially slower backtracking algorithm only when a backreference is encountered during the match. [ Unicode ] In theoretical terms, any token set can be matched by regular expressions as long as it is pre-defined. In terms of historical implementations, regular expressions were originally written to use ASCII characters as their token set though regular expression libraries have supported numerous other character set s. Many modern regular expression engines offer at least some support for Unicode. In most respects it makes no difference what the character set is, but some issues do arise when extending regular expressions to support Unicode. [ UTS#18 on Unicode Regular Expressions, Annex A: Character Blocks http://unicode.org/reports/tr18/#Character_Blocks 2010-02-05 ] [ java.util.regex java/util/regex ] Supported encoding. Some regular expression libraries expect to work on some particular encoding instead of on abstract Unicode characters. Many of these require the UTF-8 encoding, while others might expect UTF-16, or UTF-32. In contrast, Perl and Java are agnostic on encodings, instead operating on decoded characters internally. Supported Unicode range. Many regular expression engines support only the Basic Multilingual Plane, that is, the characters which can be encoded with only 16 bits. Currently, only a few regular expression engines (e.g., Perl&apos;s and Java&apos;s) can handle the full 21-bit Unicode range. Extending ASCII-oriented constructs to Unicode. For example, in ASCII-based implementations, character ranges of the form [x-y] are valid wherever x and y are codepoints in the range [0x00,0x7F] and codepoint(x) ≤ codepoint(y). The natural extension of such character ranges to Unicode would simply change the requirement that the endpoints lie in [0x00,0x7F] to the requirement that they lie in [0,0x10FFFF]. However, in practice this is often not the case. Some implementations, such as that of gawk, do not allow character ranges to cross Unicode blocks. A range like [0x61,0x7F] is valid since both endpoints fall within the Basic Latin block, as is [0x0530,0x0560] since both endpoints fall within the Armenian block, but a range like [0x0061,0x0532] is invalid since it includes multiple Unicode blocks. Other engines, such as that of the Vim editor, allow block-crossing but limit the number of characters in a range to 128. Case insensitivity. Some case-insensitivity flags affect only the ASCII characters. Other flags affect all characters. Some engines have two different flags, one for ASCII, the other for Unicode. Exactly which characters belong to the POSIX classes also varies. Cousins of case insensitivity. As ASCII has case distinction, case insensitivity became a logical feature in text searching. Unicode introduced alphabetic scripts without case like Devanagari. For these, case sensitivity is not applicable. For scripts like Chinese, another distinction seems logical: between traditional and simplified. In Arabic scripts, insensitivity to initial, medial, final, and isolated position may be desired. In Japanese, insensitivity between hiragana and katakana is sometimes useful. Normalization. Unicode has combining characters. Like old typewriters, plain letters can be followed by one of more non-spacing symbols (usually diacritics like accent marks) to form a single printing character, but also provides precomposed characters, i.e. characters that already include one or more combining characters. A sequence of a character + combining character should be matched with the identical single precomposed character. The process of standardizing sequences of characters + combining characters is called normalization. New control codes. Unicode introduced amongst others, byte order marks and text direction markers. These codes might have to be dealt with in a special way. Introduction of character classes for Unicode blocks, scripts, and numerous other character properties. Block properties are much less useful than script properties, because a block can have code points from several different scripts, and a script can have code points from several different blocks. In Perl and the library, properties of the form \p{InX} or \p{Block=X} match characters in block X and \P{InX} or \P{Block=X} matches code points not in that block. Similarly, \p{Armenian}, \p{IsArmenian}, or \p{Script=Armenian} matches any character in the Armenian script. In general, \p{X} matches any character with either the binary property X or the general category X. For example, \p{Lu}, \p{Uppercase_Letter}, or \p{GC=Lu} matches any upper-case letter. Binary properties that are not general categories include \p{White_Space}, \p{Alphabetic}, \p{Math}, and \p{Dash}. Examples of non-binary properties are \p{Bidi_Class=Right_to_Left}, \p{Word_Break=A_Letter}, and \p{Numeric_Value=10}. [ Uses ] Regular expressions are useful in the production of syntax highlighting systems, data validation, and many other tasks. While regular expressions would be useful on search engine s such as Google, processing them across the entire database could consume excessive computer resources depending on the complexity and design of the regex. Although in many cases system administrators can run regex-based queries internally, most search engines do not offer regex support to the public. Notable exceptions: Google Code Search, Exalead. [ Examples ] [ May 2009 ] [ March 2012 ] A regular expression is a string that is used to describe or match a set of strings according to certain syntax rules. The specific syntax rules vary depending on the specific implementation, programming language, or library in use. Additionally, the functionality of regex implementations can vary between version s. Despite this variability, and because regular expressions can be difficult to both explain and understand without examples, this article provides a basic description of some of the properties of regular expressions by way of illustration. The following conventions are used in the examples. { The character &apos;m&apos; is not always required to specify a } { Perl match operation. For example, m/[^abc]/ could also be rendered as /[^abc] /. The &apos;m&apos; is only necessary if the user wishes to specify a match operation without using a forward-slash as the regex } { delimiter. Sometimes it is useful to specify an alternate regex delimiter in order to avoid &quot; } { delimiter collision &quot;. See &apos; perldoc perlre &apos; for more details. } { metacharacter(s);; the metacharacters column specifies the regex syntax being demonstrated } { =~ m//;; indicates a regex match operation in } { Perl } { =~ s ///;; indicates a regex substitution operation in Perl } Also worth noting is that these regular expressions are all Perl-like syntax. Standard POSIX regular expressions are different. Unless otherwise indicated, the following examples conform to the Perl programming language, release 5.8.8, January 31, 2006. This means that other implementations may lack support for some parts of the syntax shown here (e.g. basic vs. extended regex, \( \) vs. (), or lack of \d instead of POSIX [:digit:]). The syntax and conventions used in these examples coincide with that of other programming environments as well (e.g., see Java in a Nutshell  — Page 213, Python Scripting for Computational Science  — Page 320, Programming PHP  — Page 106). Metacharacter(s) Description Example Note that all the if statements return a TRUE value. Normally matches any character except a newline. Within square brackets the dot is literal. $string1 = &quot; Hello World\n &quot;;if ($string1 =~ m/...../) { { print &quot; $string1 has length &gt; = 5\n &quot;; } } ( ) Groups a series of pattern elements to a single element. When you match a pattern within parentheses, you can use any of $1, $2,... later to refer to the previously matched pattern. $string1 = &quot; Hello World\n &quot;;if ($string1 =~ m/(H..).(o..)/) { { print &quot; We matched &apos;$1&apos; and &apos;$2&apos;\n &quot;; } } Output: We matched &apos;Hel&apos; and &apos;o W&apos;; + Matches the preceding pattern element one or more times. $string1 = &quot; Hello World\n &quot;;if ($string1 =~ m/l+/) { { print &quot; There are one or more consecutive letter \ &quot; l\ &quot; &apos;s in $string1\n &quot;; } } Output: There are one or more consecutive letter &quot; l &quot; &apos;s in Hello World ? Matches the preceding pattern element zero or one times. $string1 = &quot; Hello World\n &quot;;if ($string1 =~ m/H.?e/) { { print &quot; There is an &apos;H&apos; and a &apos;e&apos; separated by &quot;; } { print &quot; 0-1 characters (Ex: He Hoe)\n &quot;; } } ? Modifies the *, +, or {M,N}&apos;d regex that comes beforeto match as few times as possible. $string1 = &quot; Hello World\n &quot;;if ($string1 =~ m/(l.+?o)/) { { print &quot; The non-greedy match with &apos;l&apos; followed by one or &quot;; } { print &quot; more characters is &apos;llo&apos; rather than &apos;llo wo&apos;.\n &quot;; } } Matches the preceding pattern element zero or more times. $string1 = &quot; Hello World\n &quot;;if ($string1 =~ m/el*o/) { { print &quot; There is an &apos;e&apos; followed by zero to many &quot;; } { print &quot; &apos;l&apos; followed by &apos;o&apos; (eo, elo, ello, elllo)\n &quot;; } } {M,N} Denotes the minimum M and the maximum N match count. $string1 = &quot; Hello World\n &quot;;if ($string1 =~ m/l{1,2}/) { { print &quot; There exists a substring with at least 1 &quot;; } { print &quot; and at most 2 l&apos;s in $string1\n &quot;; } } [...] Denotes a set of possible character matches. $string1 = &quot; Hello World\n &quot;;if ($string1 =~ m/[aeiou]+/) { { print &quot; $string1 contains one or more vowels.\n &quot;; } } | Separates alternate possibilities. $string1 = &quot; Hello World\n &quot;;if ($string1 =~ m/(Hello|Hi|Pogo)/) { { print &quot; At least one of Hello, Hi, or Pogo is &quot;; } { print &quot; contained in $string1.\n &quot;; } } \b Matches a zero-width boundary between a word-class character (see next) and either a non-word class character or an edge. $string1 = &quot; Hello World\n &quot;;if ($string1 =~ m/llo\b/) { { print &quot; There is a word that ends with &apos;llo&apos;\n &quot;; } } \w Matches an alphanumeric character, including &quot; _ &quot;; same as [A-Za-z0-9_] in ASCII. In Unicode same as [\p{Alphabetic}\p{GC=Mark}\p{GC=Decimal_Number\p{GC=Connector_Punctuation}], where the Alphabetic property contains more than just Letters, and the Decimal_Number property contains more than [0-9]. $string1 = &quot; Hello World\n &quot;;if ($string1 =~ m/\w/) { { print &quot; There is at least one alphanumeric &quot;; } { print &quot; character in $string1 (A-Z, a-z, 0-9, _)\n &quot;; } } \W Matches a non-alphanumeric character, excluding &quot; _ &quot;; same as [^A-Za-z0-9_] in ASCII, and [^\p{Alphabetic}\p{GC=Mark}\p{GC=Decimal_Number}\p{GC=Connector_Punctuation}] in Unicode. $string1 = &quot; Hello World\n &quot;;if ($string1 =~ m/\W/) { { print &quot; The space between Hello and &quot;; } { print &quot; World is not alphanumeric\n &quot;; } } \s Matches a whitespace character, which in ASCII are tab, line feed, form feed, carriage return, and space; in Unicode, also matches no-break spaces, next line, and the variable-width spaces (amongst others). $string1 = &quot; Hello World\n &quot;;if ($string1 =~ m/\s.*\s/) { { print &quot; There are TWO whitespace characters, which may &quot;; } { print &quot; be separated by other characters, in $string1 &quot;; } } \S Matches anything BUT a whitespace. $string1 = &quot; Hello World\n &quot;;if ($string1 =~ m/\S.*\S/) { { print &quot; There are TWO non-whitespace characters, which &quot;; } { print &quot; may be separated by other characters, in $string1 &quot;; } } \d Matches a digit; same as [0-9] in ASCII; in Unicode, same as the \p{Digit} or \p{GC=Decimal_Number} property, which itself the same as the \p{Numeric_Type=Decimal} property. $string1 = &quot; 99 bottles of beer on the wall. &quot;;if ($string1 =~ m/(\d+)/) { { print &quot; $1 is the first number in &apos;$string1&apos;\n &quot;; } } Output: 99 is the first number in &apos;99 bottles of beer on the wall.&apos; \D Matches a non-digit; same as [^0-9] in ASCII or \P{Digit} in Unicode. $string1 = &quot; Hello World\n &quot;;if ($string1 =~ m/\D/) { { print &quot; There is at least one character in $string1 &quot;; } { print &quot; that is not a digit.\n &quot;; } } ^ Matches the beginning of a line or string. $string1 = &quot; Hello World\n &quot;;if ($string1 =~ m/^He/) { { print &quot; $string1 starts with the characters &apos;He&apos;\n &quot;; } } $ Matches the end of a line or string. $string1 = &quot; Hello World\n &quot;;if ($string1 =~ m/rld$/) { { print &quot; $string1 is a line or string &quot;; } { print &quot; that ends with &apos;rld&apos;\n &quot;; } } \A Matches the beginning of a string (but not an internal line). $string1 = &quot; Hello\nWorld\n &quot;;if ($string1 =~ m/\AH/) { { print &quot; $string1 is a string &quot;; } { print &quot; that starts with &apos;H&apos;\n &quot;; } } \z Matches the end of a string (but not an internal line). see Perl Best Practices  — Page 240 $string1 = &quot; Hello\nWorld\n &quot;;if ($string1 =~ m/d\n\z/) { { print &quot; $string1 is a string &quot;; } { print &quot; that ends with &apos;d\\n&apos;\n &quot;; } } [^...] Matches every character except the ones inside brackets. $string1 = &quot; Hello World\n &quot;;if ($string1 =~ m/[^abc]/) { { print &quot; $string1 contains a character other than &quot;; } { print &quot; a, b, and c\n &quot;; } } &lt; /center &gt; [ See also ] Comparison of regular expression engines Extended Backus–Naur Form List of regular expression software - applications which support regular expressions Regular tree grammar Regular language [ Notes ] [ 20em ] [ References ] [ Aho Alfred V. Alfred Aho 1990 Algorithms for finding patterns in strings van Leeuwen Jan Jan van Leeuwen Handbook of Theoretical Computer Science, volume A: Algorithms and Complexity The MIT Press 255–300 harv ] [ The Open Group http://pubs.opengroup.org/onlinepubs/007908799/xbd/re.html Regular Expressions The Single UNIX ® Specification, Version 2 1997 harv ] [ The Open Group http://pubs.opengroup.org/onlinepubs/009695399/basedefs/xbd_chap09.html Chapter 9: Regular Expressions The Open Group Base Specifications Issue 6, IEEE Std 1003.1, 2004 Edition 2004 harv ] [ http://swtch.com/~rsc/regexp/regexp1.html Regular Expression Matching Can Be Simple and Fast Cox Russ 2007 harv ] [ Ben Forta Ben Forta 2004 Sams Teach Yourself Regular Expressions in 10 Minutes Sams 0-672-32566-7 ] [ Jeffrey Friedl Jeffrey Friedl 2002 Mastering Regular Expressions http://regex.info/ O&apos;Reilly 0-596-00289-0 ] [ Gelade Wouter Neven Frank Succinctness of the Complement and Intersection of Regular Expressions 325–336 Proceedings of the 25th International Symposium on Theoretical Aspects of Computer Science (STACS 2008) http://drops.dagstuhl.de/opus/volltexte/2008/1354 2008 harv ] [ Gruber Hermann Holzer Markus Finite Automata, Digraph Connectivity, and Regular Expression Size 39–50 Proceedings of the 35th International Colloquium on Automata, Languages and Programming (ICALP 2008) http://www.hermann-gruber.com/data/icalp08.pdf 2008 10.1007/978-3-540-70583-3_4 5126 harv ] [ Mehran Habibi Mehran Habibi 2004 Real World Regular Expressions with Java 1.4 Springer 1-59059-107-0 ] [ Hopcroft John E. Motwani Rajeev Ullman Jeffrey D. Introduction to Automata Theory, Languages, and Computation Addison-Wesley 2000 2nd harv ] [ Kleene Stephen C. Representation of Events in Nerve Nets and Finite Automata Automata Studies Shannon Claude E. McCarthy John Princeton University Press 1956 3–42 harv ] [ Kozen Dexter A Completeness Theorem for Kleene Algebras and the Algebra of Regular Events Proceedings of the 6th Annual IEEE Symposium on Logic in Computer Science (LICS 1991) 214–225 1991 harv ] [ http://www.laurikari.net/tre/ TRE library 0.7.6 Ville Laurikari 2009 harv ] [ Francois Liger Francois Liger Craig McQueen, Paul Wilton 2002 Visual Basic.NET Text Manipulation Handbook Wrox Press 1-86100-730-2 ] [ Michael Sipser Michael Sipser 1998 Introduction to the Theory of Computation Chapter 1: Regular Languages 31–90 PWS Publishing 0-534-94728-X harv ] [ Tony Stubblebine Tony Stubblebine 2003 Regular Expression Pocket Reference O&apos;Reilly 0-596-00415-X ] [ http://dev.perl.org/perl6/doc/design/apo/A05.html Apocalypse 5: Pattern Matching Larry Wall Larry Wall 2002 ] [ Jan Goyvaerts [Jan Goyvaerts], [Steven Levithan] 2009 Regular Expressions Cookbook [O&apos;reilly] 978-0-596-52068-7 ] [ External links ] [ Regular Expressions ] [ Computers/Programming/Languages/Regular_Expressions Regular Expressions ] ISO/IEC 9945-2:1993 &apos;&apos;Information technology -- Portable Operating System Interface (POSIX) -- Part 2: Shell and Utilities&apos;&apos; ISO/IEC 9945-2:2002 &apos;&apos;Information technology -- Portable Operating System Interface (POSIX) -- Part 2: System Interfaces&apos;&apos; ISO/IEC 9945-2:2003 &apos;&apos;Information technology -- Portable Operating System Interface (POSIX) -- Part 2: System Interfaces&apos;&apos; ISO/IEC/IEEE 9945:2009 &apos;&apos;Information technology -- Portable Operating System Interface (POSIX®) Base Specifications, Issue 7&apos;&apos; Java Tutorials: Regular Expressions Perl Regular Expressions documentation VBScript and Regular Expressions.NET Framework Regular Expressions Pattern matching tools and libraries Structural Regular Expressions by Rob Pike JavaScript Regular Expressions Chapter and RegExp Object Reference at the Mozilla Developer Center Category:Automata theory Category:Formal languages Category:Pattern matching Category:Programming constructs Category:Regular expressions ar:تعبير نمطي bg:Регулярен израз ca:Expressió regular cs:Regulární výraz da:Regulære udtryk de:Regulärer Ausdruck el:Κανονική έκφραση es:Expresión regular eo:Regula esprimo eu:Adierazpen erregular fa:عبارت باقاعده fr:Expression rationnelle gl:Expresión regular ko:정규 표현식 hi:रेग्युलर ऍक्सप्रैशन hr:Regularni izraz is:Regluleg segð it:Espressione regolare he:ביטוי רגולרי ka:რეგულარული გამოსახულება hu:Reguláris kifejezés mk:Регуларни изрази nl:Reguliere expressie ja:正規表現 no:Regulært uttrykk pl:Wyrażenie regularne pt:Expressão regular ro:Expresie regulată ru:Регулярные выражения simple:Regular expression sk:Regulárny výraz sr:Regularni izraz fi:Säännöllinen lauseke sv:Reguljära uttryck ta:சுருங்குறித்தொடர் th:นิพจน์ปรกติ tr:Düzenli ifade uk:Регулярний вираз vi:Biểu thức chính quy wa:Erîlêye ratourneure zh:正则表达式