[ the compiled programming language ] [ 1959 ] { Grace Hopper, William Selden, Gertrude Tierney, Howard Bromberg, Howard Discount, Vernon Reeves, } { Jean E. Sammet } { COBOL 2002 } { 2002 } { strong, } { static } { OpenCOBOL, } { Micro Focus International (e.g. the } { Eclipse -plug-in Micro Focus Net Express) } { HP3000 COBOL/II, COBOL/2, IBM OS/VS COBOL, IBM COBOL/II, IBM COBOL SAA, IBM Enterprise COBOL, IBM COBOL/400, IBM ILE COBOL, Unix COBOL X/Open, Micro Focus COBOL, Microsoft COBOL, Ryan McFarland RM/COBOL, Ryan McFarland RM/COBOL-85, DOSVS COBOL, UNIVAC COBOL, Realia COBOL, Fujitsu COBOL, ICL COBOL, ACUCOBOL-GT, COBOL-IT, DEC COBOL-10, DEC VAX COBOL, Wang VS COBOL, Visual COBOL, Tandem (NonStop) COBOL85, Tandem (NonStop) SCOBOL (a COBOL74 variant for creating screens on text-based terminals) } { FLOW-MATIC, } { COMTRAN, } { FACT } { PL/I, } { CobolScript, } { ABAP } { COBOL } COBOL ( [ icon ˈ k oʊ b ɒ l ] ) is one of the oldest programming language s. Its name is an acronym for COmmon Business-Oriented Language, defining its primary domain in business, finance, and administrative systems for companies and governments. The COBOL 2002 standard includes support for object-oriented programming and other modern language features. [ Oliveira Rui The Power of Cobol BookSurge Publishing City 2006 0-620-34652-3 ] [ History and specification ] The COBOL specification was created by a committee of researchers from private industry, universities, and government during the second half of 1959. The specifications were to a great extent inspired by the FLOW-MATIC language invented by Grace Hopper - commonly referred to as &quot; the mother of the COBOL language. &quot; The IBM COMTRAN language invented by Bob Bemer was also drawn upon, but the FACT language specification from Honeywell was not distributed to committee members until late in the process and had relatively little impact. FLOW-MATIC &apos;s status as the only language of the bunch to have actually been implemented made it particularly attractive to the committee. [ Sammet Jean Jean_Sammet The Early History of COBOL ACM SIGPLAN Notices 13 8 121–161 Association for Computing Machinery, Inc. 1978 http://portal.acm.org/citation.cfm?id%3D1198367 14 January 2010 ] The scene was set on April 8, 1959 at a meeting of computer manufacturers, users, and university people at the University of Pennsylvania Computing Center. The United States Department of Defense subsequently agreed to sponsor and oversee the next activities. A meeting chaired by Charles A. Phillips was held at the Pentagon on May 28 and 29 of 1959 (exactly one year after the Zürich ALGOL 58 meeting); there it was decided to set up three committees: short, intermediate and long range (the last one was never actually formed). It was the Short Range Committee, chaired by Joseph Wegstein of the US National Bureau of Standards, that during the following months created a description of the first version of COBOL. [ Garfunkel Jerome The Cobol 85 Example Book Wiley New York 1987 0-471-80461-4 ] The committee was formed to recommend a short range approach to a common business language. The committee was made up of members representing six computer manufacturers and three government agencies. The six computer manufacturers were Burroughs Corporation, IBM, Minneapolis- Honeywell (Honeywell Labs), RCA, Sperry Rand, and Sylvania Electric Products. The three government agencies were the US Air Force, the Navy&apos;s David Taylor Model Basin, and the National Bureau of Standards (now National Institute of Standards and Technology ). The intermediate-range committee was formed but never became operational. In the end a sub-committee of the Short Range Committee developed the specifications of the COBOL language. This sub-committee was made up of six individuals: [ Wexelblat Richard History of Programming Languages Academic Press Boston 1981 0-12-745040-8 ] William Selden and Gertrude Tierney of IBM Howard Bromberg and Howard Discount of RCA Vernon Reeves and Jean E. Sammet of Sylvania Electric Products The decision to use the name &quot; COBOL &quot; was made at a meeting of the committee held on 18 September 1959. The subcommittee completed the specifications for COBOL in December 1959. The first compilers for COBOL were subsequently implemented in 1960, and on December 6 and 7, essentially the same COBOL program ran on two different computer makes, an RCA computer and a Remington-Rand Univac computer, demonstrating that compatibility could be achieved. [ ANS COBOL 1968 ] After 1959 COBOL underwent several modifications and improvements. In an attempt to overcome the problem of incompatibility between different versions of COBOL, the American National Standards Institute ( ANSI ) developed a standard form of the language in 1968. This version was known as American National Standard (ANS) COBOL. [ COBOL 1974 ] In 1974, ANSI published a revised version of (ANS) COBOL, containing a number of features that were not in the 1968 version. [ COBOL 1985 ] In 1985, ANSI published still another revised version that had new features not in the 1974 standard, most notably structured language constructs ( &quot; scope terminators &quot; ), including END-IF, END-PERFORM, END-READ, etc. [ COBOL 2002 and object-oriented COBOL ] The language continues to evolve today. In the early 1990s it was decided to add object-orientation in the next full revision of COBOL. The initial estimate was to have this revision completed by 1997 and an ISO CD (Committee Draft) was available by 1997. Some implementers (including Micro Focus, Fujitsu, Veryant, and IBM ) introduced object-oriented syntax based on the 1997 or other drafts of the full revision. The final approved ISO Standard (adopted as an ANSI standard by INCITS) was approved and made available in 2002. Like the C++ and Java programming languages, object-oriented COBOL compilers are available even as the language moves toward standardization. Fujitsu and Micro Focus currently support object-oriented COBOL compilers targeting the.NET framework. { NetCOBOL for.NET supports COBOL migration and software development in the.NET environment } The 2002 (4th revision) of COBOL included many other features beyond object-orientation. These included (but are not limited to): National Language support (including but not limited to Unicode support) Locale-based processing User-defined functions CALL (and function) prototypes (for compile-time parameter checking) Pointers and syntax for getting and freeing storage Calling conventions to and from non-COBOL languages such as C Support for execution within framework environments such as Microsoft&apos;s.NET and Java (including COBOL instantiated as Enterprise JavaBean s ) Bit and Boolean support “True” binary support (up until this enhancement, binary items were truncated based on the (base-10) specification within the Data Division) Floating-point support Standard (or portable) arithmetic results XML generation and parsing [ History of COBOL standards ] The specifications approved by the full Short Range Committee were approved by the Executive Committee on January 3, 1960, and sent to the government printing office, which edited and printed these specifications as COBOL 60. The American National Standards Institute (ANSI) produced several revisions of the COBOL standard, including: COBOL-68 COBOL-74 COBOL-85 Intrinsic Functions Amendment - 1989 Corrections Amendment - 1991 After the Amendments to the 1985 ANSI Standard (which were adopted by ISO), primary development and ownership was taken over by ISO. The following editions and TRs (Technical Reports) have been issued by ISO (and adopted as ANSI) Standards: COBOL 2002 Finalizer Technical Report - 2003 Native XML syntax Technical Report - 2006 Object Oriented Collection Class Libraries - pending final approval... From 2002, the ISO standard is also available to the public coded as ISO/IEC 1989. Work progresses on the next full revision of the COBOL Standard. Approval and availability was expected early 2010s. For information on this revision, to see the latest draft of this revision, or to see what other works is happening with the COBOL Standard, see the COBOL Standards Website. [ Legacy ] COBOL programs are in use globally in governmental and military agencies and in commercial enterprises, and are running on operating systems such as IBM&apos;s z/OS and z/VSE, the POSIX families ( Unix / Linux etc.), and Microsoft&apos;s Windows as well as ICL &apos;s VME operating system and Unisys &apos; OS 2200. In 1997, the Gartner Group reported that 80% of the world&apos;s business ran on COBOL with over 200 billion lines of code in existence and with an estimated 5 billion lines of new code annually. [ http://www.cobolportal.com/developer/future.asp?bhcp%3D1 What Professionals think of the Future of COBOL? Micro Focus 2010-05-05 ] Near the end of the twentieth century the year 2000 problem was the focus of significant COBOL programming effort, sometimes by the same programmers who had designed the systems decades before. The particular level of effort required for COBOL code has been attributed both to the large amount of business-oriented COBOL, as COBOL is by design a business language and business applications use dates heavily, and to constructs of the COBOL language such as the PICTURE clause, which can be used to define fixed-length numeric fields, including two-digit fields for years. [ May 2010 ] Because of the clean-up effort put into these COBOL programs for Y2K, many of them have been kept in use for years since then. [ June 2011 ] It should be noted however that while much of the Y2K focus was on COBOL, the fault was not in the design of the language itself, but the design of the applications that were written in COBOL. [ Features ] COBOL as defined in the original specification included a PICTURE clause for detailed field specification. It did not support local variables, recursion, dynamic memory allocation, or structured programming constructs. Support for some or all of these features has been added in later editions of the COBOL standard. COBOL has many reserved word s (over 400), called keywords. [ Self-modifying code ] The original COBOL specification supported self-modifying code via the infamous &quot; ALTER X TO PROCEED TO Y &quot; statement. X and Y are paragraph labels, and any &quot; GOTO X &quot; statements executed after such an ALTER statement have the meaning &quot; GOTO Y &quot; instead. Most [ July 2010 ] compilers still support it, but it should not be used in new programs as it was deprecated in COBOL 1985. [ December 2011 ] [ Syntactic features ] COBOL provides an update-in-place syntax, for example { ADD YEARS TO AGE } The equivalent construct in many procedural languages would be age = age + years This syntax is similar to the compound assignment operator later adopted by C: age += years The abbreviated conditional expression { IF SALARY &gt; 8000 OR SUPERVISOR-SALARY OR = PREV-SALARY } is equivalent to { IF SALARY &gt; 8000 } { OR SALARY &gt; SUPERVISOR-SALARY } { OR SALARY == PREV-SALARY } COBOL provides &quot; named conditions &quot; (so-called 88-levels). These are declared as sub-items of another item (the conditional variable). The named condition can be used in an IF statement, and tests whether the conditional variable is equal to any of the values given in the named condition&apos;s VALUE clause. The SET statement can be used to make a named condition TRUE (by assigning the first of its values to the conditional variable). COBOL allows identifiers up to 30 characters long. When COBOL was introduced, much shorter lengths (e.g., 6 characters for FORTRAN) were prevalent. COBOL introduced the concept of copybooks — chunks of code that can be inserted into a larger program. COBOL does this with the COPY statement, which also allows other code to replace parts of the copybook&apos;s code with other code (using the REPLACING... BY... clause). [ Data types ] Standard COBOL provides the following data type s : Data type Sample declaration Notes Character PIC X(20) PIC A(4)9(5)X(7) Alphanumeric and alphabetic-only Single-byte character set (SBCS) Edited character PIC X99BAXX Formatted and inserted characters Numeric fixed-point binary PIC S999V99 [USAGE] COMPUTATIONAL or BINARY Binary 16, 32, or 64 bits (2, 4, or 8 bytes) Signed or unsigned. Conforming compilers limit the maximum value of variables based on the picture clause and not the number of bits reserved for storage. Numeric fixed-point packed decimal &lt; code &gt; PIC S999V99 PACKED-DECIMAL 1 to 18 decimal digits (1 to 10 bytes) Signed or unsigned Numeric fixed-point zoned decimal PIC S999V99 [ USAGE DISPLAY ] 1 to 18 decimal digits (1 to 18 bytes) Signed or unsigned Leading or trailing sign, overpunch or separate Numeric floating-point PIC S9V999ES99 Binary floating-point Edited numeric PIC +Z,ZZ9.99 PIC $***,**9.99CR Formatted characters and digits Group ( record ) 01 CUST-NAME.    05 CUST-LAST PIC X(20).    05 CUST-FIRST PIC X(20). Aggregated elements Table ( array ) OCCURS 12 TIMES Fixed-size array, row-major order Up to 7 dimensions Variable-length table OCCURS 0 to 12 TIMES DEPENDING ON CUST-COUNT Variable-sized array, row-major order Up to 7 dimensions Renames ( variant or union data) 66 RAW-RECORD    RENAMES CUST-RECORD Character data overlaying other variables Condition name 88 IS-RETIRED-AGE    VALUES 65 THRU 150 Boolean value dependent upon another variable Array index [USAGE] INDEX Array subscript Most vendors provide additional types, such as: Data type Sample declaration Notes Numeric floating-point single precision PIC S9V9999999ES99 [USAGE] COMPUTATIONAL-1 Binary floating-point (32 bits, 7+ digits) (IBM extension) Numeric floating-point double precision PIC S9V999ES99 [USAGE] COMPUTATIONAL-2 Binary floating-point (64 bits, 16+ digits) (IBM extension) Numeric fixed-point packed decimal PIC S9V999 [USAGE] COMPUTATIONAL-3 same as PACKED DECIMAL (IBM extension) Numeric fixed-point binary PIC S999V99 [USAGE] COMPUTATIONAL-4 same as COMPUTATIONAL or BINARY (IBM extension) Numeric fixed-point binary (native binary) PIC S999V99 [USAGE] COMPUTATIONAL-5 Binary 16, 32, or 64 bits (2, 4, or 8 bytes) Signed or unsigned. The maximum value of variables based on the number of bits reserved for storage and not on the picture clause. (IBM extension) Numeric fixed-point binary in native byte order PIC S999V99 [USAGE] COMPUTATIONAL-4 Binary 16, 32, or 64 bits (2, 4, or 8 bytes) Signed or unsigned Numeric fixed-point binary in big-endian byte order PIC S999V99 [USAGE] COMPUTATIONAL-5 Binary 16, 32, or 64 bits (2, 4, or 8 bytes) Signed or unsigned Wide character PIC G(20) Alphanumeric Double-byte character set (DBCS) Edited wide character PIC G99BGGG Formatted and inserted wide characters Edited floating-point PIC +9.9(6)E+99 Formatted characters, decimal digits, and exponent Data pointer [USAGE] POINTER Data memory address Code pointer [USAGE] PROCEDURE-POINTER Code memory address Bit field PIC 1(n) [USAGE] COMPUTATIONAL-5 n can be from 1 to 64, defining an n-bit integer Signed or unsigned Index [USAGE] INDEX Binary value corresponding to an occurrence of a table element May be linked to a specific table using INDEXED BY [ Hello, world ] An example of the &quot; Hello, world &quot; program in COBOL: { IDENTIFICATION DIVISION. } { PROGRAM-ID. HELLO-WORLD. } { PROCEDURE DIVISION. } { DISPLAY &apos;Hello, world&apos;. } { STOP RUN. } Like any widespread programming language, there are various dialects of COBOL. Some compilers, for example, allow the use of double quotes in addition to standard single quotes: { DISPLAY &quot; Hello, world &quot;. } [ Hello, OS/360 circa 1972 ] On an IBM System/360 running OS/360 MVT 21.8f, circa 1972 (which predates the tradition of using Hello, world for introductory examples), Hello, world would have been punched onto 80 column cards, containing source code similar to: //COBUCLG JOB CLASS=A,MSGCLASS=A,MSGLEVEL=(1,1)//HELOWRLD EXEC COBUCLG,PARM.COB=&apos;MAP,LIST,LET&apos;//COB.SYSIN DD * { 001 IDENTIFICATION DIVISION. } { 002 PROGRAM-ID. &apos;HELLO&apos;. } { 003 ENVIRONMENT DIVISION. } { 004 CONFIGURATION SECTION. } { 005 SOURCE-COMPUTER. IBM-360. } { 006 OBJECT-COMPUTER. IBM-360. } { 0065 SPECIAL-NAMES. } { 0066 CONSOLE IS CNSL. } { 007 DATA DIVISION. } { 008 WORKING-STORAGE SECTION. } { 009 77 HELLO-CONST PIC X(12) VALUE &apos;HELLO, WORLD&apos;. } { 075 PROCEDURE DIVISION. } { 090 000-DISPLAY. } { 100 DISPLAY HELLO-CONST UPON CNSL. } { 110 STOP RUN. } //LKED.SYSLIB DD DSNAME=SYS1.COBLIB,DISP=SHR// DD DSNAME=SYS1.LINKLIB,DISP=SHR//GO.SYSPRINT DD SYSOUT=A// The // lines are JCL steps, surrounding COBOL sequence numbered source code, utilizing the ANS COBOL Compile, Link and Go module COBUCLG. HELLO, WORLD output would have been displayed on the operator&apos;s console, and the system printer would detail the run. Lots of details, with the summary output of this run about 12 lines from the bottom of the listing. { Using Hercules emulator, running OS/360 MVT 21.8f, sourced at http://www.jaymoseley.com/hercules/install.htm } //COBUCLG JOB CLASS=A,MSGCLASS=A,MSGLEVEL=(1,1)//HELOWRLD EXEC COBUCLG,PARM.COB=&apos;MAP,LIST,LET&apos;XXCOB EXEC PGM=IKFCBL00,REGION=86K,PARM=&apos;LOAD,SUPMAP&apos; 05000018XXSYSPRINT DD SYSOUT=A 10000018XXSYSUT1 DD UNIT=SYSDA,SPACE=(460,(700,100)) 15000018XXSYSUT2 DD UNIT=SYSDA,SPACE=(460,(700,100)) 20000018XXSYSUT3 DD UNIT=SYSDA,SPACE=(460,(700,100)) 25000018XXSYSUT4 DD UNIT=SYSDA,SPACE=(460,(700,100)) 30000018XXSYSLIN DD DSNAME= &amp; LOADSET,DISP=(MOD,PASS),UNIT=SYSDA, 35000018XX SPACE=(80,(500,100)) 40000018//COB.SYSIN DD *IEF236I ALLOC. FOR COBUCLG COB HELOWRLDIEF237I 352 ALLOCATED TO SYSPRINTIEF237I 151 ALLOCATED TO SYSUT1IEF237I 352 ALLOCATED TO SYSUT2IEF237I 150 ALLOCATED TO SYSUT3IEF237I 352 ALLOCATED TO SYSUT4IEF237I 151 ALLOCATED TO SYSLINIEF237I 150 ALLOCATED TO SYSIN { CB545 V2 LVL78 01MAY72 IBM OS AMERICAN NATIONAL STANDARD COBOL DATE FEB 25,1984 } { 1 } 00001 001 IDENTIFICATION DIVISION.00002 002 PROGRAM-ID. &apos;HELLO&apos;.00003 003 ENVIRONMENT DIVISION.00004 004 CONFIGURATION SECTION.00005 005 SOURCE-COMPUTER. IBM-360.00006 006 OBJECT-COMPUTER. IBM-360.00007 0065 SPECIAL-NAMES.00008 0066 CONSOLE IS CNSL.00009 007 DATA DIVISION.00010 008 WORKING-STORAGE SECTION.00011 009 77 HELLO-CONST PIC X(12) VALUE &apos;HELLO, WORLD&apos;.00012 075 PROCEDURE DIVISION.00013 090 000-DISPLAY.00014 100 DISPLAY HELLO-CONST UPON CNSL.00015 110 STOP RUN. { 2 } STATISTICS* SOURCE RECORDS = 15 DATA DIVISION STATEMENTS = 1 PROCEDURE DIVISION STATEMENTS = 2 OPTIONS IN EFFECT* SIZE = 81920 BUF = 2768 LINECNT = 57 SPACE1, FLAGW, SEQ, SOURCE OPTIONS IN EFFECT* NODMAP, NOPMAP, NOCLIST, NOSUPMAP, NOXREF, LOAD, NODECK, APOST, NOTRUNC, NOLIB, NOVERB OPTIONS IN EFFECT* ZWB IEC130I SYSPUNCH DD STATEMENT MISSINGIEC130I SYSLIB DD STATEMENT MISSINGIEC130I SYSPUNCH DD STATEMENT MISSINGIEF142I - STEP WAS EXECUTED - COND CODE 0000IEF285I SYS84056.T093538.SV000.COBUCLG.R0000001 SYSOUTIEF285I VOL SER NOS= WORK02.IEF285I SYS84056.T093538.RV000.COBUCLG.R0000002 DELETEDIEF285I VOL SER NOS= WORK01.IEF285I SYS84056.T093538.RV000.COBUCLG.R0000003 DELETEDIEF285I VOL SER NOS= WORK02.IEF285I SYS84056.T093538.RV000.COBUCLG.R0000004 DELETEDIEF285I VOL SER NOS= SYSRES.IEF285I SYS84056.T093538.RV000.COBUCLG.R0000005 DELETEDIEF285I VOL SER NOS= WORK02.IEF285I SYS84056.T093538.RV000.COBUCLG.LOADSET PASSEDIEF285I VOL SER NOS= WORK01.IEF285I SYS84056.T093538.RV000.COBUCLG.S0000006 SYSINIEF285I VOL SER NOS= SYSRES.IEF285I SYS84056.T093538.RV000.COBUCLG.S0000006 DELETEDIEF285I VOL SER NOS= SYSRES.IEF373I STEP /COB / START 84056.0937IEF374I STEP /COB / STOP 84056.0937 CPU 0MIN 00.08SEC MAIN 84K LCS 0KXXLKED EXEC PGM=IEWL,PARM=&apos;LIST,XREF,LET&apos;,COND=(5,LT,COB),REGION=96K 45000018XXSYSLIN DD DSNAME= &amp; LOADSET,DISP=(OLD,DELETE) 50000018XX DD DDNAME=SYSIN 55000018XXSYSLMOD DD DSNAME= &amp; GODATA(RUN),DISP=(NEW,PASS),UNIT=SYSDA, 60000018XX SPACE=(1024,(50,20,1)) 65000018//LKED.SYSLIB DD DSNAME=SYS1.COBLIB,DISP=SHRX/SYSLIB DD DSNAME=SYS1.COBLIB,DISP=SHR 70000018// DD DSNAME=SYS1.LINKLIB,DISP=SHRXXSYSUT1 DD UNIT=(SYSDA,SEP=(SYSLIN,SYSLMOD)),SPACE=(1024,(50,20)) 75000018XXSYSPRINT DD SYSOUT=A 80000018IEF236I ALLOC. FOR COBUCLG LKED HELOWRLDIEF237I 151 ALLOCATED TO SYSLINIEF237I 151 ALLOCATED TO SYSLMODIEF237I 350 ALLOCATED TO SYSLIBIEF237I 350 ALLOCATED TOIEF237I 150 ALLOCATED TO SYSUT1IEF237I 151 ALLOCATED TO SYSPRINT F128-LEVEL LINKAGE EDITOR OPTIONS SPECIFIED LIST,XREF,LET { DEFAULT OPTION(S) USED - SIZE=(131072,18432) } { CROSS REFERENCE TABLE } { CONTROL SECTION ENTRY } { NAME ORIGIN LENGTH NAME LOCATION NAME LOCATION NAME LOCATION NAME LOCATION } { HELLO 00 308 } { ILBODSP0* 308 700 } { ILBOSTP0* A08 35 } { ILBOSTP1 A1E } { LOCATION REFERS TO SYMBOL IN CONTROL SECTION LOCATION REFERS TO SYMBOL IN CONTROL SECTION } { 260 ILBOSTP0 ILBOSTP0 264 ILBODSP0 ILBODSP0 } { 268 ILBOSTP1 ILBOSTP0 } { ENTRY ADDRESS 00 } { TOTAL LENGTH A40 } RUN DOES NOT EXIST BUT HAS BEEN ADDED TO DATA SET IEF142I - STEP WAS EXECUTED - COND CODE 0000IEF285I SYS84056.T093538.RV000.COBUCLG.LOADSET DELETEDIEF285I VOL SER NOS= WORK01.IEF285I SYS84056.T093538.RV000.COBUCLG.GODATA PASSEDIEF285I VOL SER NOS= WORK01.IEF285I SYS1.COBLIB KEPTIEF285I VOL SER NOS= MVTRES.IEF285I SYS1.LINKLIB KEPTIEF285I VOL SER NOS= MVTRES.IEF285I SYS84056.T093538.RV000.COBUCLG.R0000007 DELETEDIEF285I VOL SER NOS= SYSRES.IEF285I SYS84056.T093538.SV000.COBUCLG.R0000008 SYSOUTIEF285I VOL SER NOS= WORK01.IEF373I STEP /LKED / START 84056.0937IEF374I STEP /LKED / STOP 84056.0937 CPU 0MIN 00.04SEC MAIN 96K LCS 0KXXGO EXEC PGM=*.LKED.SYSLMOD,COND=((5,LT,COB),(5,LT,LKED)) 85000018//GO.SYSPRINT DD SYSOUT=A//IEF236I ALLOC. FOR COBUCLG GO HELOWRLDIEF237I 151 ALLOCATED TO PGM=*.DDIEF237I 352 ALLOCATED TO SYSPRINTHELLO, WORLDIEF142I - STEP WAS EXECUTED - COND CODE 0000IEF285I SYS84056.T093538.RV000.COBUCLG.GODATA PASSEDIEF285I VOL SER NOS= WORK01.IEF285I SYS84056.T093538.SV000.COBUCLG.R0000009 DELETEDIEF285I VOL SER NOS= WORK02.IEF373I STEP /GO / START 84056.0937IEF374I STEP /GO / STOP 84056.0937 CPU 0MIN 00.01SEC MAIN 8K LCS 0KIEF285I SYS84056.T093538.RV000.COBUCLG.GODATA DELETEDIEF285I VOL SER NOS= WORK01.IEF375I JOB /COBUCLG / START 84056.0937IEF376I JOB /COBUCLG / STOP 84056.0937 CPU 0MIN 00.13SEC [ Criticism and defense ] [ Lack of structurability ] In his letter to an editor in 1975 titled &quot; How do we tell truths that might hurt? &quot; which was critical of several programming languages contemporaneous with COBOL, computer scientist and Turing Award recipient Edsger Dijkstra remarked that &quot; The use of COBOL cripples the mind; its teaching should, therefore, be regarded as a criminal offense. &quot; [ http://www.cs.utexas.edu/users/EWD/transcriptions/EWD04xx/EWD498.html E. W. Dijkstra Archive: How do we tell truths that might hurt? (EWD498) August 29, 2007 University of Texas at Austin 2006 Dijkstra ] In his dissenting response to Dijkstra&apos;s article and the above &quot; offensive statement, &quot; computer scientist Howard E. Tompkins defended structured COBOL: &quot; COBOL programs with convoluted control flow indeed tend to &apos;cripple the mind&apos;, &quot; but this was because &quot; There are too many such business application programs written by programmers that have never had the benefit of structured COBOL taught well... &quot; { &quot; In Defense of Teaching Structured COBOL as Computer Science, &quot; Howard E. Tompkins, ACM SIGPLAN Notices, Vol. 18, Issue 4, April 1983. } Additionally, the introduction of OO-COBOL has added support for object-oriented code as well as user-defined functions and user-defined data types to COBOL&apos;s repertoire. [ Compatibility issues after standardization ] COBOL 85 was not fully compatible with earlier versions, resulting in the &quot; cesarean birth &quot; of COBOL 85. Joseph T. Brophy, CIO, Travelers Insurance, spearheaded an effort to inform users of COBOL of the heavy reprogramming costs of implementing the new standard. As a result the ANSI COBOL Committee received more than 3,200 letters from the public, mostly negative, requiring the committee to make changes. On the other hand, conversion to COBOL 85 was thought to increase productivity in future years, thus justifying the conversion costs. [ The COBOL 85 example book Jerome Garfunkel Wiley New York 1987 0-471-80461-4 ] [ Verbose syntax ] COBOL syntax has often been criticized for its verbosity. However, proponents note that this was intentional in the language design, and many consider it one of COBOL&apos;s strengths. One of the design goals of COBOL was that non-programmers—managers, supervisors, and users—could read and understand the code. This is why COBOL has an English-like syntax and structural elements—including: nouns, verbs, clauses, sentences, sections, and divisions. Consequently, COBOL is considered by at least one source to be &quot; The most readable, understandable and self-documenting programming language in use today. [...] Not only does this readability generally assist the maintenance process but the older a program gets the more valuable this readability becomes. &quot; { COBOL Tutorial - Introduction to COBOL } On the other hand, the mere ability to read and understand a few lines of COBOL code does not grant to an executive or end user the experience and knowledge needed to design, build, and maintain large software systems. [ Other defenses ] Additionally, traditional COBOL is a simple language with a limited scope of function (with no pointers, no user-defined types, and no user-defined functions), encouraging a straightforward coding style. This has made it well-suited to its primary domain of business computing—where the program complexity lies in the business rules that need to be encoded rather than sophisticated algorithms or data structures. And because the standard does not belong to any particular vendor, programs written in COBOL are highly portable. The language can be used on a wide variety of hardware platforms and operating systems. And the rigid hierarchical structure restricts the definition of external references to the Environment Division, which simplifies platform changes. [ See also ] Programming language genealogies Alphabetical list of programming languages Comparison of programming languages OpenCOBOL CODASYL [ References ] [ Sources ] Ebbinkhuijsen, Wim B.C., COBOL Alphen aan den Rijn/Diegem: Samson Bedrijfsinformatie bv, 1990. ISBN 90-14-04560-3. (Dutch) [ External links ] [ July 2010 ] Standards: COBOL Standard Committee Reference manuals: [ IBM ILE COBOL Programmer&apos;s Guide 6.8  MB ] [ IBM ILE COBOL Language Reference 7.0  MB ] [ OpenCOBOL Programmer&apos;s Guide 3.3  MB ] IBM Enterprise COBOL for z/OS V4R1 Bookshelf IBM VS COBOL II V1R4.0 Bookshelf IBM COBOL documentation (iSeries Information Center) IBM AIX compiler information center Compilers and other products: IBM COBOL compilers Elastic COBOL Cloud-based Elastic COBOL from Heirloom Computing allows application development and maintenance framework as well as deployment of applications onto an Enterprise Legacy Platform-as-a-Service. Fujitsu Fujitsu NetCOBOL, COBOL development, deployment and modernization. Micro Focus Micro Focus Visual COBOL, COBOL development, deployment and modernization. Veryant, affordable COBOL maintenance and modernization platform COBOL-IT, The Enterprise-Class Open Source COBOL Compiler Cobos, Open Source IDE for COBOL / Mainframe development Redvers Consulting, Open Source COBOL Tools OpenCOBOL, an open-source COBOL compiler. OpenCOBOL FAQ, and collection of code samples. TinyCOBOL, an open-source COBOL compiler based on the COBOL 85 standards SoftwareMining, COBOL Rule Extraction Toolkit. The Compilerator, Online COBOL compiler for small experiments Exhibitions: COBOL An online exhibition from the National Museum of American History, Smithsonian Institution Category:Object-oriented programming languages Category:.NET programming languages af:COBOL ar:كوبول az:Cobol bn:কোবোল bg:COBOL bs:COBOL ca:COBOL cs:COBOL da:COBOL de:COBOL et:COBOL el:COBOL es:COBOL eo:COBOL eu:COBOL fa:کوبول fr:COBOL ga:COBOL gl:Cobol ko:코볼 hr:COBOL id:COBOL ia:COBOL it:COBOL he:COBOL ka:კობოლი lt:COBOL hu:COBOL ml:കോബോൾ mr:कोबॉल ms:COBOL nl:COBOL ja:COBOL no:COBOL pl:COBOL pt:COBOL ro:Cobol ru:Кобол simple:COBOL sk:COBOL sl:COBOL sr:Кобол (програмски језик) sh:COBOL fi:COBOL sv:COBOL ta:கோபால் நிரலாக்க மொழி te:కోబాల్ th:ภาษาโคบอล tg:COBOL tr:COBOL uk:COBOL vi:COBOL yi:קאבאל zh:COBOL