[ 1982 ] { 6.5.0 } [ 2010 06 ] { Embedded system s } { Able to use Pkgsrc framework from NetBSD project } { Current } { Proprietary } QNX ( [ ˌ k juː _ ˌ ɛ n _ ˈ ɛ k s ] or [ ˈ k juː n ɨ k s ] ) is a commercial Unix-like real-time operating system, aimed primarily at the embedded system s market. The product was originally developed by Canadian company QNX Software Systems, which was later acquired by Research In Motion. [ Description ] As a microkernel -based OS, QNX is based on the idea of running most of the OS in the form of a number of small tasks, known as servers. This differs from the more traditional monolithic kernel, in which the operating system is a single very large program composed of a huge number of &quot; parts &quot; with special abilities. In the case of QNX, the use of a microkernel allows users (developers) to turn off any functionality they do not require without having to change the OS itself; instead, those servers are simply not run. The system is quite small, with earlier versions fitting on a single floppy disk. [ http://www.openqnx.com/Article259.html QNX4 Demo Disk: An Expounding Look 2004-03-24 2009-03-13 Samuel Sidler OpenQNX ] QNX Neutrino (2001) has been ported to a number of platforms and now runs on practically any modern CPU that is used in the embedded market. This includes the PowerPC, x86 family, MIPS, SH-4 and the closely related family of ARM, StrongARM and XScale CPUs. As of September 12, 2007, QNX offers a license for non-commercial users. The BlackBerry PlayBook tablet computer designed by Research In Motion uses a version of QNX as the primary operating system. [ History ] Gordon Bell and Dan Dodge, students at the University of Waterloo in 1980, both took a standard computer science course in operating system design, in which the students constructed a basic real-time kernel. Both were convinced there was a commercial need for such a system, and moved to Kanata, Ontario (a high-tech area then to the west of Ottawa and now amalgamated into that city) to start Quantum Software Systems that year. In 1982 the first version of QNX was released for the Intel 8088 CPU. One of first widespread uses of the QNX real-time OS (RTOS) was in the non-embedded world, when it was selected as the operating system for the Ontario education system&apos;s own computer design, the Unisys ICON. Over the years QNX was used mostly for &quot; larger &quot; projects, as its 44k kernel was too large to fit inside the single-chip computers of the era. The system garnered a reputation for reliability and found itself in use running machinery in a number of industrial applications. In the late-1980s, Quantum realized that the market was rapidly moving towards the POSIX model and decided to rewrite the kernel to be much more compatible at a lower level. The result was QNX 4. During this time Patrick Hayden, while working as an intern, along with Robin Burgener (a full time employee at the time), developed a new concept for a [ 5745759 windowing system ]. This patented concept was developed into the embeddable GUI named the QNX Photon microGUI. QNX also provided a version of the X Window System. Due to the POSIX interface, porting Unix and BSD packages to QNX became much easier. Toward the end of the 1990s, the company (now called QNX Software Systems) began work on a completely new version of the QNX RTOS, designed from the ground up to be SMP capable, and to support all current POSIX API s and any new POSIX APIs that could be anticipated while still retaining the microkernel architecture. This resulted in the QNX Neutrino RTOS, which was released in 2001. Along with the Neutrino kernel, QNX Software Systems made a serious commitment to tooling, and became a founding member of the Eclipse consortium. The company released a suite of Eclipse plug-ins packaged with the Eclipse workbench in 2002 under the name QNX Momentics Tool Suite. In 2004 the company announced it had been sold to Harman International Industries. Prior to this acquisition, QNX software was already widely used in the automotive industry for telematics systems. Since the purchase by Harman, QNX software has been designed into over 200 different automobile makes and models  — not only in telematics systems but in infotainment and navigation units as well. The QNX CAR Application Platform is running in over 20 million vehicles as of mid-2011 { QNX CAR http://www.qnx.com/products/qnxcar/ }. The company has since released several middleware products including the QNX Aviage Multimedia Suite, the QNX Aviage Acoustic Processing Suite and the QNX HMI Suite. In September 2007 QNX Software Systems announced the availability of some of its source code. { QNX Press Releases: source code availability } On April 9, 2010, Research In Motion announced they would acquire QNX Software Systems from Harman International Industries. [ http://www.theglobeandmail.com/news/technology/rim-to-buy-qnx-software/article1528911/ RIM to buy QNX Software The Canadian Press The Globe and Mail 9 April 2010 2010-04-09 ] On the same day, QNX source code access was restricted. { http://community.qnx.com/sf/wiki/do/viewPage/projects.community/wiki/UpdatedQNXSourceAccessPolicyFAQ } In September, 2010, the company announced a tablet computer, the BlackBerry PlayBook, and a new operating system BlackBerry Tablet OS based on QNX to run on the tablet. { RIM Unveils The BlackBerry PlayBook, official press release, September 27, 2010 } Cisco &apos;s IOS-XR (ultra high availability IOS) built about 2004-2005 [ http://www.qnx.com/news/pr_1074_1.html QNX Delivers Extremely Reliable Microkernel for Massively Scalable Routing System QNX Staff 2004-08-17 2012-03-16 ] is based on QNX software, { CRS-1 and IOS XR Operational Best Practices } as is IOS Software Modularity introduced in 2006. [ http://www.velocityreviews.com/forums/t372212-which-os-is-behind-ios.html Which OS is behind IOS? Brad Reese- BradReese.Com 2006-09-26 2012-03-16\ ] [ Technology ] The QNX kernel contains only CPU scheduling, interprocess communication, interrupt redirection and timers. Everything else runs as a user process, including a special process known as proc which performs process creation, and memory management by operating in conjunction with the microkernel. This is made possible by two key mechanisms  — subroutine-call type interprocess communication, and a boot loader which can load an image containing not only the kernel but any desired collection of user programs and shared libraries. There are no device drivers in the kernel. The network stack is based on NetBSD code. { Core Networking 6.4: Neutrino’s Next Gen Networking Stack and Foundry27 } Along with its support for its own, native, device drivers, QNX supports its legacy, io-net manager server, and the network drivers ported from NetBSD. { Foundry27: Project Networking - Driver wiki page } QNX interprocess communication consists of sending a message from one process to another and waiting for a reply. This is a single operation, called MsgSend. The message is copied, by the kernel, from the address space of the sending process to that of the receiving process. If the receiving process is waiting for the message, control of the CPU is transferred at the same time, without a pass through the CPU scheduler. Thus, sending a message to another process and waiting for a reply does not result in &quot; losing one&apos;s turn &quot; for the CPU. This tight integration between message passing and CPU scheduling is one of the key mechanisms that makes QNX message passing broadly usable. Most Unix and Linux interprocess communication mechanisms lack this tight integration, although an implementation of QNX-type messaging for Linux does exist. Mishandling of this subtle issue is a primary reason for the disappointing performance of some other microkernel systems such as early versions of Mach. [ January 2012 ] Due to the microkernel architecture QNX is also a distributed operating system. Dan Dodge and Peter van der Veen hold US patent 6,697,876 based on the QNX operating system&apos;s distributed processing features known commercially as Transparent Distributed Processing. All I/O operations, file system operations, and network operations were meant to work through this mechanism, and the data transferred was copied during message passing. Later versions of QNX reduce the number of separate processes and integrate the network stack and other function blocks into single applications for performance reasons. Message handling is prioritized by thread priority. Since I/O requests are performed using message passing, high priority threads receive I/O service before low priority threads, an essential feature in a hard real-time system. The boot loader, although seldom discussed, is the other key component of the minimal microkernel system. Because user programs can be built into the boot image, the set of device drivers and support libraries needed for startup need not be, and are not, in the kernel. Even such functions as program loading are not in the kernel, but instead are in shared user-space libraries loaded as part of the boot image. It is possible to put an entire boot image into ROM, which is used for diskless embedded systems. Neutrino supports symmetric multiprocessing and processor affinity, called bound multiprocessing (BMP) in QNX terminology. BMP is used to improve cache hitting and to ease the migration of non-SMP safe applications to multi-processor computers. Neutrino supports strict priority-preemptive scheduling and adaptive partition scheduling (APS). APS guarantees minimum CPU percentages to selected groups of threads, even though others may have higher priority. The adaptive partition scheduler is still strictly priority-preemptive when the system is underloaded. It can also be configured to run a selected set of critical threads strictly realtime, even when the system is overloaded. [ Transparent Distributed Processing ] Transparent Distributed Processing, or TDP, is the name that the QNX operating system uses to refer to its network distributed architecture. Since QNX is a microkernel it is inherently network distributable, so TDP actually boils down to a protocol module that plugs in to the QNX networking stack. This protocol module (known as qnet) links the microkernel s across the network together, so that operating system services are accessed using exactly the same mechanism without regard to the computer node on which they reside. TDP is covered by U.S. Patent 5,745,759. [ Foundry27 ] Foundry27 is a web-based QNX community established by the company. It serves as a hub to QNX Neutrino development where developers can register, choose the license, and get the source code and related toolkit of the RTOS. { QNX Press Releases: Foundry27 } As of April 9th 2010 (after the acquisition by RIM), the full QNX source code is no longer available to hobbyists or to the general public. { Updated QNX Source Access Policy FAQ: } [ See also ] Comparison of operating systems [ References ] [ Further reading ] [ Dan Hildebrand An Architectural Overview of QNX Proceedings of the Workshop on Micro-kernels and Other Kernel Architectures 1992 http://portal.acm.org/citation.cfm?id%3D759105%26amp%3Bdl%3DACM%26amp%3Bcoll%3D%26amp%3BCFID%3D15151515%26amp%3BCFTOKEN%3D6184618 113–126 1-880446-42-1 ] [ External links ] QNX Software Foundry27 QNX User Community Open source applications GUIdebook &gt; GUIs &gt; QNX QNX used for Canadian Nuclear Power Plants QOR: Russian QNX Portal QNX demo floppy disc Knowledge base of CBD BC QNX-Russia conference Development Tips &amp; Tricks SWD Software (QNX in Russia) QNX in Poland Category:Computing platforms Category:Real-time operating systems Category:Embedded operating systems Category:Companies based in Ottawa Category:Microkernels Category:Lightweight Unix-like systems Category:Research In Motion Category:Microkernel-based operating systems Category:Mobile operating systems ar:كيو إن إكس ca:QNX cs:QNX de:QNX es:QNX fa:کیوان‌اکس fr:QNX ko:QNX ilo:QNX it:QNX lt:QNX hu:QNX nl:QNX ja:QNX no:QNX pl:QNX pt:QNX ru:QNX sk:QNX fi:QNX sv:QNX (operativsystem) uk:QNX zh:QNX