[ June 2010 ] Template metaprogramming is a metaprogramming technique in which templates are used by a compiler to generate temporary source code, which is merged by the compiler with the rest of the source code and then compiled. The output of these templates include compile-time constants, data structures, and complete functions. The use of templates can be thought of as compile-time execution. The technique is used by a number of languages, the best-known being C++, but also Curl, D, and XL. Template metaprogramming was, in a sense, discovered accidentally: see History of TMP. Some other languages support similar, if not more powerful compile-time facilities (such as Lisp macros ), but those are outside the scope of this article. [ Components of template metaprogramming ] The use of templates as a metaprogramming technique requires two distinct operations: a template must be defined, and a defined template must be instantiated. The template definition describes the generic form of the generated source code, and the instantiation causes a specific set of source code to be generated from the generic form in the template. Template metaprogramming is generally Turing-complete, meaning that any computation expressible by a computer program can be computed, in some form, by a template metaprogram. Templates are different from macros. A macro, which is also a compile-time language feature, generates code in-line using text manipulation and substitution. Macro systems often have limited compile-time process flow abilities and usually lack awareness of the semantics and type system of their companion language (an exception should be made with Lisp &apos;s macros, which are written in Lisp itself and involve manipulation and substitution of Lisp code represented as data structures as opposed to text). Template metaprograms have no mutable variables — that is, no variable can change value once it has been initialized, therefore template metaprogramming can be seen as a form of functional programming. In fact many template implementations only implement flow control through recursion, as seen in the example below. [ Using template metaprogramming ] Though the syntax of template metaprogramming is usually very different from the programming language it is used with, it has practical uses. Some common reasons to use templates are to implement generic programming (avoiding sections of code which are similar except for some minor variations) or to perform automatic compile-time optimization such as doing something once at compile time rather than every time the program is run — for instance, by having the compiler unroll loops to eliminate jumps and loop count decrements whenever the program is executed. [ Compile-time class generation ] What exactly &quot; programming at compile-time &quot; means can be illustrated with an example of a factorial function, which in non-template C++ can be written using recursion as follows: constexpr unsigned int factorial(unsigned int n) { { return (n==0)? 1 : n * factorial(n-1); } } const int x = factorial(4); // == (4 * 3 * 2 * 1 * 1) == 24const int y = factorial(0); // == 0! == 1 The code above will execute at run time to determine the factorial value of the literals 4 and 0. By using template metaprogramming and template specialization to provide the ending condition for the recursion, the factorials used in the program, ignoring any factorial not used, can be calculated at compile time by this code: template &lt; int N &gt; struct Factorial { { enum { value = N * Factorial &lt; N - 1 &gt; ::value }; } }; template &lt; &gt; struct Factorial &lt; 0 &gt; { { enum { value = 1 }; } }; // Factorial &lt; 4 &gt; ::value == 24// Factorial &lt; 0 &gt; ::value == 1const int x = Factorial &lt; 4 &gt; ::value; // == 24const int y = Factorial &lt; 0 &gt; ::value; // == 1 The code above calculates the factorial value of the literals 4 and 0 at compile time and uses the result as if they were precalculated constants. To be able to use templates in this manner, the compiler must know the value of its parameters at compile time, which has the natural precondition that &lt; code &gt; Factorial &lt; &lt; /code &gt; X &gt; ::value can only be used if X is known at compile time. In other words, X must be a constant literal or a constant expression. [ Compile-time code optimization ] The factorial example above is one example of compile-time code optimization in that all factorials used by the program are pre-compiled and injected as numeric constants at compilation, saving both run-time overhead and memory footprint. It is, however, a relatively minor optimization. As another, more significant, example of compile-time loop-unrolling, template metaprogramming can be used to create length-n vector classes (where n is known at compile time). The benefit over a more traditional length-n vector is that the loops can be unrolled, resulting in very optimized code. As an example, consider the addition operator. A length-n vector addition might be written as template &lt; int length &gt; Vector &lt; length &gt; &amp; Vector &lt; length &gt; ::operator+=(const Vector &lt; length &gt; &amp; rhs) { { for (int i = 0; i &lt; length; ++i) } { value[i] += rhs.value[i]; } { return *this; } } When the compiler instantiates the function template defined above, the following code may be produced: template &lt; &gt; Vector &lt; 2 &gt; &amp; Vector &lt; 2 &gt; ::operator+=(const Vector &lt; 2 &gt; &amp; rhs) { { value[0] += rhs.value[0]; } { value[1] += rhs.value[1]; } { return *this; } } The compiler&apos;s optimizer should be able to unroll the for loop because the template parameter length is a constant at compile time. However, take caution as this may cause code bloat as separate unrolled code will be generated for each &apos;N&apos;(vector size) you instantiate with. [ Static polymorphism ] Polymorphism is a common standard programming facility where derived objects can be used as instances of their base object but where the derived objects&apos; methods will be invoked, as in this code class Base{public: { virtual void method() { std::cout &lt; &lt; &quot; Base &quot;; } } { virtual ~Base() {} } }; class Derived : public Base{public: { virtual void method() { std::cout &lt; &lt; &quot; Derived &quot;; } } }; int main(){ { Base *pBase = new Derived; } { pBase- &gt; method(); //outputs &quot; Derived &quot; } { delete pBase; } { return 0; } } where all invocations of virtual methods will be those of the most-derived class. This dynamically polymorphic behaviour is (typically) obtained by the creation of virtual look-up table s for classes with virtual methods, tables that are traversed at run time to identify the method to be invoked. Thus, run-time polymorphism necessarily entails execution overhead (though on modern architectures the overhead is negligible). However, in many cases the polymorphic behaviour needed is invariant and can be determined at compile time. Then the Curiously Recurring Template Pattern (CRTP) can be used to achieve static polymorphism, which is an imitation of polymorphism in programming code but which is resolved at compile time and thus does away with run-time virtual-table lookups. For example: template &lt; class Derived &gt; struct base{ { void interface() } { { } { //... } { static_cast &lt; Derived* &gt; (this)- &gt; implementation(); } { //... } { } } }; struct derived : base &lt; derived &gt; { { void implementation(); } }; Here the base class template will take advantage of the fact that member function bodies are not instantiated until after their declarations, and it will use members of the derived class within its own member functions, via the use of a static_cast, thus at compilation generating an object composition with polymorphic characteristics. As an example of real-world usage, the CRTP is used in the Boost iterator library. Another similar use is the &quot; Barton–Nackman trick &quot;, sometimes referred to as &quot; restricted template expansion &quot;, where common functionality can be placed in a base class that is used not as a contract but as a necessary component to enforce conformant behaviour while minimising code redundancy. [ Benefits and drawbacks of template metaprogramming ] Compile-time versus execution-time tradeoff: If a great deal of template metaprogramming is used, compilation may become slow; section 14.7.1 [temp.inst] of the current standard defines the circumstances under which templates are implicitly instantiated. As with most aspects of C++, you pay only for what you use: defining a template does not imply that it will be instantiated, and instantiating a class template does not cause its member definitions to be instantiated. Depending on the style of use, templates may compile either faster or slower than hand-rolled code. Generic programming : Template metaprogramming allows the programmer to focus on architecture and delegate to the compiler the generation of any implementation required by client code. Thus, template metaprogramming can accomplish truly generic code, facilitating code minimization and better maintainability. Readability: With respect to C++, the syntax and idioms of template metaprogramming are esoteric compared to conventional C++ programming, and template metaprograms can be very difficult to understand. Metaprograms can thus be difficult to maintain by programmers inexperienced in template metaprogramming (though this may vary with the language&apos;s implementation of template metaprogramming syntax). On the other hand, template metaprogramming can often be used to make programs much shorter and simpler, and thus more readable. [ See also ] Metaprogramming Preprocessor Parametric polymorphism Variadic Templates Compile time function execution [ References ] Ulrich W. Eisenecker : Generative Programming: Methods, Tools, and Applications, Addison-Wesley, ISBN 0-201-30977-7 Andrei Alexandrescu : Modern C++ Design : Generic Programming and Design Patterns Applied, Addison-Wesley, ISBN 3-8266-1347-3 David Abrahams, Aleksey Gurtovoy : C++ Template Metaprogramming: Concepts, Tools, and Techniques from Boost and Beyond, Addison-Wesley, ISBN 0-321-22725-5 David Vandervoorde, Nicolai M. Josuttis : C++ Templates: The Complete Guide, Addison-Wesley, ISBN 0-201-73484-2 Manuel Clavel : Reflection in Rewriting Logic: Metalogical Foundations and Metaprogramming Applications, ISBN 1-57586-238-7 [ External links ] The Boost Metaprogramming Library (Boost MPL) The Spirit Library (built using template-metaprogramming) The Boost Lambda library (use STL algorithms easily) &quot; Using C++ template metaprograms, &quot; C++ Report, Vol. 7 No. 4 (May 1995), pp.  36–43 by Todd Veldhuizen Template Haskell, type-safe metaprogramming in Haskell Walter Bright, &quot; Templates Revisited &quot;, an article on template metaprogramming in the D programming language. &quot; Metaprogramming in C++ &quot; by Johannes Koskinen &quot; Reflection support by means of template metaprogramming &quot; by Giuseppe Attardi, Antonio Cisternino &quot; STATIC DATA STRUCTURES &quot; by Michael C. Burton, William G. Griswold, Andrew D. McCulloch, Gary A. Huber Article &quot; Template Meta Programming and Number Theory &quot; by Zeeshan Amjad Article &quot; Template Meta Programming and Number Theory: Part 2 &quot; by Zeeshan Amjad A library for LISP-style programming in C++ Category:Computer programming Category:C++ Category:Articles with example C++ code de:C++-Metaprogrammierung et:Mall (programmeerimine) fr:Métaprogrammation avec des patrons ko:템플릿 메타프로그래밍 nl:Template (software) ja:テンプレートメタプログラミング tr:Şablon Meta Programlama zh:模板超編程