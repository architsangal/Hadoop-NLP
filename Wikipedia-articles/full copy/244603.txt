In software engineering, a spinlock is a lock where the thread simply waits in a loop ( &quot; spins &quot; ) repeatedly checking until the lock becomes available. Since the thread remains active but isn&apos;t performing a useful task, the use of such a lock is a kind of busy waiting. Once acquired, spinlocks will usually be held until they are explicitly released, although in some implementations they may be automatically released if the thread being waited on (that which holds the lock) blocks, or &quot; goes to sleep &quot;. Spinlocks are efficient if thread s are only likely to be blocked for a short period, as they avoid overhead from operating system process re-scheduling or context switch ing. For this reason, spinlocks are often used inside operating system kernel s. However, spinlocks become wasteful if held for longer durations, preventing other threads from running and requiring re-scheduling. The longer a lock is held by a thread, the greater the risk that it will be interrupted by the OS scheduler while holding the lock. If this happens, other threads will be left &quot; spinning &quot; (repeatedly trying to acquire the lock), while the thread holding the lock is not making progress towards releasing it. The result is an indefinite postponement until the thread holding the lock can finish and release it. This is especially true on a single-processor system, where each waiting thread of the same priority is likely to waste its quantum (allocated time where a thread can run) spinning until the thread that holds the lock is finally finished. Implementing spin locks correctly is difficult because one must take into account the possibility of simultaneous access to the lock to prevent race condition s. Generally this is only possible with special assembly language instructions, such as atomic test-and-set operations, and cannot be easily implemented in high-level programming language s or those languages which don&apos;t support truly atomic operations. [ Silberschatz Abraham Galvin, Peter B. Operating System Concepts Fourth Edition 1994 Addison-Wesley 176–179 0-201-59292-4 ] On architectures without such operations, or if high-level language implementation is required, a non-atomic locking algorithm may be used, e.g. Peterson&apos;s algorithm. But note that such an implementation may require more memory than a spinlock, be slower to allow progress after unlocking, and may not be implementable in a high-level language if out-of-order execution is allowed. [ Example implementation ] The following example uses x86 assembly language to implement a spinlock. It will work on any Intel 80386 compatible processor. Intel syntax lock:; The lock variable. 1 = locked, 0 = unlocked. { dd 0 } spin_lock: { mov eax, 1; Set the EAX register to 1. } { xchg eax, [lock]; Atomically swap the EAX register with } {; the lock variable. } {; This will always store 1 to the lock, leaving } {; previous value in the EAX register. } { test eax, eax; Test EAX with itself. Among other things, this will } {; set the processor&apos;s Zero Flag if EAX is 0. } {; If EAX is 0, then the lock was unlocked and } {; we just locked it. } {; Otherwise, EAX is 1 and we didn&apos;t acquire the lock. } { jnz spin_lock; Jump back to the MOV instruction if the Zero Flag is } {; not set; the lock was previously locked, and so } {; we need to spin until it becomes unlocked. } { ret; The lock has been acquired, return to the calling } {; function. } spin_unlock: { mov eax, 0; Set the EAX register to 0. } { xchg eax, [lock]; Atomically swap the EAX register with } {; the lock variable. } { ret; The lock has been released. } [ Significant optimizations ] Programmers familiar with x86 assembly language can readily understand the simple implementation above, which works on all CPUs using the x86 architecture. However a number of performance optimizations are possible: On later implementations of the x86 architecture, spin_unlock can safely use an unlocked MOV instead of the slower locked XCHG. This is due to subtle memory ordering rules which support this, even though MOV isn&apos;t a full memory barrier. However some processors (some Cyrix processors, some revisions of the Intel Pentium Pro (due to bugs), and earlier Pentium and i486 SMP systems) will do the wrong thing and data protected by the lock could be corrupted. On most non-x86 architectures, explicit memory barrier instructions or atomic instructions (as in the example) must be used, or there may be special &quot; unlock &quot; instructions (as on IA-64 ) which provide the needed memory ordering. To reduce inter-CPU bus traffic, when the lock is not acquired, the code should loop reading without trying to write anything, until it reads a changed value. Because of MESI caching protocols, this causes the cache line for the lock to become &quot; Shared &quot;; then there is remarkably no bus traffic while a CPU waits for the lock. This optimization is effective on all CPU architectures that have a cache per CPU, because MESI is so widespread. [ Alternatives ] The primary disadvantage of a spinlock is that it wastes time while waiting to acquire the lock that might be productively spent elsewhere. There are two alternatives that avoid this: Do not acquire the lock. In many situations it is possible to design data structures that do not require locking, e.g. by using per thread data, or by using per-cpu data and disabling interrupts. Switch to a different thread while waiting (sometimes called sleeplock s ). This typically involves attaching the current thread to a queue of threads waiting for the lock, followed by switching to another thread that is ready to do some useful work. This scheme also has the advantage that it guarantees that resource starvation does not occur as long as all threads eventually relinquish locks they acquire and scheduling decisions can be made about which thread should progress first. Most operating systems (including Solaris, Mac OS X and FreeBSD ) use a hybrid approach called &quot; adaptive mutex &quot;. The idea is to use a spinlock when trying to access a resource locked by a currently-running thread, but to sleep if the thread is not currently running. (The latter is always the case on single-processor systems.) [ Silberschatz Abraham Galvin, Peter B. Operating System Concepts Fourth Edition 1994 Addison-Wesley 198 0-201-59292-4 ] [ Other Meanings ] In a military context, the term &quot; spin lock &quot; can be used to refer to a mechanism within a munition&apos;s fuze which arms it upon firing. Implemented on gun-launched ammunition, the rotation imparted on the projectile causes the lock to disengage from a &quot; safe &quot; condition to an &quot; armed &quot; one. [ See also ] synchronization Busy spin deadlock seqlock ticket lock [ References ] [ External links ] pthread_spin_lock documentation from The Open Group Base Specifications Issue 6, IEEE Std 1003.1, 2004 Edition Article &quot; User-Level Spin Locks - Threads, Processes &amp; IPC &quot; by Gert Boddaert Paper &quot; The Performance of Spin Lock Alternatives for Shared-Memory Multiprocessors &quot; by Thomas Anderson Paper &quot; Algorithms for Scalable Synchronization on Shared-Memory Multiprocessors &quot; by John M. Mellor-Crummey and Michael L. Scott. This paper received the 2006 Dijkstra Prize in Distributed Computing. Spin-Wait Lock by Jeffrey Richter Austria C++ SpinLock Class Reference Interlocked Variable Access(Windows) Category:Concurrency control algorithms Category:Programming constructs cs:Spinlock de:Spinlock es:Spinlock fr:Spinlock it:Spinlock lt:Suktukinis rakinimas nl:Busy waiting ja:スピンロック pl:Spinlock ru:Spinlock