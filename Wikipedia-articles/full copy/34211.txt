[ XSLT.xsl,.xslt application/xslt+xml XSL Transformations (XSLT) Version 2.0 World Wide Web Consortium 200px Stylesheet language XML 1.0 (Recommendation), 2.0 (Recommendation), 2.1 (Working Draft) ] [ XSL Transformations Published 1997 James Clark (1.0), Michael Kay (2.0) XML XSL, XSL-FO, XPath XSLT XML transformation ] XSLT (Extensible Stylesheet Language Transformations) is a declarative, XML -based language used for the transformation of XML documents. The original document is not changed; rather, a new document is created based on the content of an existing one. { XSL Transformations (XSLT) } The new document may be serialized (output) by the processor in standard XML syntax or in another format, such as HTML or plain text. { See e.  g., http://www.w3.org/TR/xslt#output, specifying alternate output methods. } XSLT is most often used to convert data between different XML schema s or to convert XML data into web page s or PDF documents. [ Application ] Applications often use XSLT to convert XML data into HTML or XHTML documents for display as a web page. The transformation may happen dynamically either on a client or on a server, or it may be done as part of the publishing process. It is also used to create output for printing or direct video display, typically by transforming the original XML into XSL Formatting Objects to create formatted output which can then be converted to a variety of formats, including PDF, PostScript and PNG. XSLT can also translate XML messages between different XML schema s, or make changes to documents within the scope of a single schema, for example by removing the parts of a message that are not needed. [ Origins ] XSLT is developed by the World Wide Web Consortium (W3C). The most recent version is XSLT 2.0, { http://www.w3.org/TR/xslt20/ } which reached W3C recommendation status on 23 January 2007. [ http://www.dblab.ntua.gr/~bikakis/XML%20and%20Semantic%20Web%20W3C%20Standards%20Timeline-History.pdf XML and Semantic Web W3C Standards Timeline 2012-02-04 ] As of 2010, however, XSLT 1.0 { http://www.w3.org/TR/xslt } is still widely used, as there are no products that support XSLT 2.0 running in the browser, nor on some important server environments such as LAMP. Originally, XSLT was part of the W3C&apos;s Extensible Stylesheet Language (XSL) development effort of 1998–1999, a project that also produced XSL Formatting Objects and the XML Path Language, XPath. The editor of the first version was James Clark. XSLT 1.0 was published as a Recommendation by the W3C on 16 November 1999. After an abortive attempt to create a version 1.1 in 2001, { http://www.w3.org/TR/xslt11/ } the XSL working group joined forces with the XQuery working group to create XPath 2.0, { http://www.w3.org/TR/xpath20/ } with a richer data model and type system based on XML Schema. XSLT 2.0, developed under the editorship of Michael Kay, was built on this foundation in 2002–2006. As a language, XSLT is influenced by functional languages, [ http://conferences.idealliance.org/extreme/html/2006/Novatchev01/EML2006Novatchev01.html Dimitre Novatchev Higher-Order Functional Programming with XSLT 2.0 and FXSL August 8, 2009 ExtremeMarkupLanguages ] and by text-based pattern matching languages in the tradition of SNOBOL and awk. Its most direct predecessor was ISO DSSSL, a language that performed the same function for full SGML that XSLT performs for XML { http://www.w3.org/TR/NOTE-XSL.html } (Some members of the standards committee that developed XSLT, including James Clark, had previously worked on DSSSL.) Unlike DSSSL, however, XSLT code uses the syntax of its target language, XML, which means that it can also be viewed as a Turing-complete { Kepser, Stephan. (2004). } { A Simple Proof for the Turing-Completeness of XSLT and XQuery &apos;&apos;. International Digital Enterprise Alliance. } { Universal Turing Machine in XSLT } { www.refal.net/~korlukov/tm/ } template processor. Most of this article is applicable to both XSLT versions; any differences are noted in the text. [ Concept ] [ Overview ] Diagram of the basic elements and process flow of Extensible Stylesheet Language Transformations. The XSLT processing model involves: one or more XML source documents; one or more XSLT stylesheet modules; the XSLT template processing engine (the processor); and one or more result documents. The XSLT processor ordinarily takes two input documents { Typically, documents are XML files, but the specifications avoid excluding other representations, such as in-memory } { DOM trees or other conforming input streams. } —an XML source document, and an XSLT stylesheet—and produces an output document. The XSLT stylesheet contains a collection of template rules: instructions and other directives that guide the processor in the production of the output document. [ Template rule processing ] The XSLT language is declarative: [ Discover the Wonders of XSLT: XSLT Quirks http://www.developer.com/xml/article.php/3357231#Coding%20styles XSLT is a very specialized language with a distinct declarative flavor. ] rather than listing an imperative sequence of actions to perform in a stateful environment, template rules only define how to handle a node matching a particular XPath-like pattern, if the processor should happen to encounter one, and the contents of the templates effectively comprise functional expressions that directly represent their evaluated form: the result tree, which is the basis of the processor&apos;s output. The processor follows a fixed algorithm: [ XSLT Definitions http://microsoftechies.wordpress.com/2010/09/16/xslt-definitions/ XSLT declarations define a set of rules and guidelines that are applied during processing according to a predefined algorithm. ] assuming a stylesheet has already been read and prepared, the processor builds a source tree from the input XML document. It then starts by processing the source tree&apos;s root node, finding in the stylesheet the best-matching template for that node, and evaluating the template&apos;s contents. Instructions in each template generally direct the processor to either create nodes in the result tree, or process more nodes in the source tree in the same way as the root node. Output is derived from the result tree. [ Processor implementations ] XSLT processor implementations fall into two main categories: client-side and server-side. Client-side XSLT adoption has been slow due to widespread deployment of older (or alternative) browsers without XSLT support. For similar reasons, adoption of XSLT 2.0 in such environments remains limited. (See Comparison of layout engines (XML)#XSL technologies ). Nevertheless, early adopters included Microsoft Internet Explorer 6 (since 2001) and Netscape 7 (since 2002). Earlier still, Internet Explorer 5 supported XSLT’s draft specification since 1999 or earlier, although it was incompatible with the final W3C specification. Netscape 6 included partial support since 2000. [ https://developer.mozilla.org/en/XSLT_in_Gecko/Browser_Differences XSLT in Gecko / Browser Differences Mozilla Developer Center 2007-01-21 2009-10-25 ] Server-side XSLT processors (a somewhat misleading term, as they don’t require a server to function; the name is intended to contrast with “client-side”) exist as both standalone products and components of other software. This includes web browsers, application servers, frameworks (such as Java and.NET), or even operating systems. For example, Windows XP ’s MSXML3 library includes an XSLT 1.0 processor. The GNOME desktop environment 2 includes libxslt, an open source implementation with complete support for the XSLT 1.0 specification. [ http://library.gnome.org/misc/release-notes/2.0/#libxml GNOME 2.0 Release Notes  – XML The GNOME Project 2002-06-26 2009-10-25 ] [ http://xmlsoft.org/XSLT/ The XSLT C library for GNOME  – libxslt 2009-10-25 ] The libxslt library is also used by other software, such as WebKit. [ http://webkit.org/projects/xslt/index.html The WebKit Open Source Project  – XSLT 2009-10-25 ] Other examples include Apache’s Xalan [ http://xalan.apache.org/ The Apache Xalan Project 2009-10-25 ] and Saxon XSLT (which supports XSLT 2.0 as well). [ Performance ] Most early XSLT processors were interpreters. More recently, code generation is increasingly common, using portable intermediate languages (such as Java bytecode or.NET Common Intermediate Language) as the target. However, even the interpretive products generally offer separate analysis and execution phases, allowing an optimized expression tree to be created in memory and reused to perform multiple transformations. This gives substantial performance benefits in online publishing applications, where the same transformation is applied many times per second to different source documents. { Saxon: Anatomy of an XSLT processor - Article describing implementation &amp; amp; optimization details of a popular XSLT processor. } This separation is reflected in the design of XSLT processing APIs (such as JAXP ). Early XSLT processors had very few optimizations. Stylesheet documents were read into Document Object Model s and the processor would act on them directly. XPath engines were also not optimized. Increasingly, however, XSLT processors use optimization techniques found in functional programming languages and database query languages, such as static rewriting of an expression tree (e.g., to move calculations out of loops), and lazy pipelined evaluation to reduce the memory footprint of intermediate results (and allow &quot; early exit &quot; when the processor can evaluate an expression such as following-sibling::*[1] without a complete evaluation of all subexpressions). Many processors also use tree representations that are significantly more efficient (in both space and time) than general-purpose DOM implementations. [ XSLT and Streaming ] XSLT 1.0 and XSLT 2.0 were not designed to allow XML Streaming of the input to output. The whole input document had to be read into memory before it could be processed. [ Kay Michael A Streaming XSLT Processor http://www.balisage.net/Proceedings/vol5/html/Kay01/BalisageVol5-Kay01.html Balisage: The Markup Conference 2010 Proceedings 15 February 2012 ] Future implementations, like XSLT 3.0, may allow XML streaming, to reduce latency between the input and the output. It is especially important when transformations are chained together in XML Pipelines, for example in XProc. [ XSLT and XPath ] [ XPath ] XSLT relies upon the W3C&apos;s XPath language for identifying subsets of the source document tree, as well as for performing calculations. XPath also provides a range of functions, which XSLT itself further augments. This reliance upon XPath adds a great deal of power and flexibility to XSLT. XSLT 1.0 uses XPath 1.0. Similarly, XSLT 2.0 relies on XPath 2.0; both specifications were published on the same date. [ XSLT and XQuery compared ] [ XQuery#XQuery and XSLT compared ] XSLT capabilities overlap with XQuery, which was initially conceived as a query language for large collections of XML documents. The XSLT 2.0 and XQuery 1.0 standards were developed by separate working groups within W3C, working together to ensure a common approach where appropriate. They share the same data model, type system, and function library, and both include XPath 2.0 as a sublanguage. The two languages, however, are rooted in different traditions and serve the needs of different communities. XSLT was primarily conceived as a stylesheet language whose primary goal was to render XML for the human reader on screen, on the web (as web template language ), or on paper. XQuery was primarily conceived as a database query language in the tradition of SQL. Because the two languages originate in different communities, XSLT is stronger in its handlingof narrative documents with more flexible structure, while XQuery is stronger in its data handling, for example when performing relational joins. [ July 2009 ] [ XSLT media types ] [ section November 2010 ] As of 2009, there is no MIME/Internet media type registered for XSLT. The XSLT 1.0 Recommendation (1999) says &quot; The MIME media types text/xml and application/xml should be used for XSLT stylesheets. It is possible that a media type will be registered specifically for XSLT stylesheets; if and when it is, that media type may also be used. &quot; It goes on to use text/xml in an example of how to embed a stylesheet with the xml-stylesheet processing instruction. RFC 3023 points out potential technical problems with text/* types in general, and proposes application/xslt+xml as an ideal media type for XSLT. The XSLT 2.0 Recommendation (January 2007) includes a formal application to register this media type. However, at the time of writing (January 2009) the process of registration has not yet been completed, and RFC 3023 warns that &quot;... this media type should not be used until such registration has been completed. &quot; Pre-1.0 working drafts of XSLT used text/xsl in their embedding examples, and this type was implemented and continues to be promoted by Microsoft in Internet Explorer and MSXML. It is also widely recognized in the xml-stylesheet processing instruction by other browsers. In practice, therefore, users wanting to control transformation in the browser using this processing instruction are obliged to use this unregistered media type. [ Kay Michael XSLT 2.0 and XPath 2.0 Programmer&apos;s Reference 2008 Wiley 978-0-470-19274-0 100 ] [ XSLT examples ] Sample of incoming XML document &lt; ?xml version= &quot; 1.0 &quot; ? &gt; { John } { Smith } { Morka } { Ismincius } [ Example 1 (transforming XML to XML) ] This XSLT stylesheet provides templates to transform the XML document: &lt; ?xml version= &quot; 1.0 &quot; encoding= &quot; UTF-8 &quot; ? &gt; Its evaluation results in a new XML document, having another structure: &lt; ?xml version= &quot; 1.0 &quot; encoding= &quot; UTF-8 &quot; ? &gt; { John } { Morka } [ Example 2 (transforming XML to XHTML) ] Processing the following example XSLT file &lt; ?xml version= &quot; 1.0 &quot; encoding= &quot; UTF-8 &quot; ? &gt; &lt; xsl:stylesheet { version= &quot; 1.0 &quot; } { xmlns:xsl= &quot; http://www.w3.org/1999/XSL/Transform &quot; } { xmlns= &quot; http://www.w3.org/1999/xhtml &quot; &gt; } { Testing XML Example } { Persons } {, } &lt; /xsl:stylesheet &gt; with the XML input file shown above results in the following XHTML ( whitespace has been adjusted here for clarity): &lt; ?xml version= &quot; 1.0 &quot; encoding= &quot; UTF-8 &quot; ? &gt; { Testing XML Example } { Persons } { Ismincius, Morka } { Smith, John } This XHTML generates the output below when rendered in a web browser. Rendered XHTML generated from an XML input file and an XSLT transformation. In order for a web browser to be able automatically to apply an XSL transformation to an XML document on display, an XML stylesheet processing instruction can be inserted into XML. So, for example, if the stylesheet in Example 2 above were available as &quot; example2.xsl &quot;, the following instruction could be added to the original incoming XML: [ http://www.w3.org/TR/xslt#section-Embedding-Stylesheets XSL Transformations (XSLT) Version 1.0: W3C Recommendation  – Embedding Stylesheets 16 November 1999 W3C 2009-01-06 ] &lt; ?xml-stylesheet href= &quot; example2.xsl &quot; type= &quot; text/xsl &quot; ? &gt; (In this example, text/xsl is technically incorrect according to the W3C specifications, but it is the only media type that is widely supported across current (2009) browsers.) [ See also ] XProc - a W3C Standard pipeline language which can be used to combine XSLT transformations together with other operations like XQuery, XInclude or HTTP requests XSLT elements - a list of some commonly used XSLT structures XML transformation language - any computer language designed specifically to transform an input XML document into an output XML document that satisfies some specific goal Extensible Stylesheet Language - a family of languages of which XSLT is a member XQuery and XSLT compared XSL formatting objects or XSL-FO - An XML-based language for documents, usually generated by transforming source documents with XSLT, consisting of objects used to create formatted output Identity transform - a starting point for filter chains that add or remove data elements from XML trees in a transformation pipeline Apache Cocoon - a Java -based framework for processing data with XSLT and other transformers. Context Framework - a Java -based web framework using XSLT as sole templating language. Omnimark - another structured text processing language (and a proprietary software) Xs3p - is an XSLT stylesheet that generates XHTML documentation from XML Schema Definition language (XSD) schema. [ References ] [ 2 ] [ Further reading ] XSLT by Doug Tidwell, published by O’Reilly (ISBN 0-596-00053-7) XSLT Cookbook by Sal Mangano, published by O’Reilly (ISBN 0-596-00974-7) XSLT 2.0 Programmer&apos;s Reference by Michael Kay (ISBN 0-764-56909-0) XSLT 2.0 and XPath 2.0 Programmer&apos;s Reference by Michael Kay (ISBN 978-0-470-19274-0) XSLT 2.0 Web Development by Dmitry Kirsanov (ISBN 0-13-140635-3) XSL Companion, 2nd Edition by Neil Bradley, published by Addison-Wesley (ISBN 0-201-77083-0) XSLT and XPath on the Edge (Unlimited Edition) by Jeni Tennison, published by Hungry Minds Inc, U.S. (ISBN 0-7645-4776-3) XSLT &amp; XPath, A Guide to XML Transformations by John Robert Gardner and Zarella Rendon, published by Prentice-Hall (ISBN 0-13-040446-2) XSL-FO by Dave Pawson, published by O&apos;Reilly (ISBN 978-0-596-00355-5) [ External links ] Documentation XSLT 1.0 W3C Recommendation XSLT 2.0 W3C Recommendation XSLT 2.1 W3C Working Draft XSLT Frequently Asked Questions Zvon XSLT 1.0 Reference XSL Concepts and Practical Use by Norman Walsh What kind of language is XSLT? XSLT and Scripting Languages schema-aware.com - examples of schema-aware XSLT XSLT - MDC Docs by Mozilla Developer Network XSLT Reference (MSDN) XSLT Elements (Saxon) Transformation Engines Saxon Xalan Microsoft.Net Tutorials Tutorial from developerWorks by IBM (1 hour) Zvon XSLT Tutorial Quick tutorial W3Schools XSLT Tutorial XSLT by Example: Elements Mailing lists The XSLT mailing list hosted by Mulberrytech XSLT code libraries EXSLT is a widespread community initiative to provide extensions to XSLT. FXSL is a library implementing support for Higher-order function s in XSLT. FXSL is written in XSLT itself. The XSLT Standard Library xsltsl, provides the XSLT developer with a set of XSLT templates for commonly used functions. These are implemented purely in XSLT, that is they do not use any extensions. xsltsl is a SourceForge project. Kernow A GUI for Saxon that provides a point and click interface for running transforms. xslt.js  – Transform XML with XSLT JavaScript library that transforms XML with XSLT in the browser. Further examples XSLT Examples using JavaScript based on wiki examples and w3schools XSLT on the Client How to use XSLT with PHP : Shows how to create a PHP class to convert a PHP array and an XSLT style-sheet into html. XSLT Resource Links from Symphony CMS (based on XSLT) { Category:Declarative programming languages } Category:Functional languages Category:Markup languages Category:Transformation languages Category:World Wide Web Consortium standards Category:XML-based programming languages Category:XML-based standards { bg:XSLT } ca:Extensible Stylesheet Language Transformations cs:Extensible Stylesheet Language Transformations da:XSLT de:XSL Transformation es:Extensible Stylesheet Language Transformations eu:XSLT fa:تبدیلات اکس‌اس‌ال fr:Extensible Stylesheet Language Transformations ko:XSLT id:Extensible Stylesheet Language Transformations is:XSLT it:XSL Transformations lt:XSLT hu:Extensible Stylesheet Language Transformations ms:XSLT nl:Extensible Stylesheet Language Transformations ja:XSL Transformations no:XSLT pl:XSL Transformations pt:XSLT ru:XSLT simple:XSLT fi:XSLT sv:XSLT tr:XSLT uk:XSL Transformations vi:XSLT bat-smg:XSLT zh:XSLT