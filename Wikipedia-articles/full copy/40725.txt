{ A left arithmetic shift of a binary number by 1. The empty position in the least significant bit is filled with a zero. Note that arithmetic left shift may cause an overflow; this is the only way it differs from logical left shift. } A right arithmetic shift of a binary number by 1. The empty position in the most significant bit is filled with a copy of the original MSB. [ HP 2001 ] [ March 2012 ] Arithmetic shift operators in various programming languages Language Left Right VHDL sla The VHDL arithmetic left shift operator is unusual. Instead of filling the LSB of the result with zero, it copies the original LSB into the new LSB. Whilst this is an exact mirror image of the arithmetic right shift, whereas the conventional definition of the operator is not, it is not the conventional definition of the operator, and is not equivalent to multiplication by a power of 2. In the VHDL 2008 standard this strange behavior was left unchanged (for backwards compatibility) for argument types that do not have forced numeric interpretation (e.g. BIT_VECTOR) but &apos;SLA&apos; for unsigned and signed argument types behaves in the expected way (i.e. rightmost positions are filled with zeros). VHDL&apos;s SLL (Shift Left Logical) function does implement the aforementioned &apos;standard&apos; arithmetic shift. sra Verilog &lt; &lt; &lt; &gt; &gt; &gt; The Verilog arithmetic right shift operator only actually performs an arithmetic shift if the first operand is signed. If the first operand is unsigned, the operator actually performs a logical right shift. C / C++ / Go (signed types only) The &gt; &gt; operator in C and C++ is not necessarily an arithmetic shift. Usually it is only an arithmetic shift if used with a signed integer type on its left-hand side. If it is used on an unsigned integer type instead, it will be a logical shift. &lt; &lt; &gt; &gt; Java, JavaScript, Python, PHP, Ruby, etc. &lt; &lt; &gt; &gt; OpenVMS macro language @ &quot; note &quot; Scheme &lt; tt &gt; arithmetic-shift &lt; tt &gt; In Scheme arithmetic-shift can be both left and right shift, depending on the second operand, very similar to the OpenVMS macro language, although R6RS Scheme adds both -right and -left variants. Common Lisp &lt; tt &gt; ash &lt; tt &gt; OCaml lsl asr Standard ML &lt; tt &gt; &lt; &lt; &lt; /tt &gt; ~ &gt; &gt; Haskell shiftL shiftR x86 Assembly SAL SAR In computer programming, an arithmetic shift is a shift operator, sometimes known as a signed shift (though it is not restricted to signed operands). The two basic flavours are the arithmetic left shift and the arithmethic right shift. For binary number s it is a bitwise operation that shifts all of the bits of its operand; every bit in the operand is simply moved a given number of bit positions, and the vacant bit-positions are filled in. Instead of being filled with all 0s, as in logical shift, when shifting to the right, the leftmost bit (usually the sign bit in signed integer representations) is replicated to fill in all the vacant positions (this is a kind of sign extension ). Arithmetic shifts can be useful as efficient ways of performing multiplication or division of signed integers by powers of two. Shifting left by n bits on a signed or unsigned binary number has the effect of multiplying it by 2 n. Shifting right by n bits on a two&apos;s complement signed binary number has the effect of dividing it by 2 n, but it always rounds down (towards negative infinity). This is different from the way rounding is usually done in signed integer division (which rounds towards 0). This discrepancy has led to bugs in more than one compiler. [ January 2011 ] For example, in the x86 instruction set, the SAR instruction (arithmetic right shift) divides a signed number by a power of two, rounding towards negative infinity. [ Hyde 1996 &amp; sect; 6.6.2.2 SAR ] However, the IDIV instruction (signed divide) divides a signed number, rounding towards zero. So a SAR instruction cannot be substituted for an IDIV by power of two instruction nor vice versa. [ Formal definition ] The formal definition of an arithmetic shift, from Federal Standard 1037C is that it is: A shift, applied to the representation of a number in a fixed radix numeration system and in a fixed-point representation system, and in which only the characters representing the fixed-point part of the number are moved. An arithmetic shift is usually equivalent to multiplying the number by a positive or a negative integral power of the radix, except for the effect of any rounding; compare the logical shift with the arithmetic shift, especially in the case of floating-point representation. An important word in the FS 1073C definition is &quot; usually &quot;. [ Equivalence of arithmetic left shift and multiplication ] Arithmetic left shifts are equivalent to multiplication by a (positive, integral) power of the radix (e.g. a multiplication by a power of 2 for binary numbers). Arithmetic left shifts are, with one exception, identical in effect to logical left shifts. The exception is the minor trap that arithmetic shifts may trigger arithmetic overflow whereas logical shifts do not. Obviousely that exception only only hits in real world use cases if a trigger signal for such an overflow is needed by the design its used for. [ Non-equivalence of arithmetic right shift and division ] However, arithmetic right shifts are major traps for the unwary. It is frequently stated that arithmetic right shifts are equivalent to division by a (positive, integral) power of the radix (e.g. a division by a power of 2 for binary numbers), and hence that division by a power of the radix can be optimized by implementing it as an arithmetic right shift. (A shifter is much simpler than a divider. On most processors, shift instructions will execute more quickly than division instructions.) Guy L. Steele quotes a large number of 1960s and 1970s programming handbooks, manuals, and other specifications from companies and institutions such as DEC, IBM, Data General, and ANSI that make such statements. [ Steele 1977 ] [ March 2012 ] However, as Steele points out, they are all wrong. Logical right shifts are equivalent to division by a power of the radix only on &quot; N-1&apos;s-complement &quot; machines (for radix N). Logical shifts of binary numbers are only equivalent to division by a power of 2 when the ones&apos; complement representation of signed numbers is being used, for example. This description has been erroneously brought over from the older ones&apos; complement architectures to newer two&apos;s complement architectures. With two&apos;s complement binary number representations, arithmetic right shift is not equivalent to division by a power of 2. On an &quot; N&apos;s-complement &quot; architecture (for radix N) an arithmetic shift is equivalent to a division that rounds towards negative infinity, not towards zero. Donald Knuth describes this in terms of a floor function. [ Knuth 1969 ] [ March 2012 ] Thus for negative numbers, the equivalence breaks down. The most trivial example of this is the arithmetic right shift of the number -1 (which is represented as all ones) in a two&apos;s complement representation, which yields -1. An arithmetic right shift of the number 1, for comparison, yields 0. These are not the results of conventional, rounding towards zero, integer division. (-1 divided by 2 is 0 when rounding towards zero. One has to round towards negative infinity to yield the answer -1.) The (1999) ISO standard for the C programming language defines the C language&apos;s right shift operator in terms of divisions by powers of 2. [ ISOIEC9899 1999 &amp; sect; 6.5.7 Bitwise shift operators ] Because of the aforementioned non-equivalence, the standard explicitly excludes from that definition the right shifts of signed numbers that have negative values. It doesn&apos;t specify the behaviour of the right shift operator in such circumstances, but instead requires each individual C compiler to specify the behaviour of shifting negative values right. [ FSF 2008 &amp; sect; 4.5 Integers implementation ] { &quot; note &quot; } [ Notes ] [ References ] [ Cross-reference ] [ 30em ] [ Sources used ] [ harv Donald Knuth The Art of Computer Programming, Volume 2 — Seminumerical algorithms 169 –170 Reading, Mass. Addison-Wesley 1969 Donald Knuth ] [ harv Arithmetic shifting considered harmful ACM SIGPLAN Notices archive 12 11 November 1977 61 –69 Guy L. Steele ACM Press New York 10.1145/956641.956647 ] [ CITEREFHP2001 http://h71000.www7.hp.com/doc/73FINAL/4515/4515pro_002.html HP OpenVMS Systems Documentation VAX MACRO and Instruction Set Reference Manual 3.7.1 Arithmetic Shift Operator Hewlett-Packard Development Company April 2001 ] [ CITEREFISOIEC98991999 Programming languages — C International Organization for Standardization 1999 ISO/IEC 9899:1999 ] [ harv CHAPTER SIX: THE 80x86 INSTRUCTION SET (Part 3) 1996-09-26 The Art of ASSEMBLY LANGUAGE PROGRAMMING Randall Hyde http://www.arl.wustl.edu/~lockwood/class/cs306/books/artofasm/Chapter_6/CH06-3.html#HEADING3-120 ] [ CITEREFFSF2008 2008 Free Software Foundation http://gcc.gnu.org/onlinedocs/gcc-4.3.3/gcc/Integers-implementation.html#Integers-implementation GCC manual C Implementation ] Category:Binary arithmetic Category:Operators (programming) ko:산술 시프트