[ Cc1 other uses of CC1 or CC-1 CC1 (disambiguation) ] [ 1987 05 23 ] [ http://www.gnu.org/software/gcc/releases.html GCC Releases 2006-12-27 GNU Project ] { 4.7.0 } [ 2012 03 22 yes/no ] { C, } { C++ } { Cross-platform } { GNU } { Compiler } { GNU General Public License (version 3 or later) } The GNU Compiler Collection (GCC) is a compiler system produced by the GNU Project supporting various programming language s. GCC is a key component of the GNU toolchain. As well as being the official compiler of the unfinished GNU operating system, GCC has been adopted as the standard compiler by most other modern Unix-like computer operating system s, including Linux, and the BSD family. A port to RISC OS has also been developed extensively in recent years. There is also an old (3.0) port of GCC to Plan9, running under its ANSI/POSIX Environment (APE). [ 2011-09-06 http://plan9.bell-labs.com/wiki/plan9/porting_alien_software_to_plan_9/index.html Bell Labs, Lucent Porting alien software to Plan 9 &amp; #124; ] GCC is also available for the widely-used Microsoft Windows operating systems, and for the ARM processor used by many portable devices. GCC has been ported to a wide variety of processor architecture s, and is widely deployed as a tool in commercial, proprietary and closed source software development environments. GCC is also available for most embedded platforms, including Symbian (called gcce), [ http://www.inf.u-szeged.hu/symbian-gcc/ Symbian GCC Improvement Project 2007-11-08 ] AMCC and Freescale Power Architecture -based chips. [ http://www.freescale.com/webapp/sps/site/overview.jsp?code%3DCW_BSP%26amp%3Bfsrch%3D1 Linux Board Support Packages 2008-08-07 ] The compiler can target a wide variety of platforms, including videogame consoles such as the PlayStation 2 [ http://ps2stuff.playstation2-linux.com/gcc_build.html setting up gcc as a cross-compiler ps2stuff 2002-06-08 2008-12-12 ] [ September 2010 H3llBot ] and Dreamcast. [ http://www.ngine.de/gccguide.html sh4 g++ guide http://web.archive.org/web/20021220025554/http%3A//www.ngine.de/gccguide.html 2002-12-20 2008-12-12 This guide is intended for people who want to compile C++ code for their Dreamcast systems ] Several companies [ http://www.fsf.org/resources/service FSF Service Directory ] make a business out of supplying and supporting GCC ports to various platforms, and chip manufacturers today consider a GCC port almost essential to the success of an architecture. [ November 2011 ] Originally named the GNU C Compiler, because it only handled the C programming language, GCC 1.0 was released in 1987, and the compiler was extended to compile C++ in December of that year. Front ends were later developed for Objective-C, Objective-C++, Fortran, Java, Ada, and Go among others. [ http://gcc.gnu.org/onlinedocs/gcc-4.6.0/gcc/G_002b_002b-and-GCC.html Programming Languages Supported by GCC 2011-11-25 GNU Project ] The Free Software Foundation (FSF) distributes GCC under the GNU General Public License (GNU GPL). GCC has played an important role in the growth of free software, as both a tool and an example. [ History ] Richard Stallman &apos;s initial plan [ Stallman Richard About the GNU Project The GNU Project September 20, 2011 http://www.gnu.org/gnu/thegnuproject.html Hoping to avoid the need to write the whole compiler myself, I obtained the source code for the Pastel compiler, which was a multiplatform compiler developed at Lawrence Livermore Lab. It supported, and was written in, an extended version of Pascal, designed to be a system-programming language. I added a C front end, and began porting it to the Motorola 68000 computer. But I had to give that up when I discovered that the compiler needed many megabytes of stack space, and the available 68000 Unix system would only allow 64k.... I concluded I would have to write a new compiler from scratch. That new compiler is now known as GCC; none of the Pastel compiler is used in it, but I managed to adapt and use the C front end that I had written. October 9, 2011 ] was to rewrite an existing compiler from Lawrence Livermore Lab from Pastel to C with some help from Len Tower and others. [ Puzo Jerome E. Gnu&apos;s Zoo GNU&apos;S Bulletin 1 1 February 1986 Free Software Foundation http://www.gnu.org/bulletins/bull1.txt Although I have a portable C and Pascal compiler,... most of the compiler is written in Pastel,... so it must all be rewritten into C. Len Tower, the sole full-time GNU staff person, is working on this, with one or two assistants. 2007-08-11 ] Stallman wrote a new C front end for the Livermore compiler but then realized that it required megabytes of stack space, an impossibility on a 68000 Unix system with only 64K, and concluded he would have to write a new compiler from scratch. None of the Pastel compiler code ended up in GCC, though Stallman did use the C front end he had written. GCC was first released March 22, 1987, available by ftp from MIT. [ GNU C compiler beta test release Richard M. Stallman (forwarded by Leonard H. Tower Jr.) March 22, 1987 comp.lang.c http://groups.google.com/group/comp.lang.misc/msg/32eda22392c20f98 October 9, 2011 The GNU C compiler is now available for ftp from the file /u2/emacs/gcc.tar on prep.ai.mit.edu. This includes machine descriptions for vax and sun, 60 pages of documentation on writing machine descriptions... the ANSI standard (Nov 86) C preprocessor and 30 pages of reference manual for it. This compiler compiles itself correctly on the 68020 and did so recently on the vax. It recently compiled Emacs correctly on the 68020, and has also compiled tex-in-C and Kyoto Common Lisp. ] Stallman was listed as the author but cited others for their contributions, including Jack Davidson and Christopher Fraser for the idea of using RTL as an intermediate language, Paul Rubin for writing most of the preprocessor and Leonard Tower for &quot; parts of the parser, RTL generator, RTL definitions, and of the Vax machine description. &quot; [ Stallman Richard M. Internals of GNU CC http://trinity.engr.uconn.edu/~vamsik/internals.pdf Free Software Foundation, Inc. 24 April 1988 Contributors to GNU CC 7 The idea of using RTL and some of the optimization ideas came from the U. of Arizona Portable Optimizer, written by Jack Davidson and Christopher Fraser.... Leonard Tower wrote parts of the parser, RTL generator, RTL definitions, and of the Vax machine description. October 3, 2011 ] By 1991, GCC 1.x had reached a point of stability, but architectural limitations prevented many desired improvements, so the FSF started work on GCC 2.x. [ August 2011 ] As GCC was licensed under the GPL, programmers wanting to work in other directions—particularly those writing interfaces for languages other than C —were free to develop their own fork of the compiler (provided they meet the GPL&apos;s terms, including its requirements to distribute source code ). Multiple forks proved inefficient and unwieldy, however, and the difficulty in getting work accepted by the official GCC project was greatly frustrating for many [ Henkel-Wallace David A new compiler project to merge the existing GCC forks http://gcc.gnu.org/news/announcement.html 15 August 1997 On the other hand, Cygnus, the Linux folks, the pgcc folks, the Fortran folks and many others have done development work which has not yet gone into the GCC2 tree despite years of efforts to make it possible.... These forks are painful and waste time... May 25, 2012 ]. The FSF kept such close control on what was added to the official version of GCC 2.x that GCC was used as one example of the &quot; cathedral &quot; development model in Eric S. Raymond &apos;s essay The Cathedral and the Bazaar. With the release of 4.4BSD in 1994, GCC became the default compiler for most BSD systems. [ August 2011 ] [ EGCS fork ] In 1997, a group of developers formed EGCS (Experimental/Enhanced GNU Compiler System), [ Pentium Compiler FAQ http://home.schmorp.de/pgcc-faq.html#egcs ] &lt; /ref &gt; to merge several experimental forks into a single project. The basis of the merger was a GCC development snapshot taken between the 2.7 and 2.81 releases. Projects merged included g77 ( FORTRAN ), PGCC ( P5 Pentium -optimized GCC), many C++ improvements, and many new architectures and operating system variants. [ A Brief History of GCC http://gcc.gnu.org/wiki/History ] [ The Short History of GCC development http://www.softpanorama.org/People/Stallman/history_of_gcc_development.shtml ] EGCS development proved considerably more vigorous than GCC development, so much so that the FSF officially halted development on their GCC 2.x compiler, &quot; blessed &quot; EGCS as the official version of GCC and appointed the EGCS project as the GCC maintainers in April 1999. Furthermore, the project explicitly adopted the &quot; bazaar &quot; model over the &quot; cathedral &quot; model. With the release of GCC 2.95 in July 1999, the two projects were once again united. GCC is now maintained by a varied group of programmers from around the world, under the direction of a steering committee. [ http://gcc.gnu.org/steering.html GCC steering committee ] It has been ported to more kinds of processors and operating system s than any other compiler. { Linux Information Project (LINFO) accessed 2010-04-27 } [ Development ] [ GCC stable release ] The current stable version of GCC is 4.7.0, which was released on March 22, 2012. GCC 4.6 supports many new Objective-C features, such as declared and synthesized properties, dot syntax, fast enumeration, optional protocol methods, method/protocol/class attributes, class extensions and a new GNU Objective-C runtime API. It also supports the Go programming language and includes the libquadmath library, which provides quadruple-precision mathematical functions on targets supporting the __float128 datatype. The library is used to provide the REAL(16) type in GNU Fortran on such targets. GCC uses many standard tools in its build, including Perl, Flex, Bison, and other common tools. In addition it currently requires three additional libraries to be present in order to build: GMP, MPC, and MPFR. Some optimization features need extra libraries, like Parma Polyhedra Library or Cloog (but GCC could be built without them). The previous major version, 4.5, was initially released on April 14, 2010 (last minor version is 4.5.3, released on April 29, 2011). It included several minor new features (new targets, new language dialects) and a couple of major new features: TreeHydra to help with Mozilla code development DragonEgg to use the GCC front-end with LLVM MELT (site GCC MELT ) to enable coding GCC extensions in a lispy domain-specific language providing powerful Pattern-matching MILEPOST CTuning to use machine learning techniques to tune the compiler. [ GCC trunk ] The trunk concentrates the major part of the development efforts, where new features are implemented and tested. Eventually, the code from the trunk will become the next major release of GCC, with version 4.8. [ Uses ] GCC is often chosen for developing software that is required to execute on a wide variety of hardware and/or operating systems. [ March 2011 ] System-specific compilers provided by hardware or OS vendors can differ substantially, complicating both the software&apos;s source code and the scripts that invoke the compiler to build it. [ March 2011 ] With GCC, most of the compiler is the same on every platform, so only code that explicitly uses platform-specific features must be rewritten for each system. [ March 2011 ] [ Languages ] { The standard compiler release 4.6 includes front ends for } { C ( gcc ), } { C++ ( g++ ), } { Objective-C ( gobjc ), } { Fortran ( } { gfortran ), } { Java ( } { gcj ), } { Ada ( } { GNAT ), and } { Go ( gccgo ). &quot; GCC Front Ends &quot;, gnu.org, Retrieved November 25, 2011. } { Also available, but not in standard are } { Pascal ( } { gpc ), } { Mercury, } { Modula-2, } { Modula-3, } { PL/I, } { D ( gdc ) } [ http://bitbucket.org/goshawk/gdc/ gdc project on bitbucket 3 July 2010 ] {, and } { VHDL ( ghdl ). A popular parallel language extension, } { OpenMP, is also supported. } The Fortran front end was g77 before version 4.0, which only supports FORTRAN 77. In newer versions, g77 is dropped in favor of the new gfortran front end that supports Fortran 95 and parts of Fortran 2003 as well. [ http://gcc.gnu.org/wiki/Fortran2003 Fortran 2003 Features in GNU Fortran ] As the later Fortran standards incorporate the F77 standard, standards-compliant F77 code is also standards-compliant F90/95 code, and so can be compiled without trouble in gfortran. A front-end for CHILL was dropped due to a lack of maintenance. { [PATCH &amp; #93; Remove chill, gcc.gnu.org, Retrieved July 29, 2010. } A few experimental branches exist to support additional languages, such as the GCC UPC compiler [ http://www.intrepid.com/upc.html GCC UPC (GCC Unified Parallel C) &amp; #124; intrepid.com intrepid.com &lt; ! 2006-02-20 2009-03-11 ] for Unified Parallel C. [ Architectures ] GCC target processor families as of version 4.3 include: [ 15em no ] Alpha ARM AVR Blackfin H8/300 HC12 IA-32 ( x86 ) IA-64 MIPS Motorola 68000 PA-RISC PDP-11 PowerPC R8C / M16C / M32C SPARC SPU SuperH System/390 / zSeries VAX x86-64 Lesser-known target processors supported in the standard release have included: [ 15em no ] 68HC11 A29K ARC CR16 C6x D30V DSP16xx Epiphany ETRAX CRIS FR-30 FR-V Intel i960 IP2000 M32R MCORE MIL-STD-1750A MMIX MN10200 MN10300 Motorola 88000 NS32K ROMP RL78 Stormy16 V850 Xtensa Additional processors have been supported by GCC versions maintained separately from the FSF version: [ 15em no ] [ Hexagon Project Wiki https://www.codeaurora.org/xwiki/bin/Hexagon/ ] [ Hexagon dowload https://www.codeaurora.org/patches/quic/hexagon/%26quot%3B ] [ sx-gcc: port gcc to nec sx vector cpu http://code.google.com/p/sx-gcc/ ] Cortus APS3 AVR32 C166 and C167 D10V EISC eSi-RISC Hexagon LatticeMico32 LatticeMico8 MeP MicroBlaze Motorola 6809 MSP430 NEC SX architecture Nios II and Nios OpenRISC 1200 PDP-10 PIC24/dsPIC Propeller System/370 TIGCC ( m68k variant) TriCore Z8000 The gcj Java compiler can target either a native machine language architecture or the Java Virtual Machine &apos;s Java bytecode. [ http://gcc.gnu.org/java/ The GNU Compiler for the Java Programming Language 2010-04-22 ] When retargeting GCC to a new platform, bootstrapping is often used. [ Structure ] GCC&apos;s external interface is generally standard for a UNIX compiler. Users invoke a driver program named gcc, which interprets command arguments, decides which language compilers to use for each input file, runs the assembler on their output, and then possibly runs the linker to produce a complete executable binary. Each of the language compilers is a separate program that inputs source code and outputs machine code. All have a common internal structure. A per-language front end parses the source code in that language and produces an abstract syntax tree ( &quot; tree &quot; for short). These are, if necessary, converted to the middle-end&apos;s input representation, called GENERIC form; the middle-end then gradually transforms the program towards its final form. Compiler optimization s and static code analysis techniques (such as FORTIFY_SOURCE, [ http://fedoraproject.org/wiki/Security/Features Security Features: Compile Time Buffer Checks (FORTIFY_SOURCE) fedoraproject.org 2009-03-11 ] a compiler directive that attempts to discover some buffer overflow s ) are applied to the code. These work on multiple representations, mostly the architecture-independent GIMPLE representation and the architecture-dependent RTL representation. Finally, machine code is produced using architecture-specific pattern matching originally based on an algorithm of Jack Davidson and Chris Fraser. GCC is written primarily in C except for parts of the Ada front end. The distribution includes the standard libraries for Ada, C++, and Java whose code is mostly written in those languages. [ http://www.ohloh.net/projects/gcc/analyses/latest languages used to make GCC ] On some platforms, the distribution also includes a low-level runtime library, libgcc, written in a combination of machine-independent C and processor-specific machine code, designed primarily to handle arithmetic operations that the target processor cannot perform directly. { GCC Internals, GCC.org, Retrieved March 01, 2010. } In May 2010, the GCC steering committee decided to allow use of a C++ compiler to compile GCC. [ GCC allows C++ – to some degree http://www.h-online.com/open/news/item/GCC-allows-C-to-some-degree-1012611.html The H 1 June 2010 ] The compiler will be written in C plus a subset of features from C++. In particular, this was decided so that GCC&apos;s developers could use the &quot; destructors &quot; and &quot; generics &quot; features of C++. [ http://lists.gnu.org/archive/html/emacs-devel/2010-07/msg00518.html An email by Richard Stallman on emacs-devel The reason the GCC developers wanted to use it is for destructors and generics. These aren&apos;t much use in Emacs, which has GC and in which data types are handled at the Lisp level. ] [ Front-ends ] Frontends vary internally, having to produce trees that can be handled by the backend. Currently, the parsers are all hand-coded recursive descent parser s, though there is no reason why a parser generator could not be used for new front-ends in the future (version 2 of the C compiler used a bison based grammar). Until recently, the tree representation of the program was not fully independent of the processor being targeted. The meaning of a tree was somewhat different for different language front-ends, and front-ends could provide their own tree codes. This was simplified with the introduction of GENERIC and GIMPLE, two new forms of language-independent trees that were introduced with the advent of GCC 4.0. GENERIC is more complex, based on the GCC 3.x Java front-end&apos;s intermediate representation. GIMPLE is a simplified GENERIC, in which various constructs are lowered to multiple GIMPLE instructions. The C, C++ and Java front ends produce GENERIC directly in the front end. Other front ends instead have different intermediate representations after parsing and convert these to GENERIC. In either case, the so-called &quot; gimplifier &quot; then lowers this more complex form into the simpler SSA -based GIMPLE form that is the common language for a large number of new powerful language- and architecture-independent global (function scope) optimizations. [ GENERIC and GIMPLE ] GENERIC is an intermediate representation language used as a &quot; middle-end &quot; while compiling source code into executable binaries. A subset, called GIMPLE, is targeted by all the front-ends of GCC. The middle stage of GCC does all the code analysis and optimization, working independently of both the compiled language and the target architecture, starting from the GENERIC { GENERIC in GNU Compiler Collection Internals } representation and expanding it to Register Transfer Language. The GENERIC representation contains only the subset of the imperative programming constructs optimised by the middle-end. In transforming the source code to GIMPLE { GIMPLE in GNU Compiler Collection Internals }, complex expressions are split into a three address code using temporary variable s. This representation was inspired by the SIMPLE representation proposed in the McCAT compiler { McCAT } by Laurie J. Hendren { Laurie J. Hendren } for simplifying the analysis and optimization of imperative programs. [ Optimization ] Optimization can occur during any phase of compilation, however the bulk of optimizations are performed after the syntax and semantic analysis of the front-end and before the code generation of the back-end, thus a common, even though somewhat contradictory, name for this part of the compiler is &quot; middle end. &quot; The exact set of GCC optimizations varies from release to release as it develops, but includes the standard algorithms, such as loop optimization, jump threading, common subexpression elimination, instruction scheduling, and so forth. The RTL optimizations are of less importance with the addition of global SSA-based optimizations on GIMPLE trees, { From Source to Binary: The Inner Workings of GCC, by Diego Novillo, } { &apos;&apos;Red Hat Magazine&apos;&apos;, December 2004 } as RTL optimizations have a much more limited scope, and have less high-level information. Some of these optimizations performed at this level include dead code elimination, partial redundancy elimination, global value numbering, sparse conditional constant propagation, and scalar replacement of aggregates. Array dependence based optimizations such as automatic vectorization and automatic parallelization are also performed. Profile-guided optimization is also possible as demonstrated here: http://gcc.gnu.org/install/build.html#TOC4 [ Back-end ] The behavior of GCC&apos;s back end is partly specified by preprocessor macros and functions specific to a target architecture, for instance to define the endianness, word size, and calling convention s. The front part of the back end uses these to help decide RTL generation, so although GCC&apos;s RTL is nominally processor-independent, the initial sequence of abstract instructions is already adapted to the target. At any moment, the actual RTL instructions forming the program representation have to comply with the machine description of the target architecture. The machine description file contains RTL patterns, along with operand constraints, and code snippets to output the final assembly. The constraints indicate that a particular RTL pattern might only apply (for example) to certain hardware registers, or (for example) allow immediate operand offsets of only a limited size (e.g. 12, 16, 24,... bit offsets, etc.). During RTL generation, the constraints for the given target architecture are checked. In order to issue a given snippet of RTL, it must match one (or more) of the RTL patterns in the machine description file, and satisfy the constraints for that pattern; otherwise, it would be impossible to convert the final RTL into machine code. Towards the end of compilation, valid RTL is reduced to a strict form in which each instruction refers to real machine registers and a pattern from the target&apos;s machine description file. Forming strict RTL is a complicated task; an important step is register allocation, where real, hardware registers are chosen to replace the initially-assigned pseudo-registers. This is followed by a &quot; reloading &quot; phase; any pseudo-registers that were not assigned a real hardware register are &apos;spilled&apos; to the stack, and RTL to perform this spilling is generated. Likewise, offsets that are too large to fit in an actual instruction must be broken up and replaced by RTL sequences that will obey the offset constraints. In the final phase the machine code is built by calling a small snippet of code, associated with each pattern, to generate the real instructions from the target&apos;s instruction set, using the final registers, offsets and addresses chosen during the reload phase. The assembly-generation snippet may be just a string; in which case, a simple string substitution of the registers, offsets, and/or addresses into the string is performed. The assembly-generation snippet may also be a short block of C code, performing some additional work, but ultimately returning a string containing the valid machine code. [ Compatible IDEs ] Most integrated development environment s written for GNU/Linux and some for other operating systems support GCC. These include: [ 3 ] Anjuta Code::Blocks CodeLite Dev-C++ Eclipse geany KDevelop NetBeans Qt Creator Xcode [ Debugging GCC programs ] The primary tool used to debug GCC code is the GNU Debugger (gdb). Among more specialized tools are Valgrind, for finding memory errors and leaks, and the graph profiler ( gprof ) that can determine how much time is spent in which routines, and how often they are called; this requires programs to be compiled with profiling options. [ References ] [ 30em ] [ See also ] [ Free software ] MinGW (Windows port of GCC) List of compilers [ Further reading ] Richard Stallman : Using the GNU Compiler Collection (GCC), Free Software Foundation, 2008. Richard Stallman : GNU Compiler Collection (GCC) Internals, Free Software Foundation, 2008. Brian J. Gough : An Introduction to GCC, Network Theory Ltd., 2004 (Revised August 2005). ISBN 0-9541617-9-3. Arthur Griffith, GCC: The Complete Reference. McGrawHill/Osborne, 2002. ISBN 0-07-222405-3. [ External links ] [ GNU C Compiler Internals ] [ 2006-03-02 New GCC Heavy on Optimization internetnews.com Kerner Sean Michael http://www.internetnews.com/dev-news/article.php/3588926 ] [ 2005-04-22 Open Source GCC 4.0: Older, Faster internetnews.com Kerner Sean Michael http://www.internetnews.com/dev-news/article.php/3499881 ] GCC homepage The official GCC manuals and user documentation, by the GCC developers Collection of GCC 4.0.2 architecture and internals documents at I.I.T. Bombay. From Source to Binary: The Inner Workings of GCC, by Diego Novillo, &apos;&apos;Red Hat Magazine&apos;&apos;, December 2004 A 2003 paper on GENERIC and GIMPLE Marketing Cygnus Support, an essay covering GCC development for the 1990s, with 30 monthly reports for in the &quot; Inside Cygnus Engineering &quot; section near the end. EGCS 1.0 announcement EGCS 1.0 features list Fear of Forking, an essay by Rick Moen recording seven well-known forks, including the GCC/EGCS one A compiler course project based on GCC at the University of Rochester The stack-smashing protector, a GCC extension Category:1987 software Category:C compilers Category:C++ compilers Category:Compilers Category:Fortran compilers Category:Free compilers and interpreters Category:Cross-platform free software Compiler Collection Category:Java development tools Category:Pascal compilers Category:Unix programming tools ar:تجميعة مصرفات جنو bg:GNU Compiler Collection bs:GNU Compiler Collection ca:GNU Compiler Collection cv:GNU Compiler Collection cs:GCC da:GCC de:GNU Compiler Collection et:GNU Compiler Collection es:GNU Compiler Collection eo:GCC eu:GNU Compiler Collection fa:جی‌سی‌سی fr:GNU Compiler Collection gl:GNU Compiler Collection ko:GNU 컴파일러 모음 hy:GCC hi:जीसीसी hr:GNU Compiler Collection it:GNU Compiler Collection he:GCC ka:GNU Compiler Collection la:GCC lt:GCC hu:GCC (informatika) ml:ഗ്നു കമ്പൈലർ ശേഖരം nl:GNU Compiler Collection ja:GNUコンパイラコレクション no:GCC pl:GNU Compiler Collection pt:GNU Compiler Collection ro:GNU Compiler Collection ru:GNU Compiler Collection sk:GNU Compiler Collection sl:GNU Compiler Collection sr:ГНУ колекција компајлера fi:GCC sv:GNU Compiler Collection te:గ్నూ కంపైలర్ కలెక్షన్ th:ชุดแปลโปรแกรมของกนู tr:GNU Compiler Collection uk:GNU Compiler Collection vi:Bộ trình dịch GNU zh:GCC